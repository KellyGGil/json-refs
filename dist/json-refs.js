var JsonRefs;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var _ = __webpack_require__(3121);

var gl = __webpack_require__(9336);

var path = __webpack_require__(7809);

var PathLoader = __webpack_require__(7749);

var qs = __webpack_require__(7216);

var slash = __webpack_require__(1596);

var URI = __webpack_require__(3129);

var badPtrTokenRegex = /~(?:[^01]|$)/g;
var remoteCache = {};
var remoteTypes = ['relative', 'remote'];
var remoteUriTypes = ['absolute', 'uri'];
var uriDetailsCache = {}; // Load promises polyfill if necessary

/* istanbul ignore if */

if (typeof Promise === 'undefined') {
  __webpack_require__(606);
}
/* Internal Functions */


function combineQueryParams(qs1, qs2) {
  var combined = {};

  function mergeQueryParams(obj) {
    _.forOwn(obj, function (val, key) {
      combined[key] = val;
    });
  }

  mergeQueryParams(qs.parse(qs1 || ''));
  mergeQueryParams(qs.parse(qs2 || ''));
  return Object.keys(combined).length === 0 ? undefined : qs.stringify(combined);
}

function combineURIs(u1, u2) {
  // Convert Windows paths
  if (_.isString(u1)) {
    u1 = slash(u1);
  }

  if (_.isString(u2)) {
    u2 = slash(u2);
  }

  var u2Details = parseURI(_.isUndefined(u2) ? '' : u2);
  var u1Details;
  var combinedDetails;

  if (remoteUriTypes.indexOf(u2Details.reference) > -1) {
    combinedDetails = u2Details;
  } else {
    u1Details = _.isUndefined(u1) ? undefined : parseURI(u1);

    if (!_.isUndefined(u1Details)) {
      combinedDetails = u1Details; // Join the paths

      combinedDetails.path = slash(path.join(u1Details.path, u2Details.path)); // Join query parameters

      combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);
    } else {
      combinedDetails = u2Details;
    }
  } // Remove the fragment


  combinedDetails.fragment = undefined; // For relative URIs, add back the '..' since it was removed above

  return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 && combinedDetails.path.indexOf('../') === 0 ? '../' : '') + URI.serialize(combinedDetails);
}

function findAncestors(obj, path) {
  var ancestors = [];
  var node;

  if (path.length > 0) {
    node = obj;
    path.slice(0, path.length - 1).forEach(function (seg) {
      if (seg in node) {
        node = node[seg];
        ancestors.push(node);
      }
    });
  }

  return ancestors;
}

function isRemote(refDetails) {
  return remoteTypes.indexOf(getRefType(refDetails)) > -1;
}

function isValid(refDetails) {
  return _.isUndefined(refDetails.error) && refDetails.type !== 'invalid';
}

function findValue(obj, path) {
  var value = obj; // Using this manual approach instead of _.get since we have to decodeURI the segments

  path.forEach(function (seg) {
    if (seg in value) {
      value = value[seg];
    } else {
      throw Error('JSON Pointer points to missing location: ' + pathToPtr(path));
    }
  });
  return value;
}

function getExtraRefKeys(ref) {
  return Object.keys(ref).filter(function (key) {
    return key !== '$ref';
  });
}

function getRefType(refDetails) {
  var type; // Convert the URI reference to one of our types

  switch (refDetails.uriDetails.reference) {
    case 'absolute':
    case 'uri':
      type = 'remote';
      break;

    case 'same-document':
      type = 'local';
      break;

    default:
      type = refDetails.uriDetails.reference;
  }

  return type;
}

function getRemoteDocument(url, options) {
  var cacheEntry = remoteCache[url];
  var allTasks = Promise.resolve();

  var loaderOptions = _.cloneDeep(options.loaderOptions || {});

  if (_.isUndefined(cacheEntry)) {
    // If there is no content processor, default to processing the raw response as JSON
    if (_.isUndefined(loaderOptions.processContent)) {
      loaderOptions.processContent = function (res, callback) {
        callback(undefined, JSON.parse(res.text));
      };
    } // Attempt to load the resource using path-loader


    allTasks = PathLoader.load(decodeURI(url), loaderOptions); // Update the cache

    allTasks = allTasks.then(function (res) {
      remoteCache[url] = {
        value: res
      };
      return res;
    })["catch"](function (err) {
      remoteCache[url] = {
        error: err
      };
      throw err;
    });
  } else {
    // Return the cached version
    allTasks = allTasks.then(function () {
      if (_.isError(cacheEntry.error)) {
        throw cacheEntry.error;
      } else {
        return cacheEntry.value;
      }
    });
  } // Return a cloned version to avoid updating the cache


  allTasks = allTasks.then(function (res) {
    return _.cloneDeep(res);
  });
  return allTasks;
}

function isRefLike(obj, throwWithDetails) {
  var refLike = true;

  try {
    if (!_.isPlainObject(obj)) {
      throw new Error('obj is not an Object');
    } else if (!_.isString(obj.$ref)) {
      throw new Error('obj.$ref is not a String');
    }
  } catch (err) {
    if (throwWithDetails) {
      throw err;
    }

    refLike = false;
  }

  return refLike;
}

function makeAbsolute(location) {
  if (location.indexOf('://') === -1 && !path.isAbsolute(location)) {
    return path.resolve(process.cwd(), location);
  } else {
    return location;
  }
}

function makeRefFilter(options) {
  var refFilter;
  var validTypes;

  if (_.isArray(options.filter) || _.isString(options.filter)) {
    validTypes = _.isString(options.filter) ? [options.filter] : options.filter;

    refFilter = function refFilter(refDetails) {
      // Check the exact type or for invalid URIs, check its original type
      return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;
    };
  } else if (_.isFunction(options.filter)) {
    refFilter = options.filter;
  } else if (_.isUndefined(options.filter)) {
    refFilter = function refFilter() {
      return true;
    };
  }

  return function (refDetails, path) {
    return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);
  };
}

function makeSubDocPath(options) {
  var subDocPath;

  if (_.isArray(options.subDocPath)) {
    subDocPath = options.subDocPath;
  } else if (_.isString(options.subDocPath)) {
    subDocPath = pathFromPtr(options.subDocPath);
  } else if (_.isUndefined(options.subDocPath)) {
    subDocPath = [];
  }

  return subDocPath;
}

function markMissing(refDetails, err) {
  refDetails.error = err.message;
  refDetails.missing = true;
}

function parseURI(uri) {
  // We decode first to avoid doubly encoding
  return URI.parse(uri);
}

function buildRefModel(document, options, metadata) {
  var allTasks = Promise.resolve();
  var subDocPtr = pathToPtr(options.subDocPath);
  var absLocation = makeAbsolute(options.location);
  var relativeBase = path.dirname(options.location);
  var docDepKey = absLocation + subDocPtr;
  var refs;
  var rOptions; // Store the document in the metadata if necessary

  if (_.isUndefined(metadata.docs[absLocation])) {
    metadata.docs[absLocation] = document;
  } // If there are no dependencies stored for the location+subDocPath, we've never seen it before and will process it


  if (_.isUndefined(metadata.deps[docDepKey])) {
    metadata.deps[docDepKey] = {}; // Find the references based on the options

    refs = findRefs(document, options); // Iterate over the references and process

    _.forOwn(refs, function (refDetails, refPtr) {
      var refKey = makeAbsolute(options.location) + refPtr;
      var refdKey = refDetails.refdId = decodeURIComponent(makeAbsolute(isRemote(refDetails) ? combineURIs(relativeBase, refDetails.uri) : options.location) + '#' + (refDetails.uri.indexOf('#') > -1 ? refDetails.uri.split('#')[1] : '')); // Record reference metadata

      metadata.refs[refKey] = refDetails; // Do not process invalid references

      if (!isValid(refDetails)) {
        return;
      } // Record the fully-qualified URI


      refDetails.fqURI = refdKey; // Record dependency (relative to the document's sub-document path)

      metadata.deps[docDepKey][refPtr === subDocPtr ? '#' : refPtr.replace(subDocPtr + '/', '#/')] = refdKey; // Do not process directly-circular references (to an ancestor or self)

      if (refKey.indexOf(refdKey + '/') === 0 || refKey === refdKey) {
        refDetails.circular = true;
        return;
      } // Prepare the options for subsequent processDocument calls


      rOptions = _.cloneDeep(options);
      rOptions.subDocPath = _.isUndefined(refDetails.uriDetails.fragment) ? [] : pathFromPtr(decodeURIComponent(refDetails.uriDetails.fragment)); // Resolve the reference

      if (isRemote(refDetails)) {
        // Delete filter.options because all remote references should be fully resolved
        delete rOptions.filter; // The new location being referenced

        rOptions.location = refdKey.split('#')[0];
        allTasks = allTasks.then(function (nMetadata, nOptions) {
          return function () {
            var rAbsLocation = makeAbsolute(nOptions.location);
            var rDoc = nMetadata.docs[rAbsLocation];

            if (_.isUndefined(rDoc)) {
              // We have no cache so we must retrieve the document
              return getRemoteDocument(rAbsLocation, nOptions)["catch"](function (err) {
                // Store the response in the document cache
                nMetadata.docs[rAbsLocation] = err; // Return the error to allow the subsequent `then` to handle both errors and successes

                return err;
              });
            } else {
              // We have already retrieved (or attempted to) the document and should use the cached version in the
              // metadata since it could already be processed some.
              return Promise.resolve().then(function () {
                return rDoc;
              });
            }
          };
        }(metadata, rOptions));
      } else {
        allTasks = allTasks.then(function () {
          return document;
        });
      } // Process the remote document or the referenced portion of the local document


      allTasks = allTasks.then(function (nMetadata, nOptions, nRefDetails) {
        return function (doc) {
          if (_.isError(doc)) {
            markMissing(nRefDetails, doc);
          } else {
            // Wrapped in a try/catch since findRefs throws
            try {
              return buildRefModel(doc, nOptions, nMetadata)["catch"](function (err) {
                markMissing(nRefDetails, err);
              });
            } catch (err) {
              markMissing(nRefDetails, err);
            }
          }
        };
      }(metadata, rOptions, refDetails));
    });
  }

  return allTasks;
}

function setValue(obj, refPath, value) {
  findValue(obj, refPath.slice(0, refPath.length - 1))[refPath[refPath.length - 1]] = value;
}

function walk(ancestors, node, path, fn) {
  var processChildren = true;

  function walkItem(item, segment) {
    path.push(segment);
    walk(ancestors, item, path, fn);
    path.pop();
  } // Call the iteratee


  if (_.isFunction(fn)) {
    processChildren = fn(ancestors, node, path);
  } // We do not process circular objects again


  if (ancestors.indexOf(node) === -1) {
    ancestors.push(node);

    if (processChildren !== false) {
      if (_.isArray(node)) {
        node.forEach(function (member, index) {
          walkItem(member, index.toString());
        });
      } else if (_.isObject(node)) {
        _.forOwn(node, function (cNode, key) {
          walkItem(cNode, key);
        });
      }
    }

    ancestors.pop();
  }
}

function validateOptions(options, obj) {
  var locationParts;
  var shouldDecode;

  if (_.isUndefined(options)) {
    // Default to an empty options object
    options = {};
  } else {
    // Clone the options so we do not alter the ones passed in
    options = _.cloneDeep(options);
  }

  if (!_.isObject(options)) {
    throw new TypeError('options must be an Object');
  } else if (!_.isUndefined(options.resolveCirculars) && !_.isBoolean(options.resolveCirculars)) {
    throw new TypeError('options.resolveCirculars must be a Boolean');
  } else if (!_.isUndefined(options.filter) && !_.isArray(options.filter) && !_.isFunction(options.filter) && !_.isString(options.filter)) {
    throw new TypeError('options.filter must be an Array, a Function of a String');
  } else if (!_.isUndefined(options.includeInvalid) && !_.isBoolean(options.includeInvalid)) {
    throw new TypeError('options.includeInvalid must be a Boolean');
  } else if (!_.isUndefined(options.location) && !_.isString(options.location)) {
    throw new TypeError('options.location must be a String');
  } else if (!_.isUndefined(options.refPreProcessor) && !_.isFunction(options.refPreProcessor)) {
    throw new TypeError('options.refPreProcessor must be a Function');
  } else if (!_.isUndefined(options.refPostProcessor) && !_.isFunction(options.refPostProcessor)) {
    throw new TypeError('options.refPostProcessor must be a Function');
  } else if (!_.isUndefined(options.subDocPath) && !_.isArray(options.subDocPath) && !isPtr(options.subDocPath)) {
    // If a pointer is provided, throw an error if it's not the proper type
    throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');
  } // Default to false for allowing circulars


  if (_.isUndefined(options.resolveCirculars)) {
    options.resolveCirculars = false;
  }

  options.filter = makeRefFilter(options); // options.location is not officially supported yet but will be when Issue 88 is complete

  if (_.isUndefined(options.location)) {
    options.location = makeAbsolute('./root.json');
  }

  locationParts = options.location.split('#'); // If options.location contains a fragment, turn it into an options.subDocPath

  if (locationParts.length > 1) {
    options.subDocPath = '#' + locationParts[1];
  }

  shouldDecode = decodeURI(options.location) === options.location; // Just to be safe, remove any accidental fragment as it would break things

  options.location = combineURIs(options.location, undefined); // If the location was not encoded, meke sure it's not when we get it back (Issue #138)

  if (shouldDecode) {
    options.location = decodeURI(options.location);
  } // Set the subDocPath to avoid everyone else having to compute it


  options.subDocPath = makeSubDocPath(options);

  if (!_.isUndefined(obj)) {
    try {
      findValue(obj, options.subDocPath);
    } catch (err) {
      err.message = err.message.replace('JSON Pointer', 'options.subDocPath');
      throw err;
    }
  }

  return options;
}

function decodePath(path) {
  if (!_.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!_.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~1/g, '/').replace(/~0/g, '~');
  });
}

function encodePath(path) {
  if (!_.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!_.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~/g, '~0').replace(/\//g, '~1');
  });
}

function findRefs(obj, options) {
  var refs = {}; // Validate the provided document

  if (!_.isArray(obj) && !_.isObject(obj)) {
    throw new TypeError('obj must be an Array or an Object');
  } // Validate options


  options = validateOptions(options, obj); // Walk the document (or sub document) and find all JSON References

  walk(findAncestors(obj, options.subDocPath), findValue(obj, options.subDocPath), _.cloneDeep(options.subDocPath), function (ancestors, node, path) {
    var processChildren = true;
    var refDetails;
    var refPtr;

    if (isRefLike(node)) {
      // Pre-process the node when necessary
      if (!_.isUndefined(options.refPreProcessor)) {
        node = options.refPreProcessor(_.cloneDeep(node), path);
      }

      refDetails = getRefDetails(node); // Post-process the reference details

      if (!_.isUndefined(options.refPostProcessor)) {
        refDetails = options.refPostProcessor(refDetails, path);
      }

      if (options.filter(refDetails, path)) {
        refPtr = pathToPtr(path);
        refs[refPtr] = refDetails;
      } // Whenever a JSON Reference has extra children, its children should not be processed.
      //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3


      if (getExtraRefKeys(node).length > 0) {
        processChildren = false;
      }
    }

    return processChildren;
  });
  return refs;
}

function findRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!_.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (_.isUndefined(options)) {
      options = {};
    }

    if (_.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    var cacheEntry = _.cloneDeep(remoteCache[options.location]);

    var cOptions = _.cloneDeep(options);

    if (_.isUndefined(cacheEntry.refs)) {
      // Do not filter any references so the cache is complete
      delete cOptions.filter;
      delete cOptions.subDocPath;
      cOptions.includeInvalid = true;
      remoteCache[options.location].refs = findRefs(res, cOptions);
    } // Add the filter options back


    if (!_.isUndefined(options.filter)) {
      cOptions.filter = options.filter;
    } // This will use the cache so don't worry about calling it twice


    return {
      refs: findRefs(res, cOptions),
      value: res
    };
  });
  return allTasks;
}

function getRefDetails(obj) {
  var details = {
    def: obj
  };
  var cacheKey;
  var extraKeys;
  var uriDetails;

  try {
    // This will throw so the result doesn't matter
    isRefLike(obj, true);
    cacheKey = obj.$ref;
    uriDetails = uriDetailsCache[cacheKey];

    if (_.isUndefined(uriDetails)) {
      uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);
    }

    details.uri = cacheKey;
    details.uriDetails = uriDetails;

    if (_.isUndefined(uriDetails.error)) {
      details.type = getRefType(details); // Validate the JSON Pointer

      try {
        if (['#', '/'].indexOf(cacheKey[0]) > -1) {
          isPtr(cacheKey, true);
        } else if (cacheKey.indexOf('#') > -1) {
          isPtr(uriDetails.fragment, true);
        }
      } catch (err) {
        details.error = err.message;
        details.type = 'invalid';
      }
    } else {
      details.error = details.uriDetails.error;
      details.type = 'invalid';
    } // Identify warning


    extraKeys = getExtraRefKeys(obj);

    if (extraKeys.length > 0) {
      details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');
    }
  } catch (err) {
    details.error = err.message;
    details.type = 'invalid';
  }

  return details;
}

function isPtr(ptr, throwWithDetails) {
  var valid = true;
  var firstChar;

  try {
    if (_.isString(ptr)) {
      if (ptr !== '') {
        firstChar = ptr.charAt(0);

        if (['#', '/'].indexOf(firstChar) === -1) {
          throw new Error('ptr must start with a / or #/');
        } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {
          throw new Error('ptr must start with a / or #/');
        } else if (ptr.match(badPtrTokenRegex)) {
          throw new Error('ptr has invalid token(s)');
        }
      }
    } else {
      throw new Error('ptr is not a String');
    }
  } catch (err) {
    if (throwWithDetails === true) {
      throw err;
    }

    valid = false;
  }

  return valid;
}

function isRef(obj, throwWithDetails) {
  return isRefLike(obj, throwWithDetails) && getRefDetails(obj).type !== 'invalid';
}

function pathFromPtr(ptr) {
  try {
    isPtr(ptr, true);
  } catch (err) {
    throw new Error('ptr must be a JSON Pointer: ' + err.message);
  }

  var segments = ptr.split('/'); // Remove the first segment

  segments.shift();
  return decodePath(segments);
}

function pathToPtr(path, hashPrefix) {
  if (!_.isArray(path)) {
    throw new Error('path must be an Array');
  } // Encode each segment and return


  return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + encodePath(path).join('/');
}

function resolveRefs(obj, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided document
    if (!_.isArray(obj) && !_.isObject(obj)) {
      throw new TypeError('obj must be an Array or an Object');
    } // Validate options


    options = validateOptions(options, obj); // Clone the input so we do not alter it

    obj = _.cloneDeep(obj);
  }).then(function () {
    var metadata = {
      deps: {},
      // To avoid processing the same refernece twice, and for circular reference identification
      docs: {},
      // Cache to avoid processing the same document more than once
      refs: {} // Reference locations and their metadata

    };
    return buildRefModel(obj, options, metadata).then(function () {
      return metadata;
    });
  }).then(function (results) {
    var allRefs = {};
    var circularPaths = [];
    var circulars = [];
    var depGraph = new gl.Graph();
    var fullLocation = makeAbsolute(options.location);
    var refsRoot = fullLocation + pathToPtr(options.subDocPath);
    var relativeBase = path.dirname(fullLocation); // Identify circulars
    // Add nodes first

    Object.keys(results.deps).forEach(function (node) {
      depGraph.setNode(node);
    }); // Add edges

    _.forOwn(results.deps, function (props, node) {
      _.forOwn(props, function (dep) {
        depGraph.setEdge(node, dep);
      });
    });

    circularPaths = gl.alg.findCycles(depGraph); // Create a unique list of circulars

    circularPaths.forEach(function (path) {
      path.forEach(function (seg) {
        if (circulars.indexOf(seg) === -1) {
          circulars.push(seg);
        }
      });
    }); // Identify circulars

    _.forOwn(results.deps, function (props, node) {
      _.forOwn(props, function (dep, prop) {
        var isCircular = false;
        var refPtr = node + prop.slice(1);
        var refDetails = results.refs[node + prop.slice(1)];
        var remote = isRemote(refDetails);
        var pathIndex;

        if (circulars.indexOf(dep) > -1) {
          // Figure out if the circular is part of a circular chain or just a reference to a circular
          circularPaths.forEach(function (path) {
            // Short circuit
            if (isCircular) {
              return;
            }

            pathIndex = path.indexOf(dep);

            if (pathIndex > -1) {
              // Check each path segment to see if the reference location is beneath one of its segments
              path.forEach(function (seg) {
                // Short circuit
                if (isCircular) {
                  return;
                }

                if (refPtr.indexOf(seg + '/') === 0) {
                  // If the reference is local, mark it as circular but if it's a remote reference, only mark it
                  // circular if the matching path is the last path segment or its match is not to a document root
                  if (!remote || pathIndex === path.length - 1 || dep[dep.length - 1] !== '#') {
                    isCircular = true;
                  }
                }
              });
            }
          });
        }

        if (isCircular) {
          // Update all references and reference details
          refDetails.circular = true;
        }
      });
    }); // Resolve the references in reverse order since the current order is top-down


    _.forOwn(Object.keys(results.deps).reverse(), function (parentPtr) {
      var deps = results.deps[parentPtr];
      var pPtrParts = parentPtr.split('#');
      var pDocument = results.docs[pPtrParts[0]];
      var pPtrPath = pathFromPtr(pPtrParts[1]);

      _.forOwn(deps, function (dep, prop) {
        var depParts = splitFragment(dep);
        var dDocument = results.docs[depParts[0]];
        var dPtrPath = pPtrPath.concat(pathFromPtr(prop));
        var refDetails = results.refs[pPtrParts[0] + pathToPtr(dPtrPath)]; // Resolve reference if valid

        if (_.isUndefined(refDetails.error) && _.isUndefined(refDetails.missing)) {
          if (!options.resolveCirculars && refDetails.circular) {
            refDetails.value = _.cloneDeep(refDetails.def);
          } else {
            try {
              refDetails.value = findValue(dDocument, pathFromPtr(depParts[1]));
            } catch (err) {
              markMissing(refDetails, err);
              return;
            } // If the reference is at the root of the document, replace the document in the cache.  Otherwise, replace
            // the value in the appropriate location in the document cache.


            if (pPtrParts[1] === '' && prop === '#') {
              results.docs[pPtrParts[0]] = refDetails.value;
            } else {
              setValue(pDocument, dPtrPath, refDetails.value);
            }
          }
        }
      });
    });

    function walkRefs(root, refPtr, refPath) {
      var refPtrParts = refPtr.split('#');
      var refDetails = results.refs[refPtr];
      var refDeps; // Record the reference (relative to the root document unless the reference is in the root document)

      allRefs[refPtrParts[0] === options.location ? '#' + refPtrParts[1] : pathToPtr(options.subDocPath.concat(refPath))] = refDetails; // Do not walk invalid references

      if (refDetails.circular || !isValid(refDetails)) {
        // Sanitize errors
        if (!refDetails.circular && refDetails.error) {
          // The way we use findRefs now results in an error that doesn't match the expectation
          refDetails.error = refDetails.error.replace('options.subDocPath', 'JSON Pointer'); // Update the error to use the appropriate JSON Pointer

          if (refDetails.error.indexOf('#') > -1) {
            refDetails.error = refDetails.error.replace(refDetails.uri.substr(refDetails.uri.indexOf('#')), refDetails.uri);
          } // Report errors opening files as JSON Pointer errors


          if (refDetails.error.indexOf('ENOENT:') === 0 || refDetails.error.indexOf('Not Found') === 0) {
            refDetails.error = 'JSON Pointer points to missing location: ' + refDetails.uri;
          }
        }

        return;
      }

      refDeps = results.deps[refDetails.refdId];

      if (refDetails.refdId.indexOf(root) !== 0) {
        Object.keys(refDeps).forEach(function (prop) {
          walkRefs(refDetails.refdId, refDetails.refdId + prop.substr(1), refPath.concat(pathFromPtr(prop)));
        });
      }
    } // For performance reasons, we only process a document (or sub document) and each reference once ever.  This means
    // that if we want to provide the full picture as to what paths in the resolved document were created as a result
    // of a reference, we have to take our fully-qualified reference locations and expand them to be all local based
    // on the original document.


    Object.keys(results.refs).forEach(function (refPtr) {
      var refDetails = results.refs[refPtr];
      var fqURISegments;
      var uriSegments; // Make all fully-qualified reference URIs relative to the document root (if necessary).  This step is done here
      // for performance reasons instead of below when the official sanitization process runs.

      if (refDetails.type !== 'invalid') {
        // Remove the trailing hash from document root references if they weren't in the original URI
        if (refDetails.fqURI[refDetails.fqURI.length - 1] === '#' && refDetails.uri[refDetails.uri.length - 1] !== '#') {
          refDetails.fqURI = refDetails.fqURI.substr(0, refDetails.fqURI.length - 1);
        }

        fqURISegments = refDetails.fqURI.split('/');
        uriSegments = refDetails.uri.split('/'); // The fully-qualified URI is unencoded so to keep the original formatting of the URI (encoded vs. unencoded),
        // we need to replace each URI segment in reverse order.

        _.times(uriSegments.length - 1, function (time) {
          var nSeg = uriSegments[uriSegments.length - time - 1];
          var pSeg = uriSegments[uriSegments.length - time];
          var fqSegIndex = fqURISegments.length - time - 1;

          if (nSeg === '.' || nSeg === '..' || pSeg === '..') {
            return;
          }

          fqURISegments[fqSegIndex] = nSeg;
        });

        refDetails.fqURI = fqURISegments.join('/'); // Make the fully-qualified URIs relative to the document root

        if (refDetails.fqURI.indexOf(fullLocation) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(fullLocation, '');
        } else if (refDetails.fqURI.indexOf(relativeBase) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(relativeBase, '');
        }

        if (refDetails.fqURI[0] === '/') {
          refDetails.fqURI = '.' + refDetails.fqURI;
        }
      } // We only want to process references found at or beneath the provided document and sub-document path


      if (refPtr.indexOf(refsRoot) !== 0) {
        return;
      }

      walkRefs(refsRoot, refPtr, pathFromPtr(refPtr.substr(refsRoot.length)));
    }); // Sanitize the reference details

    _.forOwn(allRefs, function (refDetails, refPtr) {
      // Delete the reference id used for dependency tracking and circular identification
      delete refDetails.refdId; // For locally-circular references, update the $ref to be fully qualified (Issue #175)

      if (refDetails.circular && refDetails.type === 'local') {
        refDetails.value.$ref = refDetails.fqURI;
        setValue(results.docs[fullLocation], pathFromPtr(refPtr), refDetails.value);
      } // To avoid the error message being URI encoded/decoded by mistake, replace the current JSON Pointer with the
      // value in the JSON Reference definition.


      if (refDetails.missing) {
        refDetails.error = refDetails.error.split(': ')[0] + ': ' + refDetails.def.$ref;
      }
    });

    return {
      refs: allRefs,
      resolved: results.docs[fullLocation]
    };
  });
  return allTasks;
}

function resolveRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!_.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (_.isUndefined(options)) {
      options = {};
    }

    if (_.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    return resolveRefs(res, options).then(function (res2) {
      return {
        refs: res2.refs,
        resolved: res2.resolved,
        value: res
      };
    });
  });
  return allTasks;
} // splits a fragment from a URI using the first hash found


function splitFragment(uri) {
  var hash = uri.indexOf('#');

  if (hash < 0) {
    return [uri];
  }

  var parts = [];
  parts.push(uri.substring(0, hash));
  parts.push(uri.substring(hash + 1));
  return parts;
}
/**
 * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and
 * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.
 *
 * @module json-refs
 */

/**
 * A number of functions exported below are used within the exported functions.  Typically, I would use a function
 * declaration _(with documenation)_ above and then just export a reference to the function but due to a bug in JSDoc
 * (https://github.com/jsdoc3/jsdoc/issues/679), this breaks the generated API documentation and TypeScript
 * declarations.  So that's why each `module.exports` below basically just wraps a call to the function declaration.
 */

/**
* Clears the internal cache of remote documents, reference details, etc.
*/


module.exports.clearCache = function () {
  remoteCache = {};
};
/**
 * Takes an array of path segments and decodes the JSON Pointer tokens in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string[]} the array of path segments with their JSON Pointer tokens decoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */


module.exports.decodePath = function (path) {
  return decodePath(path);
};
/**
 * Takes an array of path segments and encodes the special JSON Pointer characters in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string[]} the array of path segments with their JSON Pointer tokens encoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */


module.exports.encodePath = function (path) {
  return encodePath(path);
};
/**
 * Finds JSON References defined within the provided array/object.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Object.<string, module:json-refs.UnresolvedRefDetails|undefined>} an object whose keys are JSON Pointers
 * *(fragment version)* to where the JSON Reference is defined and whose values are {@link UnresolvedRefDetails}.
 *
 * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location
 *
 * @example
 * // Finding all valid references
 * var allRefs = JsonRefs.findRefs(obj);
 * // Finding all remote references
 * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});
 * // Finding all invalid references
 * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});
 */


module.exports.findRefs = function (obj, options) {
  return findRefs(obj, options);
};
/**
 * Finds JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link findRefs} except this API will retrieve a remote document and then
 * return the result of {@link findRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs.JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.RetrievedRefsResults>} a promise that resolves a
 * {@link module:json-refs.RetrievedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves references within a sub document
 * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {
 *     subDocPath: '#/definitions'
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.findRefsAt = function (location, options) {
  return findRefsAt(location, options);
};
/**
 * Returns detailed information about the JSON Reference.
 *
 * @param {object} obj - The JSON Reference definition
 *
 * @returns {module:json-refs.UnresolvedRefDetails} the detailed information
 */


module.exports.getRefDetails = function (obj) {
  return getRefDetails(obj);
};
/**
 * Returns whether the argument represents a JSON Pointer.
 *
 * A string is a JSON Pointer if the following are all true:
 *
 *   * The string is of type `String`
 *   * The string must be empty, `#` or start with a `/` or `#/`
 *
 * @param {string} ptr - The string to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 *
 * @example
 * // Separating the different ways to invoke isPtr for demonstration purposes
 * if (isPtr(str)) {
 *   // Handle a valid JSON Pointer
 * } else {
 *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it
 *   try {
 *     isPtr(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Pointer
 *   }
 * }
 */


module.exports.isPtr = function (ptr, throwWithDetails) {
  return isPtr(ptr, throwWithDetails);
};
/**
 * Returns whether the argument represents a JSON Reference.
 *
 * An object is a JSON Reference only if the following are all true:
 *
 *   * The object is of type `Object`
 *   * The object has a `$ref` property
 *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special
 *     characters.)*
 *
 * @param {object} obj - The object to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}
 *
 * @example
 * // Separating the different ways to invoke isRef for demonstration purposes
 * if (isRef(obj)) {
 *   // Handle a valid JSON Reference
 * } else {
 *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it
 *   try {
 *     isRef(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Reference
 *   }
 * }
 */


module.exports.isRef = function (obj, throwWithDetails) {
  return isRef(obj, throwWithDetails);
};
/**
 * Returns an array of path segments for the provided JSON Pointer.
 *
 * @param {string} ptr - The JSON Pointer
 *
 * @returns {string[]} the path segments
 *
 * @throws {Error} if the provided `ptr` argument is not a JSON Pointer
 */


module.exports.pathFromPtr = function (ptr) {
  return pathFromPtr(ptr);
};
/**
 * Returns a JSON Pointer for the provided array of path segments.
 *
 * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.
 *
 * @param {string[]} path - The array of path segments
 * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer
 *
 * @returns {string} the corresponding JSON Pointer
 *
 * @throws {Error} if the `path` argument is not an array
 */


module.exports.pathToPtr = function (path, hashPrefix) {
  return pathToPtr(path, hashPrefix);
};
/**
 * Finds JSON References defined within the provided array/object and resolves them.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.ResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs.ResolvedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves relative and remote references
 * JsonRefs.resolveRefs(swaggerObj, {
 *     filter: ['relative', 'remote']
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.resolveRefs = function (obj, options) {
  return resolveRefs(obj, options);
};
/**
 * Resolves JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link module:json-refs.resolveRefs} except this API will retrieve a remote document and
 * then return the result of {@link module:json-refs.resolveRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs.JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs.JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs.RetrievedResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs.RetrievedResolvedRefsResults} and rejects with an `Error` when the input arguments fail
 * validation, when `options.subDocPath` points to an invalid location or when the location argument points to an
 * unloadable resource
 *
 * @example
 * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references
 * JsonRefs.resolveRefsAt('./swagger.json')
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */


module.exports.resolveRefsAt = function (location, options) {
  return resolveRefsAt(location, options);
};

/***/ }),

/***/ 2857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8299);

var callBind = __webpack_require__(8953);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

/***/ }),

/***/ 8953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(5465);

var GetIntrinsic = __webpack_require__(8299);

var setFunctionLength = __webpack_require__(5887);

var $TypeError = __webpack_require__(1953);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(5049);

var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
  if (typeof originalFunction !== 'function') {
    throw new $TypeError('a function is required');
  }

  var func = $reflectApply(bind, $call, arguments);
  return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),

/***/ 3423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var $defineProperty = __webpack_require__(5049);

var $SyntaxError = __webpack_require__(1226);

var $TypeError = __webpack_require__(1953);

var gopd = __webpack_require__(3581);
/** @type {import('.')} */


module.exports = function defineDataProperty(obj, property, value) {
  if (!obj || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    throw new $TypeError('`obj` must be an object or a function`');
  }

  if (typeof property !== 'string' && _typeof(property) !== 'symbol') {
    throw new $TypeError('`property` must be a string or a symbol`');
  }

  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  }

  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  }

  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  }

  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    throw new $TypeError('`loose`, if provided, must be a boolean');
  }

  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  /* @type {false | TypedPropertyDescriptor<unknown>} */

  var desc = !!gopd && gopd(obj, property);

  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value: value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
  } else {
    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  }
};

/***/ }),

/***/ 5049:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8299);
/** @type {import('.')} */


var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
  }
}

module.exports = $defineProperty;

/***/ }),

/***/ 15:
/***/ ((module) => {

"use strict";

/** @type {import('./eval')} */

module.exports = EvalError;

/***/ }),

/***/ 157:
/***/ ((module) => {

"use strict";

/** @type {import('.')} */

module.exports = Error;

/***/ }),

/***/ 2104:
/***/ ((module) => {

"use strict";

/** @type {import('./range')} */

module.exports = RangeError;

/***/ }),

/***/ 6076:
/***/ ((module) => {

"use strict";

/** @type {import('./ref')} */

module.exports = ReferenceError;

/***/ }),

/***/ 1226:
/***/ ((module) => {

"use strict";

/** @type {import('./syntax')} */

module.exports = SyntaxError;

/***/ }),

/***/ 1953:
/***/ ((module) => {

"use strict";

/** @type {import('./type')} */

module.exports = TypeError;

/***/ }),

/***/ 7047:
/***/ ((module) => {

"use strict";

/** @type {import('./uri')} */

module.exports = URIError;

/***/ }),

/***/ 1046:
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = stringify;
stringify["default"] = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = '[...]';
var CIRCULAR_REPLACE_NODE = '[Circular]';
var arr = [];
var replacerStack = [];

function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
} // Regular stringify


function stringify(obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions();
  }

  decirc(obj, '', 0, [], undefined, 0, options);
  var res;

  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();

      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }

  return res;
}

function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);

  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, {
        value: replace
      });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}

function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;

  if (_typeof(val) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }

    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }

    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }

    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!

    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);

      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }

    stack.pop();
  }
} // Stable-stringify


function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}

function deterministicStringify(obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions();
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
  var res;

  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop();

      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }

  return res;
}

function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;

  if (_typeof(val) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }

    try {
      if (typeof val.toJSON === 'function') {
        return;
      }
    } catch (_) {
      return;
    }

    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }

    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }

    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!

    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);

      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options);
        tmp[key] = val[key];
      }

      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }

    stack.pop();
  }
} // wraps replacer function to handle values we couldn't replace
// and mark them as replaced value


function replaceGetterValues(replacer) {
  replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {
    return v;
  };
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];

        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }

    return replacer.call(this, key, val);
  };
}

/***/ }),

/***/ 2703:
/***/ ((module) => {

"use strict";

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
  var arr = [];

  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }

  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }

  return arr;
};

var slicy = function slicy(arrLike, offset) {
  var arr = [];

  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }

  return arr;
};

var joiny = function joiny(arr, joiner) {
  var str = '';

  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];

    if (i + 1 < arr.length) {
      str += joiner;
    }
  }

  return str;
};

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slicy(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, concatty(args, arguments));

      if (Object(result) === result) {
        return result;
      }

      return this;
    }

    return target.apply(that, concatty(args, arguments));
  };

  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = '$' + i;
  }

  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

/***/ }),

/***/ 5465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(2703);

module.exports = Function.prototype.bind || implementation;

/***/ }),

/***/ 8299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var undefined;

var $Error = __webpack_require__(157);

var $EvalError = __webpack_require__(15);

var $RangeError = __webpack_require__(2104);

var $ReferenceError = __webpack_require__(6076);

var $SyntaxError = __webpack_require__(1226);

var $TypeError = __webpack_require__(1953);

var $URIError = __webpack_require__(7047);

var $Function = Function; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = __webpack_require__(377)();

var hasProto = __webpack_require__(9486)();

var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
  return x.__proto__;
} // eslint-disable-line no-proto
: null);
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': $Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': $EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': $RangeError,
  '%ReferenceError%': $ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': $URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
  try {
    null.error; // eslint-disable-line no-unused-expressions
  } catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS['%Error.prototype%'] = errorProto;
  }
}

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  __proto__: null,
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(5465);

var hasOwn = __webpack_require__(863);

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

/***/ }),

/***/ 3581:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8299);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}

module.exports = $gOPD;

/***/ }),

/***/ 9336:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var lib = __webpack_require__(8676);

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(5564),
  alg: __webpack_require__(8665),
  version: lib.version
};

/***/ }),

/***/ 5729:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);

    _.each(g.successors(v), dfs);

    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function (v) {
    cmpt = [];
    dfs(v);

    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

/***/ }),

/***/ 8622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = dfs;
/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */

function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
  var acc = [];
  var visited = {};

  _.each(vs, function (v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });

  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) {
      acc.push(v);
    }

    _.each(navigation(v), function (w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });

    if (postorder) {
      acc.push(v);
    }
  }
}

/***/ }),

/***/ 3765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dijkstra = __webpack_require__(9316);

var _ = __webpack_require__(4435);

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function (acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}

/***/ }),

/***/ 9316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

var PriorityQueue = __webpack_require__(5523);

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function updateNeighbors(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " + "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function (v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = {
      distance: distance
    };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];

    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

/***/ }),

/***/ 5708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

var tarjan = __webpack_require__(2869);

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function (cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}

/***/ }),

/***/ 9040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();
  nodes.forEach(function (v) {
    results[v] = {};
    results[v][v] = {
      distance: 0
    };
    nodes.forEach(function (w) {
      if (v !== w) {
        results[v][w] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(v).forEach(function (edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = {
        distance: d,
        predecessor: v
      };
    });
  });
  nodes.forEach(function (k) {
    var rowK = results[k];
    nodes.forEach(function (i) {
      var rowI = results[i];
      nodes.forEach(function (j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;

        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}

/***/ }),

/***/ 8665:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  components: __webpack_require__(5729),
  dijkstra: __webpack_require__(9316),
  dijkstraAll: __webpack_require__(3765),
  findCycles: __webpack_require__(5708),
  floydWarshall: __webpack_require__(9040),
  isAcyclic: __webpack_require__(3776),
  postorder: __webpack_require__(1499),
  preorder: __webpack_require__(4070),
  prim: __webpack_require__(9377),
  tarjan: __webpack_require__(2869),
  topsort: __webpack_require__(8186)
};

/***/ }),

/***/ 3776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var topsort = __webpack_require__(8186);

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }

    throw e;
  }

  return true;
}

/***/ }),

/***/ 1499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(8622);

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}

/***/ }),

/***/ 4070:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(8622);

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

/***/ }),

/***/ 9377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

var Graph = __webpack_require__(7848);

var PriorityQueue = __webpack_require__(5523);

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);

    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);

      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function (v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  }); // Start from an arbitrary node


  pq.decrease(g.nodes()[0], 0);
  var init = false;

  while (pq.size() > 0) {
    v = pq.removeMin();

    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

/***/ }),

/***/ 2869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }

  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);
    g.successors(v).forEach(function (w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;

      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);

      results.push(cmpt);
    }
  }

  g.nodes().forEach(function (v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });
  return results;
}

/***/ }),

/***/ 8186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;

      _.each(g.predecessors(node), visit);

      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}

CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ 5523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

module.exports = PriorityQueue;
/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */

function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}
/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */


PriorityQueue.prototype.size = function () {
  return this._arr.length;
};
/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */


PriorityQueue.prototype.keys = function () {
  return this._arr.map(function (x) {
    return x.key;
  });
};
/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */


PriorityQueue.prototype.has = function (key) {
  return _.has(this._keyIndices, key);
};
/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */


PriorityQueue.prototype.priority = function (key) {
  var index = this._keyIndices[key];

  if (index !== undefined) {
    return this._arr[index].priority;
  }
};
/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */


PriorityQueue.prototype.min = function () {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }

  return this._arr[0].key;
};
/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */


PriorityQueue.prototype.add = function (key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);

  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({
      key: key,
      priority: priority
    });

    this._decrease(index);

    return true;
  }

  return false;
};
/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */


PriorityQueue.prototype.removeMin = function () {
  this._swap(0, this._arr.length - 1);

  var min = this._arr.pop();

  delete this._keyIndices[min.key];

  this._heapify(0);

  return min.key;
};
/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */


PriorityQueue.prototype.decrease = function (key, priority) {
  var index = this._keyIndices[key];

  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " + "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }

  this._arr[index].priority = priority;

  this._decrease(index);
};

PriorityQueue.prototype._heapify = function (i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;

  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;

    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }

    if (largest !== i) {
      this._swap(i, largest);

      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function (index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;

  while (index !== 0) {
    parent = index >> 1;

    if (arr[parent].priority < priority) {
      break;
    }

    this._swap(index, parent);

    index = parent;
  }
};

PriorityQueue.prototype._swap = function (i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

/***/ }),

/***/ 7848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = __webpack_require__(4435);

module.exports = Graph;
var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01"; // Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false; // Label for the graph itself

  this._label = undefined; // Defaults to be set when creating a new node

  this._defaultNodeLabelFn = _.constant(undefined); // Defaults to be set when creating a new edge

  this._defaultEdgeLabelFn = _.constant(undefined); // v -> label

  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {}; // v -> children

    this._children = {};
    this._children[GRAPH_NODE] = {};
  } // v -> edgeObj


  this._in = {}; // u -> v -> Number

  this._preds = {}; // v -> edgeObj

  this._out = {}; // v -> w -> Number

  this._sucs = {}; // e -> edgeObj

  this._edgeObjs = {}; // e -> label

  this._edgeLabels = {};
}
/* Number of nodes in the graph. Should only be changed by the implementation. */


Graph.prototype._nodeCount = 0;
/* Number of edges in the graph. Should only be changed by the implementation. */

Graph.prototype._edgeCount = 0;
/* === Graph functions ========= */

Graph.prototype.isDirected = function () {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function () {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function () {
  return this._isCompound;
};

Graph.prototype.setGraph = function (label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function () {
  return this._label;
};
/* === Node functions ========== */


Graph.prototype.setDefaultNodeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function () {
  return this._nodeCount;
};

Graph.prototype.nodes = function () {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function (vs, value) {
  var args = arguments;
  var self = this;

  _.each(vs, function (v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });

  return this;
};

Graph.prototype.setNode = function (v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }

    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);

  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }

  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function (v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function (v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode = function (v) {
  var self = this;

  if (_.has(this._nodes, v)) {
    var removeEdge = function removeEdge(e) {
      self.removeEdge(self._edgeObjs[e]);
    };

    delete this._nodes[v];

    if (this._isCompound) {
      this._removeFromParentsChildList(v);

      delete this._parent[v];

      _.each(this.children(v), function (child) {
        self.setParent(child);
      });

      delete this._children[v];
    }

    _.each(_.keys(this._in[v]), removeEdge);

    delete this._in[v];
    delete this._preds[v];

    _.each(_.keys(this._out[v]), removeEdge);

    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }

  return this;
};

Graph.prototype.setParent = function (v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";

    for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);

  this._removeFromParentsChildList(v);

  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function (v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function (v) {
  if (this._isCompound) {
    var parent = this._parent[v];

    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function (v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];

    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function (v) {
  var predsV = this._preds[v];

  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function (v) {
  var sucsV = this._sucs[v];

  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function (v) {
  var preds = this.predecessors(v);

  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;

  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }

  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function (filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy.setGraph(this.graph());
  var self = this;

  _.each(this._nodes, function (value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function (e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};

  function findParent(v) {
    var parent = self.parent(v);

    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function (v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};
/* === Edge functions ========== */


Graph.prototype.setDefaultEdgeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function () {
  return this._edgeCount;
};

Graph.prototype.edges = function () {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function (vs, value) {
  var self = this;
  var args = arguments;

  _.reduce(vs, function (v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }

    return w;
  });

  return this;
};
/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */


Graph.prototype.setEdge = function () {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (_typeof(arg0) === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;

    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];

    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;

  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);

  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }

    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  } // It didn't exist, so we need to create it.
  // First ensure the nodes exist.


  this.setNode(v);
  this.setNode(w);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name); // Ensure we add undirected edges in a consistent way.

  v = edgeObj.v;
  w = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  var edge = this._edgeObjs[e];

  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }

  return this;
};

Graph.prototype.inEdges = function (v, u) {
  var inV = this._in[v];

  if (inV) {
    var edges = _.values(inV);

    if (!u) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.v === u;
    });
  }
};

Graph.prototype.outEdges = function (v, w) {
  var outV = this._out[v];

  if (outV) {
    var edges = _.values(outV);

    if (!w) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.w === w;
    });
  }
};

Graph.prototype.nodeEdges = function (v, w) {
  var inEdges = this.inEdges(v, w);

  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (! --map[k]) {
    delete map[k];
  }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var edgeObj = {
    v: v,
    w: w
  };

  if (name) {
    edgeObj.name = name;
  }

  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

/***/ }),

/***/ 8676:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(7848),
  version: __webpack_require__(1096)
};

/***/ }),

/***/ 5564:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(4435);

var Graph = __webpack_require__(7848);

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };

  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }

  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function (v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = {
      v: v
    };

    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }

    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }

    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function (e) {
    var edgeValue = g.edge(e);
    var edge = {
      v: e.v,
      w: e.w
    };

    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }

    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }

    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);

  _.each(json.nodes, function (entry) {
    g.setNode(entry.v, entry.value);

    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });

  _.each(json.edges, function (entry) {
    g.setEdge({
      v: entry.v,
      w: entry.w,
      name: entry.name
    }, entry.value);
  });

  return g;
}

/***/ }),

/***/ 4435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */
var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(4127),
      constant: __webpack_require__(2700),
      each: __webpack_require__(5597),
      filter: __webpack_require__(4110),
      has: __webpack_require__(6250),
      isArray: __webpack_require__(8944),
      isEmpty: __webpack_require__(1323),
      isFunction: __webpack_require__(6516),
      isUndefined: __webpack_require__(8526),
      keys: __webpack_require__(6808),
      map: __webpack_require__(952),
      reduce: __webpack_require__(246),
      size: __webpack_require__(29),
      transform: __webpack_require__(470),
      union: __webpack_require__(4749),
      values: __webpack_require__(6482)
    };
  } catch (e) {// continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;

/***/ }),

/***/ 1096:
/***/ ((module) => {

module.exports = '2.1.8';

/***/ }),

/***/ 6698:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(5049);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
  return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!$defineProperty) {
    return null;
  }

  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};

module.exports = hasPropertyDescriptors;

/***/ }),

/***/ 9486:
/***/ ((module) => {

"use strict";


var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;
/** @type {import('.')} */

module.exports = function hasProto() {
  // @ts-expect-error: TS errors on an inherited property for some reason
  return {
    __proto__: test
  }.foo === test.foo && !(test instanceof $Object);
};

/***/ }),

/***/ 377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var origSymbol = typeof Symbol !== 'undefined' && Symbol;

var hasSymbolSham = __webpack_require__(4379);

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (_typeof(origSymbol('foo')) !== 'symbol') {
    return false;
  }

  if (_typeof(Symbol('bar')) !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};

/***/ }),

/***/ 4379:
/***/ ((module) => {

"use strict";

/* eslint complexity: [2, 18], max-statements: [2, 33] */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (_typeof(Symbol.iterator) === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

/***/ }),

/***/ 863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;

var bind = __webpack_require__(5465);
/** @type {import('.')} */


module.exports = bind.call(call, $hasOwn);

/***/ }),

/***/ 8574:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776),
    root = __webpack_require__(6563);
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ 2507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(5978),
    hashDelete = __webpack_require__(7068),
    hashGet = __webpack_require__(4143),
    hashHas = __webpack_require__(2595),
    hashSet = __webpack_require__(5835);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ 9937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(3292),
    listCacheDelete = __webpack_require__(2778),
    listCacheGet = __webpack_require__(3845),
    listCacheHas = __webpack_require__(57),
    listCacheSet = __webpack_require__(1185);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ 7949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776),
    root = __webpack_require__(6563);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ 2391:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(3662),
    mapCacheDelete = __webpack_require__(2792),
    mapCacheGet = __webpack_require__(6107),
    mapCacheHas = __webpack_require__(679),
    mapCacheSet = __webpack_require__(6223);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ 6430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776),
    root = __webpack_require__(6563);
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ 6699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776),
    root = __webpack_require__(6563);
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ 4985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(2391),
    setCacheAdd = __webpack_require__(2918),
    setCacheHas = __webpack_require__(1553);
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),

/***/ 7683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(9937),
    stackClear = __webpack_require__(4290),
    stackDelete = __webpack_require__(9796),
    stackGet = __webpack_require__(6935),
    stackHas = __webpack_require__(363),
    stackSet = __webpack_require__(4675);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ 5047:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(6563);
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),

/***/ 9138:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(6563);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ 5061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776),
    root = __webpack_require__(6563);
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ 5191:
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),

/***/ 411:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ 1576:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ 567:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(3893);
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),

/***/ 4415:
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),

/***/ 7985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(274),
    isArguments = __webpack_require__(3134),
    isArray = __webpack_require__(8944),
    isBuffer = __webpack_require__(6238),
    isIndex = __webpack_require__(6119),
    isTypedArray = __webpack_require__(6341);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ 1534:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),

/***/ 4018:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ 1624:
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

module.exports = arrayReduce;

/***/ }),

/***/ 4254:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),

/***/ 265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(4963);
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */


var asciiSize = baseProperty('length');
module.exports = asciiSize;

/***/ }),

/***/ 3061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(9810),
    eq = __webpack_require__(1130);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),

/***/ 799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(1130);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ 8287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(5857),
    keys = __webpack_require__(6808);
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),

/***/ 9940:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(5857),
    keysIn = __webpack_require__(1143);
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),

/***/ 9810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(9553);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),

/***/ 6161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(7683),
    arrayEach = __webpack_require__(411),
    assignValue = __webpack_require__(3061),
    baseAssign = __webpack_require__(8287),
    baseAssignIn = __webpack_require__(9940),
    cloneBuffer = __webpack_require__(9620),
    copyArray = __webpack_require__(6213),
    copySymbols = __webpack_require__(3749),
    copySymbolsIn = __webpack_require__(9718),
    getAllKeys = __webpack_require__(5136),
    getAllKeysIn = __webpack_require__(2799),
    getTag = __webpack_require__(8663),
    initCloneArray = __webpack_require__(8631),
    initCloneByTag = __webpack_require__(8809),
    initCloneObject = __webpack_require__(8919),
    isArray = __webpack_require__(8944),
    isBuffer = __webpack_require__(6238),
    isMap = __webpack_require__(2884),
    isObject = __webpack_require__(4819),
    isSet = __webpack_require__(9686),
    keys = __webpack_require__(6808);
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),

/***/ 5514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(4819);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),

/***/ 6867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(6251),
    createBaseEach = __webpack_require__(2591);
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),

/***/ 5104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(6867);
/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */


function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function (value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

/***/ }),

/***/ 1893:
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),

/***/ 158:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(4018),
    isFlattenable = __webpack_require__(3745);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),

/***/ 3259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(6567);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),

/***/ 6251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(3259),
    keys = __webpack_require__(6808);
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),

/***/ 3136:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(5859),
    toKey = __webpack_require__(2427);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),

/***/ 7237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(4018),
    isArray = __webpack_require__(8944);
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ 6778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047),
    getRawTag = __webpack_require__(3337),
    objectToString = __webpack_require__(6572);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ 2916:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

/***/ }),

/***/ 1931:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),

/***/ 3893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(1893),
    baseIsNaN = __webpack_require__(7737),
    strictIndexOf = __webpack_require__(3077);
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),

/***/ 3384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(6778),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ 9016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(1926),
    isObjectLike = __webpack_require__(3804);
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),

/***/ 1926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(7683),
    equalArrays = __webpack_require__(5201),
    equalByTag = __webpack_require__(1556),
    equalObjects = __webpack_require__(3703),
    getTag = __webpack_require__(8663),
    isArray = __webpack_require__(8944),
    isBuffer = __webpack_require__(6238),
    isTypedArray = __webpack_require__(6341);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),

/***/ 8310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(8663),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),

/***/ 4045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(7683),
    baseIsEqual = __webpack_require__(9016);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),

/***/ 7737:
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),

/***/ 5753:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(6516),
    isMasked = __webpack_require__(5030),
    isObject = __webpack_require__(4819),
    toSource = __webpack_require__(8583);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ 5508:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(8663),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),

/***/ 3275:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(6778),
    isLength = __webpack_require__(7324),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ 731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseMatches = __webpack_require__(1541),
    baseMatchesProperty = __webpack_require__(7788),
    identity = __webpack_require__(7350),
    isArray = __webpack_require__(8944),
    property = __webpack_require__(4997);
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),

/***/ 6266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(405),
    nativeKeys = __webpack_require__(2644);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ 9277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(4819),
    isPrototype = __webpack_require__(405),
    nativeKeysIn = __webpack_require__(4971);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),

/***/ 9078:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(6867),
    isArrayLike = __webpack_require__(5932);
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),

/***/ 1541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(4045),
    getMatchData = __webpack_require__(1170),
    matchesStrictComparable = __webpack_require__(8871);
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),

/***/ 7788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(9016),
    get = __webpack_require__(4702),
    hasIn = __webpack_require__(8557),
    isKey = __webpack_require__(4704),
    isStrictComparable = __webpack_require__(7734),
    matchesStrictComparable = __webpack_require__(8871),
    toKey = __webpack_require__(2427);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),

/***/ 4963:
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),

/***/ 2237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(3136);
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),

/***/ 1056:
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function (value, index, collection) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

/***/ }),

/***/ 7632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(7350),
    overRest = __webpack_require__(8083),
    setToString = __webpack_require__(8455);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),

/***/ 5467:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(2700),
    defineProperty = __webpack_require__(9553),
    identity = __webpack_require__(7350);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),

/***/ 274:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ 2722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047),
    arrayMap = __webpack_require__(1534),
    isArray = __webpack_require__(8944),
    isSymbol = __webpack_require__(4372);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),

/***/ 9963:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ 4739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(4985),
    arrayIncludes = __webpack_require__(567),
    arrayIncludesWith = __webpack_require__(4415),
    cacheHas = __webpack_require__(7233),
    createSet = __webpack_require__(9023),
    setToArray = __webpack_require__(9873);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),

/***/ 4956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(1534);
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),

/***/ 7233:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),

/***/ 7096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(7350);
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),

/***/ 5859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(8944),
    isKey = __webpack_require__(4704),
    stringToPath = __webpack_require__(6184),
    toString = __webpack_require__(7892);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),

/***/ 995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(9138);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),

/***/ 9620:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(6563);
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/***/ }),

/***/ 7723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(995);
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),

/***/ 4875:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),

/***/ 2622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047);
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),

/***/ 435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(995);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),

/***/ 6213:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),

/***/ 5857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(3061),
    baseAssignValue = __webpack_require__(9810);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),

/***/ 3749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(5857),
    getSymbols = __webpack_require__(6182);
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),

/***/ 9718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(5857),
    getSymbolsIn = __webpack_require__(321);
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),

/***/ 2959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(6563);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ 2591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(5932);
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),

/***/ 6567:
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),

/***/ 9023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(6699),
    noop = __webpack_require__(5908),
    setToArray = __webpack_require__(9873);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),

/***/ 9553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),

/***/ 5201:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(4985),
    arraySome = __webpack_require__(4254),
    cacheHas = __webpack_require__(7233);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),

/***/ 1556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047),
    Uint8Array = __webpack_require__(9138),
    eq = __webpack_require__(1130),
    equalArrays = __webpack_require__(5201),
    mapToArray = __webpack_require__(7115),
    setToArray = __webpack_require__(9873);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),

/***/ 3703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(5136);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),

/***/ 4126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
module.exports = freeGlobal;

/***/ }),

/***/ 5136:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(7237),
    getSymbols = __webpack_require__(6182),
    keys = __webpack_require__(6808);
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ 2799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(7237),
    getSymbolsIn = __webpack_require__(321),
    keysIn = __webpack_require__(1143);
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),

/***/ 2065:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(8660);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ 1170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(7734),
    keys = __webpack_require__(6808);
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),

/***/ 1776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(5753),
    getValue = __webpack_require__(2402);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ 8401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(4953);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),

/***/ 3337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ 6182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(1576),
    stubArray = __webpack_require__(2167);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ 321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(4018),
    getPrototype = __webpack_require__(8401),
    getSymbols = __webpack_require__(6182),
    stubArray = __webpack_require__(2167);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),

/***/ 8663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(8574),
    Map = __webpack_require__(7949),
    Promise = __webpack_require__(6430),
    Set = __webpack_require__(6699),
    WeakMap = __webpack_require__(5061),
    baseGetTag = __webpack_require__(6778),
    toSource = __webpack_require__(8583);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ 2402:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ 3976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(5859),
    isArguments = __webpack_require__(3134),
    isArray = __webpack_require__(8944),
    isIndex = __webpack_require__(6119),
    isLength = __webpack_require__(7324),
    toKey = __webpack_require__(2427);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),

/***/ 1196:
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsZWJ = "\\u200d";
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

/***/ }),

/***/ 5978:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(7596);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ 7068:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ 4143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(7596);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ 2595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(7596);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ 5835:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(7596);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ 8631:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),

/***/ 8809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(995),
    cloneDataView = __webpack_require__(7723),
    cloneRegExp = __webpack_require__(4875),
    cloneSymbol = __webpack_require__(2622),
    cloneTypedArray = __webpack_require__(435);
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),

/***/ 8919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(5514),
    getPrototype = __webpack_require__(8401),
    isPrototype = __webpack_require__(405);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),

/***/ 3745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(5047),
    isArguments = __webpack_require__(3134),
    isArray = __webpack_require__(8944);
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),

/***/ 6119:
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ 4704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isArray = __webpack_require__(8944),
    isSymbol = __webpack_require__(4372);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),

/***/ 8660:
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ 5030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(2959);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ 405:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ 7734:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(4819);
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),

/***/ 3292:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ 2778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(799);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ 3845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(799);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ 57:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(799);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ 1185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(799);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ 3662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(2507),
    ListCache = __webpack_require__(9937),
    Map = __webpack_require__(7949);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ 2792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(2065);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ 6107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(2065);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ 679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(2065);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ 6223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(2065);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ 7115:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),

/***/ 8871:
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),

/***/ 5530:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(7094);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),

/***/ 7596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(1776);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ 2644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(4953);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ 4971:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),

/***/ 5515:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(4126);
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;

/***/ }),

/***/ 6572:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ 4953:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ 8083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(5191);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),

/***/ 6563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(4126);
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ 2918:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),

/***/ 1553:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),

/***/ 9873:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),

/***/ 8455:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(5467),
    shortOut = __webpack_require__(1693);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),

/***/ 1693:
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),

/***/ 4290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(9937);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ 9796:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ 6935:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ 363:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ 4675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(9937),
    Map = __webpack_require__(7949),
    MapCache = __webpack_require__(2391);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ 3077:
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),

/***/ 5811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiSize = __webpack_require__(265),
    hasUnicode = __webpack_require__(1196),
    unicodeSize = __webpack_require__(865);
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */


function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}

module.exports = stringSize;

/***/ }),

/***/ 6184:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(5530);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),

/***/ 2427:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(4372);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),

/***/ 8583:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ 865:
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

module.exports = unicodeSize;

/***/ }),

/***/ 4127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(6161);
/** Used to compose bitmasks for cloning. */


var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

/***/ }),

/***/ 2700:
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),

/***/ 5597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(1632);

/***/ }),

/***/ 1130:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ 4110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(1576),
    baseFilter = __webpack_require__(5104),
    baseIteratee = __webpack_require__(731),
    isArray = __webpack_require__(8944);
/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */


function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

/***/ }),

/***/ 1632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(411),
    baseEach = __webpack_require__(6867),
    castFunction = __webpack_require__(7096),
    isArray = __webpack_require__(8944);
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),

/***/ 4702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(3136);
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),

/***/ 6250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(2916),
    hasPath = __webpack_require__(3976);
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

/***/ }),

/***/ 8557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(1931),
    hasPath = __webpack_require__(3976);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),

/***/ 7350:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ 3134:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(3384),
    isObjectLike = __webpack_require__(3804);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ 8944:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ 5932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(6516),
    isLength = __webpack_require__(7324);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ 3323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(5932),
    isObjectLike = __webpack_require__(3804);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),

/***/ 6238:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(6563),
    stubFalse = __webpack_require__(6285);
/** Detect free variable `exports`. */


var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

/***/ }),

/***/ 1323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(6266),
    getTag = __webpack_require__(8663),
    isArguments = __webpack_require__(3134),
    isArray = __webpack_require__(8944),
    isArrayLike = __webpack_require__(5932),
    isBuffer = __webpack_require__(6238),
    isPrototype = __webpack_require__(405),
    isTypedArray = __webpack_require__(6341);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }

  var tag = getTag(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

module.exports = isEmpty;

/***/ }),

/***/ 6516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(6778),
    isObject = __webpack_require__(4819);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ 7324:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ 2884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(8310),
    baseUnary = __webpack_require__(9963),
    nodeUtil = __webpack_require__(5515);
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),

/***/ 4819:
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ 3804:
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ 9686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(5508),
    baseUnary = __webpack_require__(9963),
    nodeUtil = __webpack_require__(5515);
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),

/***/ 4893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(6778),
    isArray = __webpack_require__(8944),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

module.exports = isString;

/***/ }),

/***/ 4372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = __webpack_require__(6778),
    isObjectLike = __webpack_require__(3804);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ 6341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(3275),
    baseUnary = __webpack_require__(9963),
    nodeUtil = __webpack_require__(5515);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ 8526:
/***/ ((module) => {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

/***/ }),

/***/ 6808:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(7985),
    baseKeys = __webpack_require__(6266),
    isArrayLike = __webpack_require__(5932);
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ 1143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(7985),
    baseKeysIn = __webpack_require__(9277),
    isArrayLike = __webpack_require__(5932);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),

/***/ 3121:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.15';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
"\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof __webpack_require__.g==="undefined"?"undefined":_typeof(__webpack_require__.g))=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=( false?0:_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?0:_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined,symIterator=_Symbol?_Symbol.iterator:undefined,symToStringTag=_Symbol?_Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// with lookup (in case of e.g. prototype pollution), and strip newlines if any.
// A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/[\r\n]/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
// Like with sourceURL, we take care to not check the option's prototype,
// as this configuration is a code injection vector.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if( true&&_typeof(__webpack_require__.amdO)=='object'&&__webpack_require__.amdO){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(this);

/***/ }),

/***/ 952:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(1534),
    baseIteratee = __webpack_require__(731),
    baseMap = __webpack_require__(9078),
    isArray = __webpack_require__(8944);
/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */


function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

/***/ }),

/***/ 7094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(2391);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),

/***/ 5908:
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),

/***/ 4997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(4963),
    basePropertyDeep = __webpack_require__(2237),
    isKey = __webpack_require__(4704),
    toKey = __webpack_require__(2427);
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),

/***/ 246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(1624),
    baseEach = __webpack_require__(6867),
    baseIteratee = __webpack_require__(731),
    baseReduce = __webpack_require__(1056),
    isArray = __webpack_require__(8944);
/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */


function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

/***/ }),

/***/ 29:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(6266),
    getTag = __webpack_require__(8663),
    isArrayLike = __webpack_require__(5932),
    isString = __webpack_require__(4893),
    stringSize = __webpack_require__(5811);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */

function size(collection) {
  if (collection == null) {
    return 0;
  }

  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }

  var tag = getTag(collection);

  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }

  return baseKeys(collection).length;
}

module.exports = size;

/***/ }),

/***/ 2167:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ 6285:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ 7892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(2722);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),

/***/ 470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(411),
    baseCreate = __webpack_require__(5514),
    baseForOwn = __webpack_require__(6251),
    baseIteratee = __webpack_require__(731),
    getPrototype = __webpack_require__(8401),
    isArray = __webpack_require__(8944),
    isBuffer = __webpack_require__(6238),
    isFunction = __webpack_require__(6516),
    isObject = __webpack_require__(4819),
    isTypedArray = __webpack_require__(6341);
/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */


function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee, 4);

  if (accumulator == null) {
    var Ctor = object && object.constructor;

    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }

  (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;

/***/ }),

/***/ 4749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(158),
    baseRest = __webpack_require__(7632),
    baseUniq = __webpack_require__(4739),
    isArrayLikeObject = __webpack_require__(3323);
/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */


var union = baseRest(function (arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
module.exports = union;

/***/ }),

/***/ 6482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(4956),
    keys = __webpack_require__(6808);
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),

/***/ 7749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var supportedLoaders = {
  file: __webpack_require__(7663),
  http: __webpack_require__(3688),
  https: __webpack_require__(3688)
};
var defaultLoader = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' || typeof importScripts === 'function' ? supportedLoaders.http : supportedLoaders.file; // Load promises polyfill if necessary

/* istanbul ignore if */

if (typeof Promise === 'undefined') {
  __webpack_require__(606);
}

function getScheme(location) {
  if (typeof location !== 'undefined') {
    location = location.indexOf('://') === -1 ? '' : location.split('://')[0];
  }

  return location;
}
/**
 * Utility that provides a single API for loading the content of a path/URL.
 *
 * @module path-loader
 */


function getLoader(location) {
  var scheme = getScheme(location);
  var loader = supportedLoaders[scheme];

  if (typeof loader === 'undefined') {
    if (scheme === '') {
      loader = defaultLoader;
    } else {
      throw new Error('Unsupported scheme: ' + scheme);
    }
  }

  return loader;
}
/**
 * Loads a document at the provided location and returns a JavaScript object representation.
 *
 * @param {string} location - The location to the document
 * @param {module:path-loader.LoadOptions} [options] - The loader options
 *
 * @returns {Promise<*>} Always returns a promise even if there is a callback provided
 *
 * @example
 * // Example using Promises
 *
 * PathLoader
 *   .load('./package.json')
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.name + ' (' + document.version + '): ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example using options.prepareRequest to provide authentication details for a remotely secure URL
 *
 * PathLoader
 *   .load('https://api.github.com/repos/whitlockjc/path-loader', {
 *     prepareRequest: function (req, callback) {
 *       req.auth('my-username', 'my-password');
 *       callback(undefined, req);
 *     }
 *   })
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.full_name + ': ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml')
 *   .then(YAML.safeLoad)
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml', {
 *     processContent: function (res, callback) {
 *       callback(YAML.safeLoad(res.text));
 *     }
 *   })
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 */


module.exports.load = function (location, options) {
  var allTasks = Promise.resolve(); // Default options to empty object

  if (typeof options === 'undefined') {
    options = {};
  } // Validate arguments


  allTasks = allTasks.then(function () {
    if (typeof location === 'undefined') {
      throw new TypeError('location is required');
    } else if (typeof location !== 'string') {
      throw new TypeError('location must be a string');
    }

    if (typeof options !== 'undefined') {
      if (_typeof(options) !== 'object') {
        throw new TypeError('options must be an object');
      } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {
        throw new TypeError('options.processContent must be a function');
      }
    }
  }); // Load the document from the provided location and process it

  allTasks = allTasks.then(function () {
    return new Promise(function (resolve, reject) {
      var loader = getLoader(location);
      loader.load(location, options || {}, function (err, document) {
        if (err) {
          reject(err);
        } else {
          resolve(document);
        }
      });
    });
  }).then(function (res) {
    if (options.processContent) {
      return new Promise(function (resolve, reject) {
        // For consistency between file and http, always send an object with a 'text' property containing the raw
        // string value being processed.
        if (_typeof(res) !== 'object') {
          res = {
            text: res
          };
        } // Pass the path being loaded


        res.location = location;
        options.processContent(res, function (err, processed) {
          if (err) {
            reject(err);
          } else {
            resolve(processed);
          }
        });
      });
    } else {
      // If there was no content processor, we will assume that for all objects that it is a Superagent response
      // and will return its `text` property value.  Otherwise, we will return the raw response.
      return _typeof(res) === 'object' ? res.text : res;
    }
  });
  return allTasks;
};

/***/ }),

/***/ 7663:
/***/ ((module) => {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var unsupportedError = new TypeError('The \'file\' scheme is not supported in the browser');
/**
 * The file loader is not supported in the browser.
 *
 * @throws {error} the file loader is not supported in the browser
 */

module.exports.getBase = function () {
  throw unsupportedError;
};
/**
 * The file loader is not supported in the browser.
 */


module.exports.load = function () {
  var fn = arguments[arguments.length - 1];

  if (typeof fn === 'function') {
    fn(unsupportedError);
  } else {
    throw unsupportedError;
  }
};

/***/ }),

/***/ 3688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-env node, browser */

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var request = __webpack_require__(534);

var supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];
/**
 * Loads a file from an http or https URL.
 *
 * @param {string} location - The document URL (If relative, location is relative to window.location.origin).
 * @param {object} options - The loader options
 * @param {string} [options.method=get] - The HTTP method to use for the request
 * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request
 * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the
 * response
 * @param {function} callback - The error-first callback
 */

module.exports.load = function (location, options, callback) {
  var realMethod = options.method ? options.method.toLowerCase() : 'get';
  var err;
  var realRequest;

  function makeRequest(err, req) {
    if (err) {
      callback(err);
    } else {
      // buffer() is only available in Node.js
      if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && typeof req.buffer === 'function') {
        req.buffer(true);
      }

      req.end(function (err2, res) {
        if (err2) {
          callback(err2);
        } else {
          callback(undefined, res);
        }
      });
    }
  }

  if (typeof options.method !== 'undefined') {
    if (typeof options.method !== 'string') {
      err = new TypeError('options.method must be a string');
    } else if (supportedHttpMethods.indexOf(options.method) === -1) {
      err = new TypeError('options.method must be one of the following: ' + supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' + supportedHttpMethods[supportedHttpMethods.length - 1]);
    }
  } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {
    err = new TypeError('options.prepareRequest must be a function');
  }

  if (!err) {
    realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);

    if (options.prepareRequest) {
      try {
        options.prepareRequest(realRequest, makeRequest);
      } catch (err2) {
        callback(err2);
      }
    } else {
      makeRequest(undefined, realRequest);
    }
  } else {
    callback(err);
  }
};

/***/ }),

/***/ 5747:
/***/ ((module) => {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ 8468:
/***/ ((module) => {

"use strict";


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defaults = ['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert', 'disableTLSCerts'];

var Agent =
/*#__PURE__*/
function () {
  function Agent() {
    _classCallCheck(this, Agent);

    this._defaults = [];
  }

  _createClass(Agent, [{
    key: "_setDefaults",
    value: function _setDefaults(request) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._defaults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var def = _step.value;
          request[def.fn].apply(request, _toConsumableArray(def.args));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);

  return Agent;
}();

var _loop = function _loop() {
  var fn = _defaults[_i];

  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
};

for (var _i = 0, _defaults = defaults; _i < _defaults.length; _i++) {
  _loop();
}

module.exports = Agent;

/***/ }),

/***/ 534:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * Root reference for iframes.
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self === 'undefined') {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
} else {
  // Web Worker
  root = self;
}

var Emitter = __webpack_require__(5747);

var safeStringify = __webpack_require__(1046);

var qs = __webpack_require__(5995);

var RequestBase = __webpack_require__(6988);

var _require = __webpack_require__(4152),
    isObject = _require.isObject,
    mixin = _require.mixin,
    hasOwn = _require.hasOwn;

var ResponseBase = __webpack_require__(6762);

var Agent = __webpack_require__(8468);
/**
 * Noop.
 */


function noop() {}
/**
 * Expose `request`.
 */


module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports = module.exports;
var request = exports;
exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest) {
    return new root.XMLHttpRequest();
  }

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(object) {
  if (!isObject(object)) return object;
  var pairs = [];

  for (var key in object) {
    if (hasOwn(object, key)) pushEncodedKeyValuePair(pairs, key, object[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, value) {
  if (value === undefined) return;

  if (value === null) {
    pairs.push(encodeURI(key));
    return;
  }

  if (Array.isArray(value)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;
        pushEncodedKeyValuePair(pairs, key, v);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (isObject(value)) {
    for (var subkey in value) {
      if (hasOwn(value, subkey)) pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), value[subkey]);
    }
  } else {
    pairs.push(encodeURI(key) + '=' + encodeURIComponent(value));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(string_) {
  var object = {};
  var pairs = string_.split('&');
  var pair;
  var pos;

  for (var i = 0, length_ = pairs.length; i < length_; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos === -1) {
      object[decodeURIComponent(pair)] = '';
    } else {
      object[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return object;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': function applicationXWwwFormUrlencoded(obj) {
    return qs.stringify(obj, {
      indices: false,
      strictNullHandling: true
    });
  },
  'application/json': safeStringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(string_) {
  var lines = string_.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var value;

  for (var i = 0, length_ = lines.length; i < length_; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    value = trim(line.slice(index + 1));
    fields[field] = value;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[/+]json($|[^-\w])/i.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(request_) {
  this.req = request_;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method !== 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  this.header = this.headers; // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && request_._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method === 'HEAD' ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
}

mixin(Response.prototype, ResponseBase.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (string_) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, string_);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && string_ && (string_.length > 0 || string_ instanceof Object) ? parse(string_) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var message = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var error = new Error(message);
  error.status = this.status;
  error.method = method;
  error.url = url;
  return error;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var error = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (err) {
      error = new Error('Parser is unable to parse the response');
      error.parse = true;
      error.original = err; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        error.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        error.status = self.xhr.status ? self.xhr.status : null;
        error.statusCode = error.status; // backwards-compat only
      } else {
        error.rawResponse = null;
        error.status = null;
      }

      return self.callback(error);
    }

    self.emit('response', res);
    var new_error;

    try {
      if (!self._isResponseOK(res)) {
        new_error = new Error(res.statusText || res.text || 'Unsuccessful HTTP response');
      }
    } catch (err) {
      new_error = err; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_error) {
      new_error.original = error;
      new_error.response = res;
      new_error.status = new_error.status || res.status;
      self.callback(new_error, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */
// eslint-disable-next-line new-cap


Emitter(Request.prototype);
mixin(Request.prototype, RequestBase.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = options.encoder ? options.encoder : function (string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };
  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (value) {
  if (typeof value !== 'string') value = serialize(value);
  if (value) this._query.push(value);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (error, res) {
  if (this._shouldRetry(error, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (error) {
    if (this._maxRetries) error.retries = this._retries - 1;
    this.emit('error', error);
  }

  fn(error, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var error = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  error.crossDomain = true;
  error.status = this.status;
  error.method = this.method;
  error.url = this.url;
  this.callback(error);
}; // This only warns, because the request is still likely to work


Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
};

Request.prototype.ca = Request.prototype.agent;
Request.prototype.buffer = Request.prototype.ca; // This throws, because it can't send/receive data as expected

Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};

Request.prototype.pipe = Request.prototype.write;
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */

Request.prototype._isHost = function (object) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return object && _typeof(object) === 'object' && !Array.isArray(object) && Object.prototype.toString.call(object) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._setUploadTimeout = function () {
  var self = this; // upload timeout it's wokrs only if deadline timeout is off

  if (this._uploadTimeout && !this._uploadTimeoutTimer) {
    this._uploadTimeoutTimer = setTimeout(function () {
      self._timeoutError('Upload timeout of ', self._uploadTimeout, 'ETIMEDOUT');
    }, this._uploadTimeout);
  }
}; // eslint-disable-next-line complexity


Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  this.xhr = request.getXHR();
  var xhr = this.xhr;
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.addEventListener('readystatechange', function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState !== 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (err) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }); // progress

  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;

      if (e.percent === 100) {
        clearTimeout(self._uploadTimeoutTimer);
      }
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (err) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  if (xhr.upload) {
    this._setUploadTimeout();
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method !== 'GET' && this.method !== 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] === null) continue;
    if (hasOwn(this.header, field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data === 'undefined' ? null : data);
};

request.agent = function () {
  return new Agent();
};

var _loop = function _loop() {
  var method = _arr[_i];

  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var request_ = new request.Request(method, url);

    this._setDefaults(request_);

    if (fn) {
      request_.end(fn);
    }

    return request_;
  };
};

for (var _i = 0, _arr = ['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE']; _i < _arr.length; _i++) {
  _loop();
}

Agent.prototype.del = Agent.prototype["delete"];
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var request_ = request('GET', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.query(data);
  if (fn) request_.end(fn);
  return request_;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var request_ = request('HEAD', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.query(data);
  if (fn) request_.end(fn);
  return request_;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var request_ = request('OPTIONS', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var request_ = request('DELETE', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
}

request.del = del;
request["delete"] = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var request_ = request('PATCH', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var request_ = request('POST', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var request_ = request('PUT', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};

/***/ }),

/***/ 6988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * Module of mixed-in functions shared between node and client code
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(4152),
    isObject = _require.isObject,
    hasOwn = _require.hasOwn;
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase() {}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (value) {
  this._responseType = value;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function (options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }

  for (var option in options) {
    if (hasOwn(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;

        case 'response':
          this._responseTimeout = options.response;
          break;

        case 'upload':
          this._uploadTimeout = options.upload;
          break;

        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
}; //
// NOTE: we do not include ESOCKETTIMEDOUT because that is from `request` package
//       <https://github.com/sindresorhus/got/pull/537>
//
// NOTE: we do not include EADDRINFO because it was removed from libuv in 2014
//       <https://github.com/libuv/libuv/commit/02e1ebd40b807be5af46343ea873331b2ee4e9c1>
//       <https://github.com/request/request/search?q=ESOCKETTIMEDOUT&unscoped_q=ESOCKETTIMEDOUT>
//
//
// TODO: expose these as configurable defaults
//


var ERROR_CODES = new Set(['ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN']);
var STATUS_CODES = new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]); // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)
// const METHODS = new Set(['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE']);

/**
 * Determine if a request should be retried.
 * (Inspired by https://github.com/sindresorhus/got#retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */

RequestBase.prototype._shouldRetry = function (error, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(error, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (err) {
      console.error(err);
    }
  } // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)

  /*
  if (
    this.req &&
    this.req.method &&
    !METHODS.has(this.req.method.toUpperCase())
  )
    return false;
  */


  if (res && res.status && STATUS_CODES.has(res.status)) return true;

  if (error) {
    if (error.code && ERROR_CODES.has(error.code)) return true; // Superagent timeout

    if (error.timeout && error.code === 'ECONNABORTED') return true;
    if (error.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  this.timedoutError = null;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function (resolve, reject) {
  var _this = this;

  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (resolve, reject) {
      self.on('abort', function () {
        if (_this._maxRetries && _this._maxRetries > _this._retries) {
          return;
        }

        if (_this.timedout && _this.timedoutError) {
          reject(_this.timedoutError);
          return;
        }

        var error = new Error('Aborted');
        error.code = 'ABORTED';
        error.status = _this.status;
        error.method = _this.method;
        error.url = _this.url;
        reject(error);
      });
      self.end(function (error, res) {
        if (error) reject(error);else resolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype["catch"] = function (callback) {
  return this.then(undefined, callback);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (callback) {
  if (typeof callback !== 'function') throw new Error('Callback required');
  this._okCallback = callback;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, value) {
  if (isObject(field)) {
    for (var key in field) {
      if (hasOwn(field, key)) this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = value;
  this.header[field] = value;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @param {String} options extra options, e.g. 'blob'
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, value, options) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      if (hasOwn(name, key)) this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(value)) {
    for (var i in value) {
      if (hasOwn(value, i)) this.field(name, value[i]);
    }

    return this;
  } // val should be defined now


  if (value === null || undefined === value) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof value === 'boolean') {
    value = String(value);
  } // fix https://github.com/ladjs/superagent/issues/1680


  if (options) this._getFormData().append(name, value, options);else this._getFormData().append(name, value);
  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser

  if (this.req) {
    this.req.abort(); // node
  }

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;

    default:
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 * @param {Boolean} [on=true] - Set 'withCredentials' state
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */
// eslint-disable-next-line complexity


RequestBase.prototype.send = function (data) {
  var isObject_ = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject_ && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObject_ && isObject(this._data)) {
    for (var key in data) {
      if (typeof data[key] == 'bigint' && !data[key].toJSON) throw new Error('Cannot serialize BigInt value to json');
      if (hasOwn(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'bigint') throw new Error("Cannot send value of type BigInt");else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if (type) type = type.toLowerCase().trim();

    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObject_ || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.includes('?') ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArray = this.url.slice(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArray.sort(this._sort);
      } else {
        queryArray.sort();
      }

      this.url = this.url.slice(0, index) + '?' + queryArray.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.warn('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var error = new Error("".concat(reason + timeout, "ms exceeded"));
  error.timeout = timeout;
  error.code = 'ECONNABORTED';
  error.errno = errno;
  this.timedout = true;
  this.timedoutError = error;
  this.abort();
  this.callback(error);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

/***/ }),

/***/ 6762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * Module dependencies.
 */

var utils = __webpack_require__(4152);
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase() {}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var parameters = utils.params(ct);

  for (var key in parameters) {
    if (Object.prototype.hasOwnProperty.call(parameters, key)) this[key] = parameters[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = Math.trunc(status / 100); // status / class

  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type; // basics

  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false; // sugar

  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};

/***/ }),

/***/ 4152:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.type = function (string_) {
  return string_.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (value) {
  var object = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = value.split(/ *; */)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var string_ = _step.value;
      var parts = string_.split(/ *= */);
      var key = parts.shift();

      var _value = parts.shift();

      if (key && _value) object[key] = _value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return object;
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (value) {
  var object = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = value.split(/ *, */)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var string_ = _step2.value;
      var parts = string_.split(/ *; */);
      var url = parts[0].slice(1, -1);
      var rel = parts[1].split(/ *= */)[1].slice(1, -1);
      object[rel] = url;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return object;
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};
/**
 * Check if `obj` is an object.
 *
 * @param {Object} object
 * @return {Boolean}
 * @api private
 */


exports.isObject = function (object) {
  return object !== null && _typeof(object) === 'object';
};
/**
 * Object.hasOwn fallback/polyfill.
 *
 * @type {(object: object, property: string) => boolean} object
 * @api private
 */


exports.hasOwn = Object.hasOwn || function (object, property) {
  if (object == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  return Object.prototype.hasOwnProperty.call(new Object(object), property);
};

exports.mixin = function (target, source) {
  for (var key in source) {
    if (exports.hasOwn(source, key)) {
      target[key] = source[key];
    }
  }
};
/**
 * Check if the response is compressed using Gzip or Deflate.
 * @param {Object} res
 * @return {Boolean}
 */


exports.isGzipOrDeflateEncoding = function (res) {
  return new RegExp(/^\s*(?:deflate|gzip)\s*$/).test(res.headers['content-encoding']);
};
/**
 * Check if the response is compressed using Brotli.
 * @param {Object} res
 * @return {Boolean}
 */


exports.isBrotliEncoding = function (res) {
  return new RegExp(/^\s*(?:br)\s*$/).test(res.headers['content-encoding']);
};

/***/ }),

/***/ 606:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
(function UMD(name, context, definition) {
  // special form of UMD for polyfilling across evironments
  context[name] = context[name] || definition();

  if ( true && module.exports) {
    module.exports = context[name];
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function $AMD$() {
      return context[name];
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})("Promise", typeof __webpack_require__.g != "undefined" ? __webpack_require__.g : this, function DEF() {
  /*jshint validthis:true */
  "use strict";

  var builtInProp,
      cycle,
      scheduling_queue,
      ToString = Object.prototype.toString,
      timer = typeof setImmediate != "undefined" ? function timer(fn) {
    return setImmediate(fn);
  } : setTimeout; // dammit, IE8.

  try {
    Object.defineProperty({}, "x", {});

    builtInProp = function builtInProp(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  } // Note: using a queue instead of array for efficiency


  scheduling_queue = function Queue() {
    var first, last, item;

    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }

    return {
      add: function add(fn, self) {
        item = new Item(fn, self);

        if (last) {
          last.next = item;
        } else {
          first = item;
        }

        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;

        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();

  function schedule(fn, self) {
    scheduling_queue.add(fn, self);

    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  } // promise duck typing


  function isThenable(o) {
    var _then,
        o_type = _typeof(o);

    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }

    return typeof _then == "function" ? _then : false;
  }

  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }

    this.chain.length = 0;
  } // NOTE: This is a separate function to isolate
  // the `try..catch` so that other code can be
  // optimized better


  function notifyIsolated(self, cb, chain) {
    var ret, _then;

    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }

        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }

  function resolve(msg) {
    var _then,
        self = this; // already triggered?


    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    try {
      if (_then = isThenable(msg)) {
        schedule(function () {
          var def_wrapper = new MakeDefWrapper(self);

          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;

        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }

  function reject(msg) {
    var self = this; // already triggered?

    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    self.msg = msg;
    self.state = 2;

    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }

  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx) {
        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
          resolver(idx, msg);
        }, rejecter);
      })(idx);
    }
  }

  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }

  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }

  function Promise(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }

    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    } // instance shadowing the inherited "brand"
    // to signal an already "initialized" promise


    this.__NPO__ = 1;
    var def = new MakeDef(this);

    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      }; // Note: `then(..)` itself can be borrowed to be used against
      // a different promise constructor for making the chained promise,
      // by substituting a different `this` binding.

      o.promise = new this.constructor(function extractChain(resolve, reject) {
        if (typeof resolve != "function" || typeof reject != "function") {
          throw TypeError("Not a function");
        }

        o.resolve = resolve;
        o.reject = reject;
      });
      def.chain.push(o);

      if (def.state !== 0) {
        schedule(notify, def);
      }

      return o.promise;
    };

    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };

    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }

  var PromisePrototype = builtInProp({}, "constructor", Promise,
  /*configurable=*/
  false); // Note: Android 4 cannot use `Object.defineProperty(..)` here

  Promise.prototype = PromisePrototype; // built-in "brand" to signal an "uninitialized" promise

  builtInProp(PromisePrototype, "__NPO__", 0,
  /*configurable=*/
  false);
  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
    var Constructor = this; // spec mandated checks
    // note: best "isPromise" check that's practical for now

    if (msg && _typeof(msg) == "object" && msg.__NPO__ === 1) {
      return msg;
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      resolve(msg);
    });
  });
  builtInProp(Promise, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      reject(msg);
    });
  });
  builtInProp(Promise, "all", function Promise$all(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    if (arr.length === 0) {
      return Constructor.resolve([]);
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      var len = arr.length,
          msgs = Array(len),
          count = 0;
      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;

        if (++count === len) {
          resolve(msgs);
        }
      }, reject);
    });
  });
  builtInProp(Promise, "race", function Promise$race(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve(msg);
      }, reject);
    });
  });
  return Promise;
});

/***/ }),

/***/ 7809:
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
} // Resolves . and .. elements in a path with directory names


function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;

  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length) code = path.charCodeAt(i);else if (code === 47
    /*/*/
    ) break;else code = 47
    /*/*/
    ;

    if (code === 47
    /*/*/
    ) {
        if (lastSlash === i - 1 || dots === 1) {// NOOP
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46
          /*.*/
          || res.charCodeAt(res.length - 2) !== 46
          /*.*/
          ) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf('/');

                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = '';
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                  }

                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = '';
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }

          if (allowAboveRoot) {
            if (res.length > 0) res += '/..';else res = '..';
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
          lastSegmentLength = i - lastSlash - 1;
        }

        lastSlash = i;
        dots = 0;
      } else if (code === 46
    /*.*/
    && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }

  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');

  if (!dir) {
    return base;
  }

  if (dir === pathObject.root) {
    return dir + base;
  }

  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0) path = arguments[i];else {
        if (cwd === undefined) cwd = process.cwd();
        path = cwd;
      }
      assertPath(path); // Skip empty entries

      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47
      /*/*/
      ;
    } // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path


    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },
  normalize: function normalize(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var isAbsolute = path.charCodeAt(0) === 47
    /*/*/
    ;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47
    /*/*/
    ; // Normalize the path

    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';
    if (isAbsolute) return '/' + path;
    return path;
  },
  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47
    /*/*/
    ;
  },
  join: function join() {
    if (arguments.length === 0) return '.';
    var joined;

    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);

      if (arg.length > 0) {
        if (joined === undefined) joined = arg;else joined += '/' + arg;
      }
    }

    if (joined === undefined) return '.';
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return '';
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) return ''; // Trim any leading backslashes

    var fromStart = 1;

    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47
      /*/*/
      ) break;
    }

    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart; // Trim any leading backslashes

    var toStart = 1;

    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47
      /*/*/
      ) break;
    }

    var toEnd = to.length;
    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root

    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;

    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47
          /*/*/
          ) {
              // We get here if `from` is the exact base path for `to`.
              // For example: from='/foo/bar'; to='/foo/bar/baz'
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47
          /*/*/
          ) {
              // We get here if `to` is the exact base path for `from`.
              // For example: from='/foo/bar/baz'; to='/foo/bar'
              lastCommonSep = i;
            } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }

        break;
      }

      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) break;else if (fromCode === 47
      /*/*/
      ) lastCommonSep = i;
    }

    var out = ''; // Generate the relative path based on the path difference between `to`
    // and `from`

    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47
      /*/*/
      ) {
          if (out.length === 0) out += '..';else out += '/..';
        }
    } // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts


    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47
      /*/*/
      ) ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path) {
    return path;
  },
  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47
    /*/*/
    ;
    var end = -1;
    var matchedSlash = true;

    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },
  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;

      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);

        if (code === 47
        /*/*/
        ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }

          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47
        /*/*/
        ) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },
  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    var preDotState = 0;

    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === 46
      /*.*/
      ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }

    return path.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || _typeof(pathObject) !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + _typeof(pathObject));
    }

    return _format('/', pathObject);
  },
  parse: function parse(path) {
    assertPath(path);
    var ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47
    /*/*/
    ;
    var start;

    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }

    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find

    var preDotState = 0; // Get non-dir info

    for (; i >= start; --i) {
      code = path.charCodeAt(i);

      if (code === 47
      /*/*/
      ) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }

          continue;
        }

      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }

      if (code === 46
      /*.*/
      ) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }

      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
    return ret;
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};
posix.posix = posix;
module.exports = posix;

/***/ }),

/***/ 1423:
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: 'RFC1738',
  RFC3986: 'RFC3986'
};
module.exports = {
  'default': Format.RFC3986,
  formatters: {
    RFC1738: function RFC1738(value) {
      return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function RFC3986(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};

/***/ }),

/***/ 5995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(4090);

var parse = __webpack_require__(6244);

var formats = __webpack_require__(1423);

module.exports = {
  formats: formats,
  parse: parse,
  stringify: stringify
};

/***/ }),

/***/ 6244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(9974);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: 'utf-8',
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: false,
  decoder: utils.decode,
  delimiter: '&',
  depth: 5,
  duplicates: 'combine',
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1000,
  parseArrays: true,
  plainObjects: false,
  strictDepth: false,
  strictNullHandling: false
};

var interpretNumericEntities = function interpretNumericEntities(str) {
  return str.replace(/&#(\d+);/g, function ($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};

var parseArrayValue = function parseArrayValue(val, options) {
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
    return val.split(',');
  }

  return val;
}; // This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.


var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.

var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
  var obj = {
    __proto__: null
  };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
  cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1; // Keep track of where the utf8 sentinel was found

  var i;
  var charset = options.charset;

  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf('utf8=') === 0) {
        if (parts[i] === charsetSentinel) {
          charset = 'utf-8';
        } else if (parts[i] === isoSentinel) {
          charset = 'iso-8859-1';
        }

        skipIndex = i;
        i = parts.length; // The eslint settings do not allow break;
      }
    }
  }

  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }

    var part = parts[i];
    var bracketEqualsPos = part.indexOf(']=');
    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
    var key, val;

    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, 'key');
      val = options.strictNullHandling ? null : '';
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
      });
    }

    if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
      val = interpretNumericEntities(val);
    }

    if (part.indexOf('[]=') > -1) {
      val = isArray(val) ? [val] : val;
    }

    var existing = has.call(obj, key);

    if (existing && options.duplicates === 'combine') {
      obj[key] = utils.combine(obj[key], val);
    } else if (!existing || options.duplicates === 'last') {
      obj[key] = val;
    }
  }

  return obj;
};

var parseObject = function parseObject(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);

  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];

    if (root === '[]' && options.parseArrays) {
      obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
      var index = parseInt(decodedRoot, 10);

      if (!options.parseArrays && decodedRoot === '') {
        obj = {
          0: leaf
        };
      } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = leaf;
      } else if (decodedRoot !== '__proto__') {
        obj[decodedRoot] = leaf;
      }
    }

    leaf = obj;
  }

  return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  } // Transform dot notation to bracket notation


  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks

  var brackets = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g; // Get the parent

  var segment = options.depth > 0 && brackets.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists

  var keys = [];

  if (parent) {
    // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(parent);
  } // Loop through children appending to the array until we hit depth


  var i = 0;

  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;

    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(segment[1]);
  } // If there's a remainder, check strictDepth option for throw, else just add whatever is left


  if (segment) {
    if (options.strictDepth === true) {
      throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
    }

    keys.push('[' + key.slice(segment.index) + ']');
  }

  return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
  if (!opts) {
    return defaults;
  }

  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
  }

  if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
    throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
  }

  if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
    throw new TypeError('Decoder has to be a function.');
  }

  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }

  var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
  var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

  if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
    throw new TypeError('The duplicates option must be either combine, first, or last');
  }

  var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    allowDots: allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
    decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
    duplicates: duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
    strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};

module.exports = function (str, opts) {
  var options = normalizeParseOptions(opts);

  if (str === '' || str === null || typeof str === 'undefined') {
    return options.plainObjects ? Object.create(null) : {};
  }

  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object

  var keys = Object.keys(tempObj);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
    obj = utils.merge(obj, newObj, options);
  }

  if (options.allowSparse === true) {
    return obj;
  }

  return utils.compact(obj);
};

/***/ }),

/***/ 4090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var getSideChannel = __webpack_require__(6402);

var utils = __webpack_require__(9974);

var formats = __webpack_require__(1423);

var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + '[]';
  },
  comma: 'comma',
  indices: function indices(prefix, key) {
    return prefix + '[' + key + ']';
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray = Array.isArray;
var push = Array.prototype.push;

var pushToArray = function pushToArray(arr, valueOrArray) {
  push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: 'indices',
  charset: 'utf-8',
  charsetSentinel: false,
  delimiter: '&',
  encode: true,
  encodeDotInKeys: false,
  encoder: utils.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
  return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || _typeof(v) === 'symbol' || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  var obj = object;
  var tmpSc = sideChannel;
  var step = 0;
  var findFlag = false;

  while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
    // Where object last appeared in the ref tree
    var pos = tmpSc.get(object);
    step += 1;

    if (typeof pos !== 'undefined') {
      if (pos === step) {
        throw new RangeError('Cyclic object value');
      } else {
        findFlag = true; // Break while
      }
    }

    if (typeof tmpSc.get(sentinel) === 'undefined') {
      step = 0;
    }
  }

  if (typeof filter === 'function') {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate(obj);
  } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
    obj = utils.maybeMap(obj, function (value) {
      if (value instanceof Date) {
        return serializeDate(value);
      }

      return value;
    });
  }

  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
    }

    obj = '';
  }

  if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
      return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
    }

    return [formatter(prefix) + '=' + formatter(String(obj))];
  }

  var values = [];

  if (typeof obj === 'undefined') {
    return values;
  }

  var objKeys;

  if (generateArrayPrefix === 'comma' && isArray(obj)) {
    // we need to join elements in
    if (encodeValuesOnly && encoder) {
      obj = utils.maybeMap(obj, encoder);
    }

    objKeys = [{
      value: obj.length > 0 ? obj.join(',') || null : void undefined
    }];
  } else if (isArray(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }

  var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;
  var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjustedPrefix + '[]';
  }

  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = _typeof(key) === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

    if (skipNulls && value === null) {
      continue;
    }

    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
    var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
    sideChannel.set(object, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel);
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }

  return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
  if (!opts) {
    return defaults;
  }

  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
  }

  if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
    throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
  }

  if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
    throw new TypeError('Encoder has to be a function.');
  }

  var charset = opts.charset || defaults.charset;

  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }

  var format = formats['default'];

  if (typeof opts.format !== 'undefined') {
    if (!has.call(formats.formatters, opts.format)) {
      throw new TypeError('Unknown format option provided.');
    }

    format = opts.format;
  }

  var formatter = formats.formatters[format];
  var filter = defaults.filter;

  if (typeof opts.filter === 'function' || isArray(opts.filter)) {
    filter = opts.filter;
  }

  var arrayFormat;

  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ('indices' in opts) {
    arrayFormat = opts.indices ? 'indices' : 'repeat';
  } else {
    arrayFormat = defaults.arrayFormat;
  }

  if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
    throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
  }

  var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
    allowDots: allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat: arrayFormat,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter: filter,
    format: format,
    formatter: formatter,
    serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
    sort: typeof opts.sort === 'function' ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};

module.exports = function (object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;

  if (typeof options.filter === 'function') {
    filter = options.filter;
    obj = filter('', obj);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }

  var keys = [];

  if (_typeof(obj) !== 'object' || obj === null) {
    return '';
  }

  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

  if (!objKeys) {
    objKeys = Object.keys(obj);
  }

  if (options.sort) {
    objKeys.sort(options.sort);
  }

  var sideChannel = getSideChannel();

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (options.skipNulls && obj[key] === null) {
      continue;
    }

    pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }

  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? '?' : '';

  if (options.charsetSentinel) {
    if (options.charset === 'iso-8859-1') {
      // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
      prefix += 'utf8=%26%2310003%3B&';
    } else {
      // encodeURIComponent('✓')
      prefix += 'utf8=%E2%9C%93&';
    }
  }

  return joined.length > 0 ? prefix + joined : '';
};

/***/ }),

/***/ 9974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var formats = __webpack_require__(1423);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = function () {
  var array = [];

  for (var i = 0; i < 256; ++i) {
    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
  }

  return array;
}();

var compactQueue = function compactQueue(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];

    if (isArray(obj)) {
      var compacted = [];

      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== 'undefined') {
          compacted.push(obj[j]);
        }
      }

      item.obj[item.prop] = compacted;
    }
  }
};

var arrayToObject = function arrayToObject(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};

  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== 'undefined') {
      obj[i] = source[i];
    }
  }

  return obj;
};

var merge = function merge(target, source, options) {
  /* eslint no-param-reassign: 0 */
  if (!source) {
    return target;
  }

  if (_typeof(source) !== 'object') {
    if (isArray(target)) {
      target.push(source);
    } else if (target && _typeof(target) === 'object') {
      if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }

    return target;
  }

  if (!target || _typeof(target) !== 'object') {
    return [target].concat(source);
  }

  var mergeTarget = target;

  if (isArray(target) && !isArray(source)) {
    mergeTarget = arrayToObject(target, options);
  }

  if (isArray(target) && isArray(source)) {
    source.forEach(function (item, i) {
      if (has.call(target, i)) {
        var targetItem = target[i];

        if (targetItem && _typeof(targetItem) === 'object' && item && _typeof(item) === 'object') {
          target[i] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }

  return Object.keys(source).reduce(function (acc, key) {
    var value = source[key];

    if (has.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }

    return acc;
  }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function (acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};

var decode = function decode(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, ' ');

  if (charset === 'iso-8859-1') {
    // unescape never throws, no try...catch needed:
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  } // utf-8


  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};

var limit = 1024;
/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
  // It has been adapted here for stricter adherence to RFC 3986
  if (str.length === 0) {
    return str;
  }

  var string = str;

  if (_typeof(str) === 'symbol') {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== 'string') {
    string = String(str);
  }

  if (charset === 'iso-8859-1') {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
      return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
    });
  }

  var out = '';

  for (var j = 0; j < string.length; j += limit) {
    var segment = string.length >= limit ? string.slice(j, j + limit) : string;
    var arr = [];

    for (var i = 0; i < segment.length; ++i) {
      var c = segment.charCodeAt(i);

      if (c === 0x2D // -
      || c === 0x2E // .
      || c === 0x5F // _
      || c === 0x7E // ~
      || c >= 0x30 && c <= 0x39 // 0-9
      || c >= 0x41 && c <= 0x5A // a-z
      || c >= 0x61 && c <= 0x7A // A-Z
      || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
      ) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }

      if (c < 0x80) {
        arr[arr.length] = hexTable[c];
        continue;
      }

      if (c < 0x800) {
        arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
        continue;
      }

      if (c < 0xD800 || c >= 0xE000) {
        arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        continue;
      }

      i += 1;
      c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
      arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }

    out += arr.join('');
  }

  return out;
};

var compact = function compact(value) {
  var queue = [{
    obj: {
      o: value
    },
    prop: 'o'
  }];
  var refs = [];

  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];

      if (_typeof(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
        queue.push({
          obj: obj,
          prop: key
        });
        refs.push(val);
      }
    }
  }

  compactQueue(queue);
  return value;
};

var isRegExp = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
  if (!obj || _typeof(obj) !== 'object') {
    return false;
  }

  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
  return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
  if (isArray(val)) {
    var mapped = [];

    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }

    return mapped;
  }

  return fn(val);
};

module.exports = {
  arrayToObject: arrayToObject,
  assign: assign,
  combine: combine,
  compact: compact,
  decode: decode,
  encode: encode,
  isBuffer: isBuffer,
  isRegExp: isRegExp,
  maybeMap: maybeMap,
  merge: merge
};

/***/ }),

/***/ 9700:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ 3484:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ 7216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(9700);
exports.encode = exports.stringify = __webpack_require__(3484);

/***/ }),

/***/ 5887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8299);

var define = __webpack_require__(3423);

var hasDescriptors = __webpack_require__(6698)();

var gOPD = __webpack_require__(3581);

var $TypeError = __webpack_require__(1953);

var $floor = GetIntrinsic('%Math.floor%');
/** @type {import('.')} */

module.exports = function setFunctionLength(fn, length) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }

  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    throw new $TypeError('`length` must be a positive 32-bit integer');
  }

  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;

  if ('length' in fn && gOPD) {
    var desc = gOPD(fn, 'length');

    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }

    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }

  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(
      /** @type {Parameters<define>[0]} */
      fn, 'length', length, true, true);
    } else {
      define(
      /** @type {Parameters<define>[0]} */
      fn, 'length', length);
    }
  }

  return fn;
};

/***/ }),

/***/ 6402:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var GetIntrinsic = __webpack_require__(8299);

var callBound = __webpack_require__(2857);

var inspect = __webpack_require__(3404);

var $TypeError = __webpack_require__(1953);

var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);
var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/

/** @type {import('.').listGetNode} */

var listGetNode = function listGetNode(list, key) {
  // eslint-disable-line consistent-return

  /** @type {typeof list | NonNullable<(typeof list)['next']>} */
  var prev = list;
  /** @type {(typeof list)['next']} */

  var curr;

  for (; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next; // eslint-disable-next-line no-extra-parens

      curr.next =
      /** @type {NonNullable<typeof list.next>} */
      list.next;
      list.next = curr; // eslint-disable-line no-param-reassign

      return curr;
    }
  }
};
/** @type {import('.').listGet} */


var listGet = function listGet(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
/** @type {import('.').listSet} */


var listSet = function listSet(objects, key, value) {
  var node = listGetNode(objects, key);

  if (node) {
    node.value = value;
  } else {
    // Prepend the new node to the beginning of the list
    objects.next =
    /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: key,
      next: objects.next,
      value: value
    };
  }
};
/** @type {import('.').listHas} */


var listHas = function listHas(objects, key) {
  return !!listGetNode(objects, key);
};
/** @type {import('.')} */


module.exports = function getSideChannel() {
  /** @type {WeakMap<object, unknown>} */
  var $wm;
  /** @type {Map<object, unknown>} */

  var $m;
  /** @type {import('.').RootNode<unknown>} */

  var $o;
  /** @type {import('.').Channel} */

  var channel = {
    assert: function assert(key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    get: function get(key) {
      // eslint-disable-line consistent-return
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listGet($o, key);
        }
      }
    },
    has: function has(key) {
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listHas($o, key);
        }
      }

      return false;
    },
    set: function set(key, value) {
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if (!$wm) {
          $wm = new $WeakMap();
        }

        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }

        $mapSet($m, key, value);
      } else {
        if (!$o) {
          // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
          $o = {
            key: {},
            next: null
          };
        }

        listSet($o, key, value);
      }
    }
  };
  return channel;
};

/***/ }),

/***/ 3404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'object'; // ie, `has-tostringtag/shams

var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (_typeof(Symbol.toStringTag) === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
? function (O) {
  return O.__proto__; // eslint-disable-line no-proto
} : null);

function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
    return str;
  }

  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;

  if (typeof num === 'number') {
    var _int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)


    if (_int !== num) {
      var intStr = String(_int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
    }
  }

  return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(1635);

var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
  var opts = options || {};

  if (has(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }

  if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }

  var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;

  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
  }

  if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }

  if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }

  var numericSeparator = opts.numericSeparator;

  if (typeof obj === 'undefined') {
    return 'undefined';
  }

  if (obj === null) {
    return 'null';
  }

  if (typeof obj === 'boolean') {
    return obj ? 'true' : 'false';
  }

  if (typeof obj === 'string') {
    return inspectString(obj, opts);
  }

  if (typeof obj === 'number') {
    if (obj === 0) {
      return Infinity / obj > 0 ? '0' : '-0';
    }

    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }

  if (typeof obj === 'bigint') {
    var bigIntStr = String(obj) + 'n';
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }

  var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;

  if (typeof depth === 'undefined') {
    depth = 0;
  }

  if (depth >= maxDepth && maxDepth > 0 && _typeof(obj) === 'object') {
    return isArray(obj) ? '[Array]' : '[Object]';
  }

  var indent = getIndent(opts, depth);

  if (typeof seen === 'undefined') {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return '[Circular]';
  }

  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }

    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };

      if (has(opts, 'quoteStyle')) {
        newOpts.quoteStyle = opts.quoteStyle;
      }

      return inspect_(value, newOpts, depth + 1, seen);
    }

    return inspect_(value, opts, depth + 1, seen);
  }

  if (typeof obj === 'function' && !isRegExp(obj)) {
    // in older engines, regexes are callable
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect);
    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
  }

  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
    return _typeof(obj) === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
  }

  if (isElement(obj)) {
    var s = '<' + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];

    for (var i = 0; i < attrs.length; i++) {
      s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
    }

    s += '>';

    if (obj.childNodes && obj.childNodes.length) {
      s += '...';
    }

    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
    return s;
  }

  if (isArray(obj)) {
    if (obj.length === 0) {
      return '[]';
    }

    var xs = arrObjKeys(obj, inspect);

    if (indent && !singleLineValues(xs)) {
      return '[' + indentedJoin(xs, indent) + ']';
    }

    return '[ ' + $join.call(xs, ', ') + ' ]';
  }

  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);

    if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
      return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
    }

    if (parts.length === 0) {
      return '[' + String(obj) + ']';
    }

    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
  }

  if (_typeof(obj) === 'object' && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
      return utilInspect(obj, {
        depth: maxDepth - depth
      });
    } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
      return obj.inspect();
    }
  }

  if (isMap(obj)) {
    var mapParts = [];

    if (mapForEach) {
      mapForEach.call(obj, function (value, key) {
        mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
      });
    }

    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
  }

  if (isSet(obj)) {
    var setParts = [];

    if (setForEach) {
      setForEach.call(obj, function (value) {
        setParts.push(inspect(value, obj));
      });
    }

    return collectionOf('Set', setSize.call(obj), setParts, indent);
  }

  if (isWeakMap(obj)) {
    return weakCollectionOf('WeakMap');
  }

  if (isWeakSet(obj)) {
    return weakCollectionOf('WeakSet');
  }

  if (isWeakRef(obj)) {
    return weakCollectionOf('WeakRef');
  }

  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }

  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }

  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }

  if (isString(obj)) {
    return markBoxed(inspect(String(obj)));
  } // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other

  /* eslint-env browser */


  if (typeof window !== 'undefined' && obj === window) {
    return '{ [object Window] }';
  }

  if (typeof globalThis !== 'undefined' && obj === globalThis || typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g) {
    return '{ [object globalThis] }';
  }

  if (!isDate(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? '' : 'null prototype';
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');

    if (ys.length === 0) {
      return tag + '{}';
    }

    if (indent) {
      return tag + '{' + indentedJoin(ys, indent) + '}';
    }

    return tag + '{ ' + $join.call(ys, ', ') + ' }';
  }

  return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
  return quoteChar + s + quoteChar;
}

function quote(s) {
  return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) {
  return toStr(obj) === '[object Array]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isDate(obj) {
  return toStr(obj) === '[object Date]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isRegExp(obj) {
  return toStr(obj) === '[object RegExp]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isError(obj) {
  return toStr(obj) === '[object Error]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isString(obj) {
  return toStr(obj) === '[object String]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isNumber(obj) {
  return toStr(obj) === '[object Number]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isBoolean(obj) {
  return toStr(obj) === '[object Boolean]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
} // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives


function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && _typeof(obj) === 'object' && obj instanceof Symbol;
  }

  if (_typeof(obj) === 'symbol') {
    return true;
  }

  if (!obj || _typeof(obj) !== 'object' || !symToString) {
    return false;
  }

  try {
    symToString.call(obj);
    return true;
  } catch (e) {}

  return false;
}

function isBigInt(obj) {
  if (!obj || _typeof(obj) !== 'object' || !bigIntValueOf) {
    return false;
  }

  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {}

  return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) {
  return key in this;
};

function has(obj, key) {
  return hasOwn.call(obj, key);
}

function toStr(obj) {
  return objectToString.call(obj);
}

function nameOf(f) {
  if (f.name) {
    return f.name;
  }

  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);

  if (m) {
    return m[1];
  }

  return null;
}

function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }

  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }

  return -1;
}

function isMap(x) {
  if (!mapSize || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    mapSize.call(x);

    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }

    return x instanceof Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakMap(x) {
  if (!weakMapHas || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakMapHas.call(x, weakMapHas);

    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakRef(x) {
  if (!weakRefDeref || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {}

  return false;
}

function isSet(x) {
  if (!setSize || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    setSize.call(x);

    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }

    return x instanceof Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakSet(x) {
  if (!weakSetHas || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakSetHas.call(x, weakSetHas);

    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isElement(x) {
  if (!x || _typeof(x) !== 'object') {
    return false;
  }

  if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
    return true;
  }

  return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  } // eslint-disable-next-line no-control-regex


  var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: 'b',
    9: 't',
    10: 'n',
    12: 'f',
    13: 'r'
  }[n];

  if (x) {
    return '\\' + x;
  }

  return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
  return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
  return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
  return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], '\n') >= 0) {
      return false;
    }
  }

  return true;
}

function getIndent(opts, depth) {
  var baseIndent;

  if (opts.indent === '\t') {
    baseIndent = '\t';
  } else if (typeof opts.indent === 'number' && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), ' ');
  } else {
    return null;
  }

  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}

function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return '';
  }

  var lineJoiner = '\n' + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
  var isArr = isArray(obj);
  var xs = [];

  if (isArr) {
    xs.length = obj.length;

    for (var i = 0; i < obj.length; i++) {
      xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
    }
  }

  var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
  var symMap;

  if (hasShammedSymbols) {
    symMap = {};

    for (var k = 0; k < syms.length; k++) {
      symMap['$' + syms[k]] = syms[k];
    }
  }

  for (var key in obj) {
    // eslint-disable-line no-restricted-syntax
    if (!has(obj, key)) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
      // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
    } else {
      xs.push(key + ': ' + inspect(obj[key], obj));
    }
  }

  if (typeof gOPS === 'function') {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
      }
    }
  }

  return xs;
}

/***/ }),

/***/ 1596:
/***/ ((module) => {

"use strict";


module.exports = function (path) {
  var isExtendedLengthPath = /^\\\\\?\\/.test(path);
  var hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

  if (isExtendedLengthPath || hasNonAscii) {
    return path;
  }

  return path.replace(/\\/g, '/');
};

/***/ }),

/***/ 3129:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
  ( false ? 0 : _typeof(exports)) === 'object' && "object" !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
})(this, function (exports) {
  'use strict';

  function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
      sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
      sets[0] = sets[0].slice(0, -1);
      var xl = sets.length - 1;

      for (var x = 1; x < xl; ++x) {
        sets[x] = sets[x].slice(1, -1);
      }

      sets[xl] = sets[xl].slice(1);
      return sets.join('');
    } else {
      return sets[0];
    }
  }

  function subexp(str) {
    return "(?:" + str + ")";
  }

  function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
  }

  function toUpperCase(str) {
    return str.toUpperCase();
  }

  function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
  }

  function assign(target, source) {
    var obj = target;

    if (source) {
      for (var key in source) {
        obj[key] = source[key];
      }
    }

    return obj;
  }

  function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
      NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
      NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
      NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
      ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      UNRESERVED: new RegExp(UNRESERVED$$, "g"),
      OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
      PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
      IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
      IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules

    };
  }

  var URI_PROTOCOL = buildExps(false);
  var IRI_PROTOCOL = buildExps(true);

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  };
  /** Highest positive signed 32-bit float value */


  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */

  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80

  var delimiter = '-'; // '\x2D'

  /** Regular expressions */

  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars

  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */

  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };
  /** Convenience shortcuts */

  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error$1(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var result = [];
    var length = array.length;

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  var ucs2encode = function ucs2encode(array) {
    return String.fromCodePoint.apply(String, toConsumableArray(array));
  };
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  var basicToDigit = function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
      return codePoint - 0x16;
    }

    if (codePoint - 0x41 < 0x1A) {
      return codePoint - 0x41;
    }

    if (codePoint - 0x61 < 0x1A) {
      return codePoint - 0x61;
    }

    return base;
  };
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  var decode = function decode(input) {
    // Don't use UCS-2.
    var output = [];
    var inputLength = input.length;
    var i = 0;
    var n = initialN;
    var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    var basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (var j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error$1('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      var oldi = i;

      for (var w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error$1('invalid-input');
        }

        var digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error$1('overflow');
        }

        i += digit * w;
        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        var baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error$1('overflow');
        }

        w *= baseMinusT;
      }

      var out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error$1('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output.

      output.splice(i++, 0, n);
    }

    return String.fromCodePoint.apply(String, output);
  };
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  var encode = function encode(input) {
    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

    input = ucs2decode(input); // Cache the length.

    var inputLength = input.length; // Initialize the state.

    var n = initialN;
    var delta = 0;
    var bias = initialBias; // Handle the basic code points.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _currentValue2 = _step.value;

        if (_currentValue2 < 0x80) {
          output.push(stringFromCharCode(_currentValue2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var basicLength = output.length;
    var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string with a delimiter unless it's empty.

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var currentValue = _step2.value;

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _currentValue = _step3.value;

          if (_currentValue < n && ++delta > maxInt) {
            error$1('overflow');
          }

          if (_currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;

            for (var k = base;;
            /* no condition */
            k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (q < t) {
                break;
              }

              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  };
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  var toUnicode = function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  var toASCII = function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '2.1.0',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /**
   * URI.js
   *
   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/uri-js
   */

  /**
   * Copyright 2011 Gary Court. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification, are
   * permitted provided that the following conditions are met:
   *
   *    1. Redistributions of source code must retain the above copyright notice, this list of
   *       conditions and the following disclaimer.
   *
   *    2. Redistributions in binary form must reproduce the above copyright notice, this list
   *       of conditions and the following disclaimer in the documentation and/or other materials
   *       provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The views and conclusions contained in the software and documentation are those of the
   * authors and should not be interpreted as representing official policies, either expressed
   * or implied, of Gary Court.
   */

  var SCHEMES = {};

  function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
  }

  function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;

    while (i < il) {
      var c = parseInt(str.substr(i + 1, 2), 16);

      if (c < 128) {
        newStr += String.fromCharCode(c);
        i += 3;
      } else if (c >= 194 && c < 224) {
        if (il - i >= 6) {
          var c2 = parseInt(str.substr(i + 4, 2), 16);
          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
        } else {
          newStr += str.substr(i, 6);
        }

        i += 6;
      } else if (c >= 224) {
        if (il - i >= 9) {
          var _c = parseInt(str.substr(i + 4, 2), 16);

          var c3 = parseInt(str.substr(i + 7, 2), 16);
          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
        } else {
          newStr += str.substr(i, 9);
        }

        i += 9;
      } else {
        newStr += str.substr(i, 3);
        i += 3;
      }
    }

    return newStr;
  }

  function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }

    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
  }

  function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
  }

  function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
      return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
      return host;
    }
  }

  function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
          last = _address$toLowerCase$2[0],
          first = _address$toLowerCase$2[1];

      var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
      var lastFields = last.split(":").map(_stripLeadingZeros);
      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
      var fieldCount = isLastFieldIPv4Address ? 7 : 8;
      var lastFieldsStart = lastFields.length - fieldCount;
      var fields = Array(fieldCount);

      for (var x = 0; x < fieldCount; ++x) {
        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
      }

      if (isLastFieldIPv4Address) {
        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
      }

      var allZeroFields = fields.reduce(function (acc, field, index) {
        if (!field || field === "0") {
          var lastLongest = acc[acc.length - 1];

          if (lastLongest && lastLongest.index + lastLongest.length === index) {
            lastLongest.length++;
          } else {
            acc.push({
              index: index,
              length: 1
            });
          }
        }

        return acc;
      }, []);
      var longestZeroFields = allZeroFields.sort(function (a, b) {
        return b.length - a.length;
      })[0];
      var newHost = void 0;

      if (longestZeroFields && longestZeroFields.length > 1) {
        var newFirst = fields.slice(0, longestZeroFields.index);
        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
        newHost = newFirst.join(":") + "::" + newLast.join(":");
      } else {
        newHost = fields.join(":");
      }

      if (zone) {
        newHost += "%" + zone;
      }

      return newHost;
    } else {
      return host;
    }
  }

  var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
  var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;

  function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);

    if (matches) {
      if (NO_MATCH_IS_UNDEFINED) {
        //store each component
        components.scheme = matches[1];
        components.userinfo = matches[3];
        components.host = matches[4];
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = matches[7];
        components.fragment = matches[8]; //fix port number

        if (isNaN(components.port)) {
          components.port = matches[5];
        }
      } else {
        //IE FIX for improper RegExp matching
        //store each component
        components.scheme = matches[1] || undefined;
        components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
        components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
        components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined; //fix port number

        if (isNaN(components.port)) {
          components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
        }
      }

      if (components.host) {
        //normalize IP hosts
        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
      } //determine reference type


      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
        components.reference = "same-document";
      } else if (components.scheme === undefined) {
        components.reference = "relative";
      } else if (components.fragment === undefined) {
        components.reference = "absolute";
      } else {
        components.reference = "uri";
      } //check for reference errors


      if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
        components.error = components.error || "URI is not a " + options.reference + " reference.";
      } //find scheme handler


      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //check if scheme can't handle IRIs

      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        //if host component is a domain name
        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
          //convert Unicode IDN -> ASCII IDN
          try {
            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
          }
        } //convert IRI -> URI


        _normalizeComponentEncoding(components, URI_PROTOCOL);
      } else {
        //normalize encodings
        _normalizeComponentEncoding(components, protocol);
      } //perform scheme specific parsing


      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(components, options);
      }
    } else {
      components.error = components.error || "URI can not be parsed.";
    }

    return components;
  }

  function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];

    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }

    if (components.host !== undefined) {
      //normalize IP hosts, add brackets and escape zone separator for IPv6
      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
      }));
    }

    if (typeof components.port === "number") {
      uriTokens.push(":");
      uriTokens.push(components.port.toString(10));
    }

    return uriTokens.length ? uriTokens.join("") : undefined;
  }

  var RDS1 = /^\.\.?\//;
  var RDS2 = /^\/\.(\/|$)/;
  var RDS3 = /^\/\.\.(\/|$)/;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;

  function removeDotSegments(input) {
    var output = [];

    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        var im = input.match(RDS5);

        if (im) {
          var s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }

    return output.join("");
  }

  function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = []; //find scheme handler

    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //perform scheme specific serialization

    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

    if (components.host) {
      //if host component is an IPv6 address
      if (protocol.IPV6ADDRESS.test(components.host)) {} //TODO: normalize IPv6 address as per RFC 5952
      //if host component is a domain name
      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          //convert IDN via punycode
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
    } //normalize encoding


    _normalizeComponentEncoding(components, protocol);

    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }

    var authority = _recomposeAuthority(components, options);

    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }

      uriTokens.push(authority);

      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }

    if (components.path !== undefined) {
      var s = components.path;

      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }

      if (authority === undefined) {
        s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
      }

      uriTokens.push(s);
    }

    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }

    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }

    return uriTokens.join(""); //merge tokens into a string
  }

  function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];
    var target = {};

    if (!skipNormalization) {
      base = parse(serialize(base, options), options); //normalize base components

      relative = parse(serialize(relative, options), options); //normalize relative components
    }

    options = options || {};

    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme; //target.authority = relative.authority;

      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;

          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }

            target.path = removeDotSegments(target.path);
          }

          target.query = relative.query;
        } //target.authority = base.authority;


        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }

      target.scheme = base.scheme;
    }

    target.fragment = relative.fragment;
    return target;
  }

  function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({
      scheme: 'null'
    }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
  }

  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
      uri = parse(serialize(uri, options), options);
    }

    return uri;
  }

  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
      uriA = serialize(uriA, options);
    }

    if (typeof uriB === "string") {
      uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
      uriB = serialize(uriB, options);
    }

    return uriA === uriB;
  }

  function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
  }

  function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
  }

  var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
      //report missing host
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }

      return components;
    },
    serialize: function serialize(components, options) {
      //normalize the default port
      if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
        components.port = undefined;
      } //normalize the empty path


      if (!components.path) {
        components.path = "/";
      } //NOTE: We do not parse query strings for HTTP URIs
      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
      //and not the HTTP spec.


      return components;
    }
  };
  var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
  };
  var O = {};
  var isIRI = true; //RFC 3986

  var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
  var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive

  var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
  //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
  //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
  //const VCHAR$$ = "[\\x21-\\x7E]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
  //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
  //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
  //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');

  var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
  var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
  var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
  var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
  var UNRESERVED = new RegExp(UNRESERVED$$, "g");
  var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
  var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
  var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
  var NOT_HFVALUE = NOT_HFNAME;

  function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
  }

  var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
      var mailtoComponents = components;
      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
      mailtoComponents.path = undefined;

      if (mailtoComponents.query) {
        var unknownHeaders = false;
        var headers = {};
        var hfields = mailtoComponents.query.split("&");

        for (var x = 0, xl = hfields.length; x < xl; ++x) {
          var hfield = hfields[x].split("=");

          switch (hfield[0]) {
            case "to":
              var toAddrs = hfield[1].split(",");

              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                to.push(toAddrs[_x]);
              }

              break;

            case "subject":
              mailtoComponents.subject = unescapeComponent(hfield[1], options);
              break;

            case "body":
              mailtoComponents.body = unescapeComponent(hfield[1], options);
              break;

            default:
              unknownHeaders = true;
              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
              break;
          }
        }

        if (unknownHeaders) mailtoComponents.headers = headers;
      }

      mailtoComponents.query = undefined;

      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
        var addr = to[_x2].split("@");

        addr[0] = unescapeComponent(addr[0]);

        if (!options.unicodeSupport) {
          //convert Unicode IDN -> ASCII IDN
          try {
            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
          } catch (e) {
            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
          }
        } else {
          addr[1] = unescapeComponent(addr[1], options).toLowerCase();
        }

        to[_x2] = addr.join("@");
      }

      return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
      var components = mailtoComponents;
      var to = toArray(mailtoComponents.to);

      if (to) {
        for (var x = 0, xl = to.length; x < xl; ++x) {
          var toAddr = String(to[x]);
          var atIdx = toAddr.lastIndexOf("@");
          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
          var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode

          try {
            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
          } catch (e) {
            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }

          to[x] = localPart + "@" + domain;
        }

        components.path = to.join(",");
      }

      var headers = mailtoComponents.headers = mailtoComponents.headers || {};
      if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
      if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
      var fields = [];

      for (var name in headers) {
        if (headers[name] !== O[name]) {
          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
        }
      }

      if (fields.length) {
        components.query = fields.join("&");
      }

      return components;
    }
  };
  var URN_PARSE = /^([^\:]+)\:(.*)/; //RFC 2141

  var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
      var matches = components.path && components.path.match(URN_PARSE);
      var urnComponents = components;

      if (matches) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = matches[1].toLowerCase();
        var nss = matches[2];
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        urnComponents.nid = nid;
        urnComponents.nss = nss;
        urnComponents.path = undefined;

        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }

      return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
      var scheme = options.scheme || urnComponents.scheme || "urn";
      var nid = urnComponents.nid;
      var urnScheme = scheme + ":" + (options.nid || nid);
      var schemeHandler = SCHEMES[urnScheme];

      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }

      var uriComponents = urnComponents;
      var nss = urnComponents.nss;
      uriComponents.path = (nid || options.nid) + ":" + nss;
      return uriComponents;
    }
  };
  var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/; //RFC 4122

  var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
      var uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = undefined;

      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }

      return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
      var urnComponents = uuidComponents; //normalize UUID

      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
  };
  SCHEMES[handler.scheme] = handler;
  SCHEMES[handler$1.scheme] = handler$1;
  SCHEMES[handler$2.scheme] = handler$2;
  SCHEMES[handler$3.scheme] = handler$3;
  SCHEMES[handler$4.scheme] = handler$4;
  exports.SCHEMES = SCHEMES;
  exports.pctEncChar = pctEncChar;
  exports.pctDecChars = pctDecChars;
  exports.parse = parse;
  exports.removeDotSegments = removeDotSegments;
  exports.serialize = serialize;
  exports.resolveComponents = resolveComponents;
  exports.resolve = resolve;
  exports.normalize = normalize;
  exports.equal = equal;
  exports.escapeComponent = escapeComponent;
  exports.unescapeComponent = unescapeComponent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ 1635:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(2987);
/******/ 	JsonRefs = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7V0FDQTtXQUNBOzs7OztVRUpBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9kZWZpbmUtZGF0YS1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9lcy1kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL2V2YWwuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9yYW5nZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvcmVmLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9zeW50YXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3R5cGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3VyaS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dvcGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9jb21wb25lbnRzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGZzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEtYWxsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2Zsb3lkLXdhcnNoYWxsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvcG9zdG9yZGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvcHJlb3JkZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvdG9wc29ydC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZ3JhcGguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9qc29uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2hhcy1wcm90by9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9oYXNvd24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVNpemUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJbmRleE9mLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nU2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlU2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmlsdGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVW5kZWZpbmVkLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zaXplLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pb24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9teS1wYXRoLWxvYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9teS1wYXRoLWxvYWRlci9saWIvbG9hZGVycy9maWxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbXktcGF0aC1sb2FkZXIvbGliL2xvYWRlcnMvaHR0cC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9teS1wYXRoLWxvYWRlci9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vc3JjL2FnZW50LWJhc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vc3JjL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi9zcmMvcmVxdWVzdC1iYXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4uL3NyYy9yZXNwb25zZS1iYXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9uYXRpdmUtcHJvbWlzZS1vbmx5L2xpYi9ucG8uc3JjLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc2V0LWZ1bmN0aW9uLWxlbmd0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zbGFzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3NjaGVtZXMvdXJuLXV1aWQudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3NjaGVtZXMvdXJuLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9zY2hlbWVzL21haWx0by50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvc2NoZW1lcy9odHRwcy50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvc2NoZW1lcy9odHRwLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy91cmkudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvcmVnZXhwcy1pcmkudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3JlZ2V4cHMtdXJpLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy91dGlsLnRzIiwid2VicGFjazovL0pzb25SZWZzL2lnbm9yZWR8RDpcXEtlbGx5XFx2aWFtZXJpY2FzLXByb2plY3RzXFxqc29uLXJlZnNcXGpzb24tcmVmc1xcbm9kZV9tb2R1bGVzXFxzaWRlLWNoYW5uZWxcXG5vZGVfbW9kdWxlc1xcb2JqZWN0LWluc3BlY3R8Li91dGlsLmluc3BlY3QiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL0pzb25SZWZzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9Kc29uUmVmcy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL0pzb25SZWZzL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9Kc29uUmVmcy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBnbCA9IHJlcXVpcmUoJ2dyYXBobGliJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBQYXRoTG9hZGVyID0gcmVxdWlyZSgnbXktcGF0aC1sb2FkZXInKTtcbnZhciBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG52YXIgc2xhc2ggPSByZXF1aXJlKCdzbGFzaCcpO1xudmFyIFVSSSA9IHJlcXVpcmUoJ3VyaS1qcycpO1xuXG52YXIgYmFkUHRyVG9rZW5SZWdleCA9IC9+KD86W14wMV18JCkvZztcbnZhciByZW1vdGVDYWNoZSA9IHt9O1xudmFyIHJlbW90ZVR5cGVzID0gWydyZWxhdGl2ZScsICdyZW1vdGUnXTtcbnZhciByZW1vdGVVcmlUeXBlcyA9IFsnYWJzb2x1dGUnLCAndXJpJ107XG52YXIgdXJpRGV0YWlsc0NhY2hlID0ge307XG5cbi8vIExvYWQgcHJvbWlzZXMgcG9seWZpbGwgaWYgbmVjZXNzYXJ5XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seScpO1xufVxuXG4vKiBJbnRlcm5hbCBGdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gY29tYmluZVF1ZXJ5UGFyYW1zIChxczEsIHFzMikge1xuICB2YXIgY29tYmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBtZXJnZVF1ZXJ5UGFyYW1zIChvYmopIHtcbiAgICBfLmZvck93bihvYmosIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgY29tYmluZWRba2V5XSA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmdlUXVlcnlQYXJhbXMocXMucGFyc2UocXMxIHx8ICcnKSk7XG4gIG1lcmdlUXVlcnlQYXJhbXMocXMucGFyc2UocXMyIHx8ICcnKSk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbWJpbmVkKS5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBxcy5zdHJpbmdpZnkoY29tYmluZWQpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lVVJJcyAodTEsIHUyKSB7XG4gIC8vIENvbnZlcnQgV2luZG93cyBwYXRoc1xuICBpZiAoXy5pc1N0cmluZyh1MSkpIHtcbiAgICB1MSA9IHNsYXNoKHUxKTtcbiAgfVxuXG4gIGlmIChfLmlzU3RyaW5nKHUyKSkge1xuICAgIHUyID0gc2xhc2godTIpO1xuICB9XG5cbiAgdmFyIHUyRGV0YWlscyA9IHBhcnNlVVJJKF8uaXNVbmRlZmluZWQodTIpID8gJycgOiB1Mik7XG4gIHZhciB1MURldGFpbHM7XG4gIHZhciBjb21iaW5lZERldGFpbHM7XG5cbiAgaWYgKHJlbW90ZVVyaVR5cGVzLmluZGV4T2YodTJEZXRhaWxzLnJlZmVyZW5jZSkgPiAtMSkge1xuICAgIGNvbWJpbmVkRGV0YWlscyA9IHUyRGV0YWlscztcbiAgfSBlbHNlIHtcbiAgICB1MURldGFpbHMgPSBfLmlzVW5kZWZpbmVkKHUxKSA/IHVuZGVmaW5lZCA6IHBhcnNlVVJJKHUxKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh1MURldGFpbHMpKSB7XG4gICAgICBjb21iaW5lZERldGFpbHMgPSB1MURldGFpbHM7XG5cbiAgICAgIC8vIEpvaW4gdGhlIHBhdGhzXG4gICAgICBjb21iaW5lZERldGFpbHMucGF0aCA9IHNsYXNoKHBhdGguam9pbih1MURldGFpbHMucGF0aCwgdTJEZXRhaWxzLnBhdGgpKTtcblxuICAgICAgLy8gSm9pbiBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICBjb21iaW5lZERldGFpbHMucXVlcnkgPSBjb21iaW5lUXVlcnlQYXJhbXModTFEZXRhaWxzLnF1ZXJ5LCB1MkRldGFpbHMucXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iaW5lZERldGFpbHMgPSB1MkRldGFpbHM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBmcmFnbWVudFxuICBjb21iaW5lZERldGFpbHMuZnJhZ21lbnQgPSB1bmRlZmluZWQ7XG5cbiAgLy8gRm9yIHJlbGF0aXZlIFVSSXMsIGFkZCBiYWNrIHRoZSAnLi4nIHNpbmNlIGl0IHdhcyByZW1vdmVkIGFib3ZlXG4gIHJldHVybiAocmVtb3RlVXJpVHlwZXMuaW5kZXhPZihjb21iaW5lZERldGFpbHMucmVmZXJlbmNlKSA9PT0gLTEgJiZcbiAgICAgICAgICBjb21iaW5lZERldGFpbHMucGF0aC5pbmRleE9mKCcuLi8nKSA9PT0gMCA/ICcuLi8nIDogJycpICsgVVJJLnNlcmlhbGl6ZShjb21iaW5lZERldGFpbHMpO1xufVxuXG5mdW5jdGlvbiBmaW5kQW5jZXN0b3JzIChvYmosIHBhdGgpIHtcbiAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICB2YXIgbm9kZTtcblxuICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgbm9kZSA9IG9iajtcblxuICAgIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgIGlmIChzZWcgaW4gbm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZVtzZWddO1xuXG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gaXNSZW1vdGUgKHJlZkRldGFpbHMpIHtcbiAgcmV0dXJuIHJlbW90ZVR5cGVzLmluZGV4T2YoZ2V0UmVmVHlwZShyZWZEZXRhaWxzKSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCAocmVmRGV0YWlscykge1xuICByZXR1cm4gXy5pc1VuZGVmaW5lZChyZWZEZXRhaWxzLmVycm9yKSAmJiByZWZEZXRhaWxzLnR5cGUgIT09ICdpbnZhbGlkJztcbn1cblxuZnVuY3Rpb24gZmluZFZhbHVlIChvYmosIHBhdGgpIHtcbiAgdmFyIHZhbHVlID0gb2JqO1xuXG4gIC8vIFVzaW5nIHRoaXMgbWFudWFsIGFwcHJvYWNoIGluc3RlYWQgb2YgXy5nZXQgc2luY2Ugd2UgaGF2ZSB0byBkZWNvZGVVUkkgdGhlIHNlZ21lbnRzXG4gIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgaWYgKHNlZyBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtzZWddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignSlNPTiBQb2ludGVyIHBvaW50cyB0byBtaXNzaW5nIGxvY2F0aW9uOiAnICsgcGF0aFRvUHRyKHBhdGgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXh0cmFSZWZLZXlzIChyZWYpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5ICE9PSAnJHJlZic7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSZWZUeXBlIChyZWZEZXRhaWxzKSB7XG4gIHZhciB0eXBlO1xuXG4gIC8vIENvbnZlcnQgdGhlIFVSSSByZWZlcmVuY2UgdG8gb25lIG9mIG91ciB0eXBlc1xuICBzd2l0Y2ggKHJlZkRldGFpbHMudXJpRGV0YWlscy5yZWZlcmVuY2UpIHtcbiAgY2FzZSAnYWJzb2x1dGUnOlxuICBjYXNlICd1cmknOlxuICAgIHR5cGUgPSAncmVtb3RlJztcbiAgICBicmVhaztcbiAgY2FzZSAnc2FtZS1kb2N1bWVudCc6XG4gICAgdHlwZSA9ICdsb2NhbCc7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdHlwZSA9IHJlZkRldGFpbHMudXJpRGV0YWlscy5yZWZlcmVuY2U7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtb3RlRG9jdW1lbnQgKHVybCwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVFbnRyeSA9IHJlbW90ZUNhY2hlW3VybF07XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB2YXIgbG9hZGVyT3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMubG9hZGVyT3B0aW9ucyB8fCB7fSk7XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQoY2FjaGVFbnRyeSkpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBjb250ZW50IHByb2Nlc3NvciwgZGVmYXVsdCB0byBwcm9jZXNzaW5nIHRoZSByYXcgcmVzcG9uc2UgYXMgSlNPTlxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGxvYWRlck9wdGlvbnMucHJvY2Vzc0NvbnRlbnQpKSB7XG4gICAgICBsb2FkZXJPcHRpb25zLnByb2Nlc3NDb250ZW50ID0gZnVuY3Rpb24gKHJlcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBKU09OLnBhcnNlKHJlcy50ZXh0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgcmVzb3VyY2UgdXNpbmcgcGF0aC1sb2FkZXJcbiAgICBhbGxUYXNrcyA9IFBhdGhMb2FkZXIubG9hZChkZWNvZGVVUkkodXJsKSwgbG9hZGVyT3B0aW9ucyk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGNhY2hlXG4gICAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICByZW1vdGVDYWNoZVt1cmxdID0ge1xuICAgICAgICAgIHZhbHVlOiByZXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJlbW90ZUNhY2hlW3VybF0gPSB7XG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9O1xuXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFJldHVybiB0aGUgY2FjaGVkIHZlcnNpb25cbiAgICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF8uaXNFcnJvcihjYWNoZUVudHJ5LmVycm9yKSkge1xuICAgICAgICB0aHJvdyBjYWNoZUVudHJ5LmVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBjbG9uZWQgdmVyc2lvbiB0byBhdm9pZCB1cGRhdGluZyB0aGUgY2FjaGVcbiAgYWxsVGFza3MgPSBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICByZXR1cm4gXy5jbG9uZURlZXAocmVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG5mdW5jdGlvbiBpc1JlZkxpa2UgKG9iaiwgdGhyb3dXaXRoRGV0YWlscykge1xuICB2YXIgcmVmTGlrZSA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iaiBpcyBub3QgYW4gT2JqZWN0Jyk7XG4gICAgfSBlbHNlIGlmICghXy5pc1N0cmluZyhvYmouJHJlZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb2JqLiRyZWYgaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhyb3dXaXRoRGV0YWlscykge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHJlZkxpa2UgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZWZMaWtlO1xufVxuXG5mdW5jdGlvbiBtYWtlQWJzb2x1dGUgKGxvY2F0aW9uKSB7XG4gIGlmIChsb2NhdGlvbi5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgJiYgIXBhdGguaXNBYnNvbHV0ZShsb2NhdGlvbikpIHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIGxvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVJlZkZpbHRlciAob3B0aW9ucykge1xuICB2YXIgcmVmRmlsdGVyO1xuICB2YXIgdmFsaWRUeXBlcztcblxuICBpZiAoXy5pc0FycmF5KG9wdGlvbnMuZmlsdGVyKSB8fCBfLmlzU3RyaW5nKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIHZhbGlkVHlwZXMgPSBfLmlzU3RyaW5nKG9wdGlvbnMuZmlsdGVyKSA/IFtvcHRpb25zLmZpbHRlcl0gOiBvcHRpb25zLmZpbHRlcjtcbiAgICByZWZGaWx0ZXIgPSBmdW5jdGlvbiAocmVmRGV0YWlscykge1xuICAgICAgLy8gQ2hlY2sgdGhlIGV4YWN0IHR5cGUgb3IgZm9yIGludmFsaWQgVVJJcywgY2hlY2sgaXRzIG9yaWdpbmFsIHR5cGVcbiAgICAgIHJldHVybiB2YWxpZFR5cGVzLmluZGV4T2YocmVmRGV0YWlscy50eXBlKSA+IC0xIHx8IHZhbGlkVHlwZXMuaW5kZXhPZihnZXRSZWZUeXBlKHJlZkRldGFpbHMpKSA+IC0xO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIHJlZkZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICB9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgcmVmRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocmVmRGV0YWlscywgcGF0aCkge1xuICAgIHJldHVybiAocmVmRGV0YWlscy50eXBlICE9PSAnaW52YWxpZCcgfHwgb3B0aW9ucy5pbmNsdWRlSW52YWxpZCA9PT0gdHJ1ZSkgJiYgcmVmRmlsdGVyKHJlZkRldGFpbHMsIHBhdGgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlU3ViRG9jUGF0aCAob3B0aW9ucykge1xuICB2YXIgc3ViRG9jUGF0aDtcblxuICBpZiAoXy5pc0FycmF5KG9wdGlvbnMuc3ViRG9jUGF0aCkpIHtcbiAgICBzdWJEb2NQYXRoID0gb3B0aW9ucy5zdWJEb2NQYXRoO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIHN1YkRvY1BhdGggPSBwYXRoRnJvbVB0cihvcHRpb25zLnN1YkRvY1BhdGgpO1xuICB9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIHN1YkRvY1BhdGggPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzdWJEb2NQYXRoO1xufVxuXG5mdW5jdGlvbiBtYXJrTWlzc2luZyAocmVmRGV0YWlscywgZXJyKSB7XG4gIHJlZkRldGFpbHMuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgcmVmRGV0YWlscy5taXNzaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkkgKHVyaSkge1xuICAvLyBXZSBkZWNvZGUgZmlyc3QgdG8gYXZvaWQgZG91Ymx5IGVuY29kaW5nXG4gIHJldHVybiBVUkkucGFyc2UodXJpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWZNb2RlbCAoZG9jdW1lbnQsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB2YXIgc3ViRG9jUHRyID0gcGF0aFRvUHRyKG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gIHZhciBhYnNMb2NhdGlvbiA9IG1ha2VBYnNvbHV0ZShvcHRpb25zLmxvY2F0aW9uKTtcbiAgdmFyIHJlbGF0aXZlQmFzZSA9IHBhdGguZGlybmFtZShvcHRpb25zLmxvY2F0aW9uKTtcbiAgdmFyIGRvY0RlcEtleSA9IGFic0xvY2F0aW9uICsgc3ViRG9jUHRyO1xuICB2YXIgcmVmcztcbiAgdmFyIHJPcHRpb25zO1xuXG4gIC8vIFN0b3JlIHRoZSBkb2N1bWVudCBpbiB0aGUgbWV0YWRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmIChfLmlzVW5kZWZpbmVkKG1ldGFkYXRhLmRvY3NbYWJzTG9jYXRpb25dKSkge1xuICAgIG1ldGFkYXRhLmRvY3NbYWJzTG9jYXRpb25dID0gZG9jdW1lbnQ7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVwZW5kZW5jaWVzIHN0b3JlZCBmb3IgdGhlIGxvY2F0aW9uK3N1YkRvY1BhdGgsIHdlJ3ZlIG5ldmVyIHNlZW4gaXQgYmVmb3JlIGFuZCB3aWxsIHByb2Nlc3MgaXRcbiAgaWYgKF8uaXNVbmRlZmluZWQobWV0YWRhdGEuZGVwc1tkb2NEZXBLZXldKSkge1xuICAgIG1ldGFkYXRhLmRlcHNbZG9jRGVwS2V5XSA9IHt9O1xuXG4gICAgLy8gRmluZCB0aGUgcmVmZXJlbmNlcyBiYXNlZCBvbiB0aGUgb3B0aW9uc1xuICAgIHJlZnMgPSBmaW5kUmVmcyhkb2N1bWVudCwgb3B0aW9ucyk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHJlZmVyZW5jZXMgYW5kIHByb2Nlc3NcbiAgICBfLmZvck93bihyZWZzLCBmdW5jdGlvbiAocmVmRGV0YWlscywgcmVmUHRyKSB7XG4gICAgICB2YXIgcmVmS2V5ID0gbWFrZUFic29sdXRlKG9wdGlvbnMubG9jYXRpb24pICsgcmVmUHRyO1xuICAgICAgdmFyIHJlZmRLZXkgPSByZWZEZXRhaWxzLnJlZmRJZCA9IGRlY29kZVVSSUNvbXBvbmVudChtYWtlQWJzb2x1dGUoaXNSZW1vdGUocmVmRGV0YWlscykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVVUklzKHJlbGF0aXZlQmFzZSwgcmVmRGV0YWlscy51cmkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2F0aW9uKSArICcjJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmRGV0YWlscy51cmkuaW5kZXhPZignIycpID4gLTEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmRGV0YWlscy51cmkuc3BsaXQoJyMnKVsxXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJykpO1xuXG4gICAgICAvLyBSZWNvcmQgcmVmZXJlbmNlIG1ldGFkYXRhXG4gICAgICBtZXRhZGF0YS5yZWZzW3JlZktleV0gPSByZWZEZXRhaWxzO1xuXG4gICAgICAvLyBEbyBub3QgcHJvY2VzcyBpbnZhbGlkIHJlZmVyZW5jZXNcbiAgICAgIGlmICghaXNWYWxpZChyZWZEZXRhaWxzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlY29yZCB0aGUgZnVsbHktcXVhbGlmaWVkIFVSSVxuICAgICAgcmVmRGV0YWlscy5mcVVSSSA9IHJlZmRLZXk7XG5cbiAgICAgIC8vIFJlY29yZCBkZXBlbmRlbmN5IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyBzdWItZG9jdW1lbnQgcGF0aClcbiAgICAgIG1ldGFkYXRhLmRlcHNbZG9jRGVwS2V5XVtyZWZQdHIgPT09IHN1YkRvY1B0ciA/ICcjJyA6IHJlZlB0ci5yZXBsYWNlKHN1YkRvY1B0ciArICcvJywgJyMvJyldID0gcmVmZEtleTtcblxuICAgICAgLy8gRG8gbm90IHByb2Nlc3MgZGlyZWN0bHktY2lyY3VsYXIgcmVmZXJlbmNlcyAodG8gYW4gYW5jZXN0b3Igb3Igc2VsZilcbiAgICAgIGlmIChyZWZLZXkuaW5kZXhPZihyZWZkS2V5ICsgJy8nKSA9PT0gMCB8fCByZWZLZXkgPT09IHJlZmRLZXkpIHtcbiAgICAgICAgcmVmRGV0YWlscy5jaXJjdWxhciA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSBvcHRpb25zIGZvciBzdWJzZXF1ZW50IHByb2Nlc3NEb2N1bWVudCBjYWxsc1xuICAgICAgck9wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zKTtcblxuICAgICAgck9wdGlvbnMuc3ViRG9jUGF0aCA9IF8uaXNVbmRlZmluZWQocmVmRGV0YWlscy51cmlEZXRhaWxzLmZyYWdtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhGcm9tUHRyKGRlY29kZVVSSUNvbXBvbmVudChyZWZEZXRhaWxzLnVyaURldGFpbHMuZnJhZ21lbnQpKTtcblxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVmZXJlbmNlXG4gICAgICBpZiAoaXNSZW1vdGUocmVmRGV0YWlscykpIHtcbiAgICAgICAgLy8gRGVsZXRlIGZpbHRlci5vcHRpb25zIGJlY2F1c2UgYWxsIHJlbW90ZSByZWZlcmVuY2VzIHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxuICAgICAgICBkZWxldGUgck9wdGlvbnMuZmlsdGVyO1xuICAgICAgICAvLyBUaGUgbmV3IGxvY2F0aW9uIGJlaW5nIHJlZmVyZW5jZWRcbiAgICAgICAgck9wdGlvbnMubG9jYXRpb24gPSByZWZkS2V5LnNwbGl0KCcjJylbMF07XG5cbiAgICAgICAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChuTWV0YWRhdGEsIG5PcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgckFic0xvY2F0aW9uID0gbWFrZUFic29sdXRlKG5PcHRpb25zLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgdmFyIHJEb2MgPSBuTWV0YWRhdGEuZG9jc1tyQWJzTG9jYXRpb25dO1xuXG4gICAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHJEb2MpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBubyBjYWNoZSBzbyB3ZSBtdXN0IHJldHJpZXZlIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZW1vdGVEb2N1bWVudChyQWJzTG9jYXRpb24sIG5PcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHJlc3BvbnNlIGluIHRoZSBkb2N1bWVudCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuTWV0YWRhdGEuZG9jc1tyQWJzTG9jYXRpb25dID0gZXJyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZXJyb3IgdG8gYWxsb3cgdGhlIHN1YnNlcXVlbnQgYHRoZW5gIHRvIGhhbmRsZSBib3RoIGVycm9ycyBhbmQgc3VjY2Vzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcmV0cmlldmVkIChvciBhdHRlbXB0ZWQgdG8pIHRoZSBkb2N1bWVudCBhbmQgc2hvdWxkIHVzZSB0aGUgY2FjaGVkIHZlcnNpb24gaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gbWV0YWRhdGEgc2luY2UgaXQgY291bGQgYWxyZWFkeSBiZSBwcm9jZXNzZWQgc29tZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJEb2M7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KG1ldGFkYXRhLCByT3B0aW9ucykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJvY2VzcyB0aGUgcmVtb3RlIGRvY3VtZW50IG9yIHRoZSByZWZlcmVuY2VkIHBvcnRpb24gb2YgdGhlIGxvY2FsIGRvY3VtZW50XG4gICAgICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChuTWV0YWRhdGEsIG5PcHRpb25zLCBuUmVmRGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0Vycm9yKGRvYykpIHtcbiAgICAgICAgICAgICAgbWFya01pc3NpbmcoblJlZkRldGFpbHMsIGRvYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXcmFwcGVkIGluIGEgdHJ5L2NhdGNoIHNpbmNlIGZpbmRSZWZzIHRocm93c1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFJlZk1vZGVsKGRvYywgbk9wdGlvbnMsIG5NZXRhZGF0YSlcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtNaXNzaW5nKG5SZWZEZXRhaWxzLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG1hcmtNaXNzaW5nKG5SZWZEZXRhaWxzLCBlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfShtZXRhZGF0YSwgck9wdGlvbnMsIHJlZkRldGFpbHMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWUgKG9iaiwgcmVmUGF0aCwgdmFsdWUpIHtcbiAgZmluZFZhbHVlKG9iaiwgcmVmUGF0aC5zbGljZSgwLCByZWZQYXRoLmxlbmd0aCAtIDEpKVtyZWZQYXRoW3JlZlBhdGgubGVuZ3RoIC0gMV1dID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHdhbGsgKGFuY2VzdG9ycywgbm9kZSwgcGF0aCwgZm4pIHtcbiAgdmFyIHByb2Nlc3NDaGlsZHJlbiA9IHRydWU7XG5cbiAgZnVuY3Rpb24gd2Fsa0l0ZW0gKGl0ZW0sIHNlZ21lbnQpIHtcbiAgICBwYXRoLnB1c2goc2VnbWVudCk7XG4gICAgd2FsayhhbmNlc3RvcnMsIGl0ZW0sIHBhdGgsIGZuKTtcbiAgICBwYXRoLnBvcCgpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgaXRlcmF0ZWVcbiAgaWYgKF8uaXNGdW5jdGlvbihmbikpIHtcbiAgICBwcm9jZXNzQ2hpbGRyZW4gPSBmbihhbmNlc3RvcnMsIG5vZGUsIHBhdGgpO1xuICB9XG5cbiAgLy8gV2UgZG8gbm90IHByb2Nlc3MgY2lyY3VsYXIgb2JqZWN0cyBhZ2FpblxuICBpZiAoYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPT09IC0xKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG5cbiAgICBpZiAocHJvY2Vzc0NoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKF8uaXNBcnJheShub2RlKSkge1xuICAgICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlciwgaW5kZXgpIHtcbiAgICAgICAgICB3YWxrSXRlbShtZW1iZXIsIGluZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChub2RlKSkge1xuICAgICAgICBfLmZvck93bihub2RlLCBmdW5jdGlvbiAoY05vZGUsIGtleSkge1xuICAgICAgICAgIHdhbGtJdGVtKGNOb2RlLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbmNlc3RvcnMucG9wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zIChvcHRpb25zLCBvYmopIHtcbiAgdmFyIGxvY2F0aW9uUGFydHM7XG4gIHZhciBzaG91bGREZWNvZGU7XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAvLyBEZWZhdWx0IHRvIGFuIGVtcHR5IG9wdGlvbnMgb2JqZWN0XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIHRoZSBvcHRpb25zIHNvIHdlIGRvIG5vdCBhbHRlciB0aGUgb25lcyBwYXNzZWQgaW5cbiAgICBvcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIV8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5yZXNvbHZlQ2lyY3VsYXJzKSAmJlxuICAgICAgICAgICAgICFfLmlzQm9vbGVhbihvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5yZXNvbHZlQ2lyY3VsYXJzIG11c3QgYmUgYSBCb29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5maWx0ZXIpICYmXG4gICAgICAgICAgICAgIV8uaXNBcnJheShvcHRpb25zLmZpbHRlcikgJiZcbiAgICAgICAgICAgICAhXy5pc0Z1bmN0aW9uKG9wdGlvbnMuZmlsdGVyKSAmJlxuICAgICAgICAgICAgICFfLmlzU3RyaW5nKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZmlsdGVyIG11c3QgYmUgYW4gQXJyYXksIGEgRnVuY3Rpb24gb2YgYSBTdHJpbmcnKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmluY2x1ZGVJbnZhbGlkKSAmJlxuICAgICAgICAgICAgICFfLmlzQm9vbGVhbihvcHRpb25zLmluY2x1ZGVJbnZhbGlkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuaW5jbHVkZUludmFsaWQgbXVzdCBiZSBhIEJvb2xlYW4nKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmxvY2F0aW9uKSAmJlxuICAgICAgICAgICAgICFfLmlzU3RyaW5nKG9wdGlvbnMubG9jYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5sb2NhdGlvbiBtdXN0IGJlIGEgU3RyaW5nJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IpICYmXG4gICAgICAgICAgICAgIV8uaXNGdW5jdGlvbihvcHRpb25zLnJlZlByZVByb2Nlc3NvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnJlZlByZVByb2Nlc3NvciBtdXN0IGJlIGEgRnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IpICYmXG4gICAgICAgICAgICAgIV8uaXNGdW5jdGlvbihvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5yZWZQb3N0UHJvY2Vzc29yIG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMuc3ViRG9jUGF0aCkgJiZcbiAgICAgICAgICAgICAhXy5pc0FycmF5KG9wdGlvbnMuc3ViRG9jUGF0aCkgJiZcbiAgICAgICAgICAgICAhaXNQdHIob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIC8vIElmIGEgcG9pbnRlciBpcyBwcm92aWRlZCwgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QgdGhlIHByb3BlciB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5zdWJEb2NQYXRoIG11c3QgYmUgYW4gQXJyYXkgb2YgcGF0aCBzZWdtZW50cyBvciBhIHZhbGlkIEpTT04gUG9pbnRlcicpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBmYWxzZSBmb3IgYWxsb3dpbmcgY2lyY3VsYXJzXG4gIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVzb2x2ZUNpcmN1bGFycykpIHtcbiAgICBvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMgPSBmYWxzZTtcbiAgfVxuXG4gIG9wdGlvbnMuZmlsdGVyID0gbWFrZVJlZkZpbHRlcihvcHRpb25zKTtcblxuICAvLyBvcHRpb25zLmxvY2F0aW9uIGlzIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZCB5ZXQgYnV0IHdpbGwgYmUgd2hlbiBJc3N1ZSA4OCBpcyBjb21wbGV0ZVxuICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zLmxvY2F0aW9uKSkge1xuICAgIG9wdGlvbnMubG9jYXRpb24gPSBtYWtlQWJzb2x1dGUoJy4vcm9vdC5qc29uJyk7XG4gIH1cblxuICBsb2NhdGlvblBhcnRzID0gb3B0aW9ucy5sb2NhdGlvbi5zcGxpdCgnIycpO1xuXG4gIC8vIElmIG9wdGlvbnMubG9jYXRpb24gY29udGFpbnMgYSBmcmFnbWVudCwgdHVybiBpdCBpbnRvIGFuIG9wdGlvbnMuc3ViRG9jUGF0aFxuICBpZiAobG9jYXRpb25QYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgb3B0aW9ucy5zdWJEb2NQYXRoID0gJyMnICsgbG9jYXRpb25QYXJ0c1sxXTtcbiAgfVxuXG4gIHNob3VsZERlY29kZSA9IGRlY29kZVVSSShvcHRpb25zLmxvY2F0aW9uKSA9PT0gb3B0aW9ucy5sb2NhdGlvbjtcblxuICAvLyBKdXN0IHRvIGJlIHNhZmUsIHJlbW92ZSBhbnkgYWNjaWRlbnRhbCBmcmFnbWVudCBhcyBpdCB3b3VsZCBicmVhayB0aGluZ3NcbiAgb3B0aW9ucy5sb2NhdGlvbiA9IGNvbWJpbmVVUklzKG9wdGlvbnMubG9jYXRpb24sIHVuZGVmaW5lZCk7XG5cbiAgLy8gSWYgdGhlIGxvY2F0aW9uIHdhcyBub3QgZW5jb2RlZCwgbWVrZSBzdXJlIGl0J3Mgbm90IHdoZW4gd2UgZ2V0IGl0IGJhY2sgKElzc3VlICMxMzgpXG4gIGlmIChzaG91bGREZWNvZGUpIHtcbiAgICBvcHRpb25zLmxvY2F0aW9uID0gZGVjb2RlVVJJKG9wdGlvbnMubG9jYXRpb24pO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBzdWJEb2NQYXRoIHRvIGF2b2lkIGV2ZXJ5b25lIGVsc2UgaGF2aW5nIHRvIGNvbXB1dGUgaXRcbiAgb3B0aW9ucy5zdWJEb2NQYXRoID0gbWFrZVN1YkRvY1BhdGgob3B0aW9ucyk7XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICB0cnkge1xuICAgICAgZmluZFZhbHVlKG9iaiwgb3B0aW9ucy5zdWJEb2NQYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnSlNPTiBQb2ludGVyJywgJ29wdGlvbnMuc3ViRG9jUGF0aCcpO1xuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVBhdGggKHBhdGgpIHtcbiAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHNlZykpIHtcbiAgICAgIHNlZyA9IEpTT04uc3RyaW5naWZ5KHNlZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZy5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVQYXRoIChwYXRoKSB7XG4gIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgIGlmICghXy5pc1N0cmluZyhzZWcpKSB7XG4gICAgICBzZWcgPSBKU09OLnN0cmluZ2lmeShzZWcpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWcucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kUmVmcyAob2JqLCBvcHRpb25zKSB7XG4gIHZhciByZWZzID0ge307XG5cbiAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gIGlmICghXy5pc0FycmF5KG9iaikgJiYgIV8uaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iaiBtdXN0IGJlIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIG9iaik7XG5cbiAgLy8gV2FsayB0aGUgZG9jdW1lbnQgKG9yIHN1YiBkb2N1bWVudCkgYW5kIGZpbmQgYWxsIEpTT04gUmVmZXJlbmNlc1xuICB3YWxrKGZpbmRBbmNlc3RvcnMob2JqLCBvcHRpb25zLnN1YkRvY1BhdGgpLFxuICAgICAgIGZpbmRWYWx1ZShvYmosIG9wdGlvbnMuc3ViRG9jUGF0aCksXG4gICAgICAgXy5jbG9uZURlZXAob3B0aW9ucy5zdWJEb2NQYXRoKSxcbiAgICAgICBmdW5jdGlvbiAoYW5jZXN0b3JzLCBub2RlLCBwYXRoKSB7XG4gICAgICAgICB2YXIgcHJvY2Vzc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgIHZhciByZWZEZXRhaWxzO1xuICAgICAgICAgdmFyIHJlZlB0cjtcblxuICAgICAgICAgaWYgKGlzUmVmTGlrZShub2RlKSkge1xuICAgICAgICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgbm9kZSB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgbm9kZSA9IG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yKF8uY2xvbmVEZWVwKG5vZGUpLCBwYXRoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHJlZkRldGFpbHMgPSBnZXRSZWZEZXRhaWxzKG5vZGUpO1xuXG4gICAgICAgICAgIC8vIFBvc3QtcHJvY2VzcyB0aGUgcmVmZXJlbmNlIGRldGFpbHNcbiAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvcikpIHtcbiAgICAgICAgICAgICByZWZEZXRhaWxzID0gb3B0aW9ucy5yZWZQb3N0UHJvY2Vzc29yKHJlZkRldGFpbHMsIHBhdGgpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyKHJlZkRldGFpbHMsIHBhdGgpKSB7XG4gICAgICAgICAgICAgcmVmUHRyID0gcGF0aFRvUHRyKHBhdGgpO1xuXG4gICAgICAgICAgICAgcmVmc1tyZWZQdHJdID0gcmVmRGV0YWlscztcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFdoZW5ldmVyIGEgSlNPTiBSZWZlcmVuY2UgaGFzIGV4dHJhIGNoaWxkcmVuLCBpdHMgY2hpbGRyZW4gc2hvdWxkIG5vdCBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAgIC8vICAgU2VlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYnJ5YW4tenlwLWpzb24tcmVmLTAzI3NlY3Rpb24tM1xuICAgICAgICAgICBpZiAoZ2V0RXh0cmFSZWZLZXlzKG5vZGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICBwcm9jZXNzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkcmVuO1xuICAgICAgIH0pO1xuXG4gIHJldHVybiByZWZzO1xufVxuXG5mdW5jdGlvbiBmaW5kUmVmc0F0IChsb2NhdGlvbiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGxvY2F0aW9uXG4gICAgICBpZiAoIV8uaXNTdHJpbmcobG9jYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xvY2F0aW9uIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAvLyBBZGQgdGhlIGxvY2F0aW9uIHRvIHRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nL3ZhbGlkYXRpb25cbiAgICAgICAgb3B0aW9ucy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gZ2V0UmVtb3RlRG9jdW1lbnQob3B0aW9ucy5sb2NhdGlvbiwgb3B0aW9ucyk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IF8uY2xvbmVEZWVwKHJlbW90ZUNhY2hlW29wdGlvbnMubG9jYXRpb25dKTtcbiAgICAgIHZhciBjT3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMpO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChjYWNoZUVudHJ5LnJlZnMpKSB7XG4gICAgICAgIC8vIERvIG5vdCBmaWx0ZXIgYW55IHJlZmVyZW5jZXMgc28gdGhlIGNhY2hlIGlzIGNvbXBsZXRlXG4gICAgICAgIGRlbGV0ZSBjT3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIGRlbGV0ZSBjT3B0aW9ucy5zdWJEb2NQYXRoO1xuXG4gICAgICAgIGNPcHRpb25zLmluY2x1ZGVJbnZhbGlkID0gdHJ1ZTtcblxuICAgICAgICByZW1vdGVDYWNoZVtvcHRpb25zLmxvY2F0aW9uXS5yZWZzID0gZmluZFJlZnMocmVzLCBjT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgZmlsdGVyIG9wdGlvbnMgYmFja1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBjT3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyB3aWxsIHVzZSB0aGUgY2FjaGUgc28gZG9uJ3Qgd29ycnkgYWJvdXQgY2FsbGluZyBpdCB0d2ljZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmczogZmluZFJlZnMocmVzLCBjT3B0aW9ucyksXG4gICAgICAgIHZhbHVlOiByZXNcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG5mdW5jdGlvbiBnZXRSZWZEZXRhaWxzIChvYmopIHtcbiAgdmFyIGRldGFpbHMgPSB7XG4gICAgZGVmOiBvYmpcbiAgfTtcbiAgdmFyIGNhY2hlS2V5O1xuICB2YXIgZXh0cmFLZXlzO1xuICB2YXIgdXJpRGV0YWlscztcblxuICB0cnkge1xuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBzbyB0aGUgcmVzdWx0IGRvZXNuJ3QgbWF0dGVyXG4gICAgaXNSZWZMaWtlKG9iaiwgdHJ1ZSk7XG5cbiAgICBjYWNoZUtleSA9IG9iai4kcmVmO1xuICAgIHVyaURldGFpbHMgPSB1cmlEZXRhaWxzQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodXJpRGV0YWlscykpIHtcbiAgICAgIHVyaURldGFpbHMgPSB1cmlEZXRhaWxzQ2FjaGVbY2FjaGVLZXldID0gcGFyc2VVUkkoY2FjaGVLZXkpO1xuICAgIH1cblxuICAgIGRldGFpbHMudXJpID0gY2FjaGVLZXk7XG4gICAgZGV0YWlscy51cmlEZXRhaWxzID0gdXJpRGV0YWlscztcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHVyaURldGFpbHMuZXJyb3IpKSB7XG4gICAgICBkZXRhaWxzLnR5cGUgPSBnZXRSZWZUeXBlKGRldGFpbHMpO1xuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgSlNPTiBQb2ludGVyXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoWycjJywgJy8nXS5pbmRleE9mKGNhY2hlS2V5WzBdKSA+IC0xKSB7XG4gICAgICAgICAgaXNQdHIoY2FjaGVLZXksIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhY2hlS2V5LmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgaXNQdHIodXJpRGV0YWlscy5mcmFnbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZXRhaWxzLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIGRldGFpbHMudHlwZSA9ICdpbnZhbGlkJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWlscy5lcnJvciA9IGRldGFpbHMudXJpRGV0YWlscy5lcnJvcjtcbiAgICAgIGRldGFpbHMudHlwZSA9ICdpbnZhbGlkJztcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmeSB3YXJuaW5nXG4gICAgZXh0cmFLZXlzID0gZ2V0RXh0cmFSZWZLZXlzKG9iaik7XG5cbiAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRldGFpbHMud2FybmluZyA9ICdFeHRyYSBKU09OIFJlZmVyZW5jZSBwcm9wZXJ0aWVzIHdpbGwgYmUgaWdub3JlZDogJyArIGV4dHJhS2V5cy5qb2luKCcsICcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGV0YWlscy5lcnJvciA9IGVyci5tZXNzYWdlO1xuICAgIGRldGFpbHMudHlwZSA9ICdpbnZhbGlkJztcbiAgfVxuXG4gIHJldHVybiBkZXRhaWxzO1xufVxuXG5mdW5jdGlvbiBpc1B0ciAocHRyLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBmaXJzdENoYXI7XG5cbiAgdHJ5IHtcbiAgICBpZiAoXy5pc1N0cmluZyhwdHIpKSB7XG4gICAgICBpZiAocHRyICE9PSAnJykge1xuICAgICAgICBmaXJzdENoYXIgPSBwdHIuY2hhckF0KDApO1xuXG4gICAgICAgIGlmIChbJyMnLCAnLyddLmluZGV4T2YoZmlyc3RDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBtdXN0IHN0YXJ0IHdpdGggYSAvIG9yICMvJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSAnIycgJiYgcHRyICE9PSAnIycgJiYgcHRyLmNoYXJBdCgxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBzdGFydCB3aXRoIGEgLyBvciAjLycpO1xuICAgICAgICB9IGVsc2UgaWYgKHB0ci5tYXRjaChiYWRQdHJUb2tlblJlZ2V4KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHRyIGhhcyBpbnZhbGlkIHRva2VuKHMpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhyb3dXaXRoRGV0YWlscyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVmIChvYmosIHRocm93V2l0aERldGFpbHMpIHtcbiAgcmV0dXJuIGlzUmVmTGlrZShvYmosIHRocm93V2l0aERldGFpbHMpICYmIGdldFJlZkRldGFpbHMob2JqKS50eXBlICE9PSAnaW52YWxpZCc7XG59XG5cbmZ1bmN0aW9uIHBhdGhGcm9tUHRyIChwdHIpIHtcbiAgdHJ5IHtcbiAgICBpc1B0cihwdHIsIHRydWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBtdXN0IGJlIGEgSlNPTiBQb2ludGVyOiAnICsgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gcHRyLnNwbGl0KCcvJyk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBzZWdtZW50XG4gIHNlZ21lbnRzLnNoaWZ0KCk7XG5cbiAgcmV0dXJuIGRlY29kZVBhdGgoc2VnbWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXRoVG9QdHIgKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG5cbiAgLy8gRW5jb2RlIGVhY2ggc2VnbWVudCBhbmQgcmV0dXJuXG4gIHJldHVybiAoaGFzaFByZWZpeCAhPT0gZmFsc2UgPyAnIycgOiAnJykgKyAocGF0aC5sZW5ndGggPiAwID8gJy8nIDogJycpICsgZW5jb2RlUGF0aChwYXRoKS5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWZzIChvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBkb2N1bWVudFxuICAgICAgaWYgKCFfLmlzQXJyYXkob2JqKSAmJiAhXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iaiBtdXN0IGJlIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIG9iaik7XG5cbiAgICAgIC8vIENsb25lIHRoZSBpbnB1dCBzbyB3ZSBkbyBub3QgYWx0ZXIgaXRcbiAgICAgIG9iaiA9IF8uY2xvbmVEZWVwKG9iaik7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgICAgIGRlcHM6IHt9LCAvLyBUbyBhdm9pZCBwcm9jZXNzaW5nIHRoZSBzYW1lIHJlZmVybmVjZSB0d2ljZSwgYW5kIGZvciBjaXJjdWxhciByZWZlcmVuY2UgaWRlbnRpZmljYXRpb25cbiAgICAgICAgZG9jczoge30sIC8vIENhY2hlIHRvIGF2b2lkIHByb2Nlc3NpbmcgdGhlIHNhbWUgZG9jdW1lbnQgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgcmVmczoge30gLy8gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgdGhlaXIgbWV0YWRhdGFcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBidWlsZFJlZk1vZGVsKG9iaiwgb3B0aW9ucywgbWV0YWRhdGEpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgIHZhciBhbGxSZWZzID0ge307XG4gICAgICB2YXIgY2lyY3VsYXJQYXRocyA9IFtdO1xuICAgICAgdmFyIGNpcmN1bGFycyA9IFtdO1xuICAgICAgdmFyIGRlcEdyYXBoID0gbmV3IGdsLkdyYXBoKCk7XG4gICAgICB2YXIgZnVsbExvY2F0aW9uID0gbWFrZUFic29sdXRlKG9wdGlvbnMubG9jYXRpb24pO1xuICAgICAgdmFyIHJlZnNSb290ID0gZnVsbExvY2F0aW9uICsgcGF0aFRvUHRyKG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gICAgICB2YXIgcmVsYXRpdmVCYXNlID0gcGF0aC5kaXJuYW1lKGZ1bGxMb2NhdGlvbik7XG5cbiAgICAgIC8vIElkZW50aWZ5IGNpcmN1bGFyc1xuXG4gICAgICAvLyBBZGQgbm9kZXMgZmlyc3RcbiAgICAgIE9iamVjdC5rZXlzKHJlc3VsdHMuZGVwcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBkZXBHcmFwaC5zZXROb2RlKG5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBlZGdlc1xuICAgICAgXy5mb3JPd24ocmVzdWx0cy5kZXBzLCBmdW5jdGlvbiAocHJvcHMsIG5vZGUpIHtcbiAgICAgICAgXy5mb3JPd24ocHJvcHMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBkZXBHcmFwaC5zZXRFZGdlKG5vZGUsIGRlcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNpcmN1bGFyUGF0aHMgPSBnbC5hbGcuZmluZEN5Y2xlcyhkZXBHcmFwaCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBsaXN0IG9mIGNpcmN1bGFyc1xuICAgICAgY2lyY3VsYXJQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgaWYgKGNpcmN1bGFycy5pbmRleE9mKHNlZykgPT09IC0xKSB7XG4gICAgICAgICAgICBjaXJjdWxhcnMucHVzaChzZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWRlbnRpZnkgY2lyY3VsYXJzXG4gICAgICBfLmZvck93bihyZXN1bHRzLmRlcHMsIGZ1bmN0aW9uIChwcm9wcywgbm9kZSkge1xuICAgICAgICBfLmZvck93bihwcm9wcywgZnVuY3Rpb24gKGRlcCwgcHJvcCkge1xuICAgICAgICAgIHZhciBpc0NpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHJlZlB0ciA9IG5vZGUgKyBwcm9wLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW25vZGUgKyBwcm9wLnNsaWNlKDEpXTtcbiAgICAgICAgICB2YXIgcmVtb3RlID0gaXNSZW1vdGUocmVmRGV0YWlscyk7XG4gICAgICAgICAgdmFyIHBhdGhJbmRleDtcblxuICAgICAgICAgIGlmIChjaXJjdWxhcnMuaW5kZXhPZihkZXApID4gLTEpIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlIGNpcmN1bGFyIGlzIHBhcnQgb2YgYSBjaXJjdWxhciBjaGFpbiBvciBqdXN0IGEgcmVmZXJlbmNlIHRvIGEgY2lyY3VsYXJcbiAgICAgICAgICAgIGNpcmN1bGFyUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAvLyBTaG9ydCBjaXJjdWl0XG4gICAgICAgICAgICAgIGlmIChpc0NpcmN1bGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGF0aEluZGV4ID0gcGF0aC5pbmRleE9mKGRlcCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhdGhJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBwYXRoIHNlZ21lbnQgdG8gc2VlIGlmIHRoZSByZWZlcmVuY2UgbG9jYXRpb24gaXMgYmVuZWF0aCBvbmUgb2YgaXRzIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNob3J0IGNpcmN1aXRcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NpcmN1bGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlZlB0ci5pbmRleE9mKHNlZyArICcvJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBsb2NhbCwgbWFyayBpdCBhcyBjaXJjdWxhciBidXQgaWYgaXQncyBhIHJlbW90ZSByZWZlcmVuY2UsIG9ubHkgbWFyayBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBjaXJjdWxhciBpZiB0aGUgbWF0Y2hpbmcgcGF0aCBpcyB0aGUgbGFzdCBwYXRoIHNlZ21lbnQgb3IgaXRzIG1hdGNoIGlzIG5vdCB0byBhIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW1vdGUgfHwgcGF0aEluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgfHwgZGVwW2RlcC5sZW5ndGggLSAxXSAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNDaXJjdWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQ2lyY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgcmVmZXJlbmNlcyBhbmQgcmVmZXJlbmNlIGRldGFpbHNcbiAgICAgICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVmZXJlbmNlcyBpbiByZXZlcnNlIG9yZGVyIHNpbmNlIHRoZSBjdXJyZW50IG9yZGVyIGlzIHRvcC1kb3duXG4gICAgICBfLmZvck93bihPYmplY3Qua2V5cyhyZXN1bHRzLmRlcHMpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHBhcmVudFB0cikge1xuICAgICAgICB2YXIgZGVwcyA9IHJlc3VsdHMuZGVwc1twYXJlbnRQdHJdO1xuICAgICAgICB2YXIgcFB0clBhcnRzID0gcGFyZW50UHRyLnNwbGl0KCcjJyk7XG4gICAgICAgIHZhciBwRG9jdW1lbnQgPSByZXN1bHRzLmRvY3NbcFB0clBhcnRzWzBdXTtcbiAgICAgICAgdmFyIHBQdHJQYXRoID0gcGF0aEZyb21QdHIocFB0clBhcnRzWzFdKTtcblxuICAgICAgICBfLmZvck93bihkZXBzLCBmdW5jdGlvbiAoZGVwLCBwcm9wKSB7XG4gICAgICAgICAgdmFyIGRlcFBhcnRzID0gc3BsaXRGcmFnbWVudChkZXApO1xuICAgICAgICAgIHZhciBkRG9jdW1lbnQgPSByZXN1bHRzLmRvY3NbZGVwUGFydHNbMF1dO1xuICAgICAgICAgIHZhciBkUHRyUGF0aCA9IHBQdHJQYXRoLmNvbmNhdChwYXRoRnJvbVB0cihwcm9wKSk7XG4gICAgICAgICAgdmFyIHJlZkRldGFpbHMgPSByZXN1bHRzLnJlZnNbcFB0clBhcnRzWzBdICsgcGF0aFRvUHRyKGRQdHJQYXRoKV07XG5cbiAgICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZSBpZiB2YWxpZFxuICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlZkRldGFpbHMuZXJyb3IpICYmIF8uaXNVbmRlZmluZWQocmVmRGV0YWlscy5taXNzaW5nKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMgJiYgcmVmRGV0YWlscy5jaXJjdWxhcikge1xuICAgICAgICAgICAgICByZWZEZXRhaWxzLnZhbHVlID0gXy5jbG9uZURlZXAocmVmRGV0YWlscy5kZWYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWZEZXRhaWxzLnZhbHVlID0gZmluZFZhbHVlKGREb2N1bWVudCwgcGF0aEZyb21QdHIoZGVwUGFydHNbMV0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbWFya01pc3NpbmcocmVmRGV0YWlscywgZXJyKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgYXQgdGhlIHJvb3Qgb2YgdGhlIGRvY3VtZW50LCByZXBsYWNlIHRoZSBkb2N1bWVudCBpbiB0aGUgY2FjaGUuICBPdGhlcndpc2UsIHJlcGxhY2VcbiAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGluIHRoZSBhcHByb3ByaWF0ZSBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQgY2FjaGUuXG4gICAgICAgICAgICAgIGlmIChwUHRyUGFydHNbMV0gPT09ICcnICYmIHByb3AgPT09ICcjJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuZG9jc1twUHRyUGFydHNbMF1dID0gcmVmRGV0YWlscy52YWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShwRG9jdW1lbnQsIGRQdHJQYXRoLCByZWZEZXRhaWxzLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gd2Fsa1JlZnMgKHJvb3QsIHJlZlB0ciwgcmVmUGF0aCkge1xuICAgICAgICB2YXIgcmVmUHRyUGFydHMgPSByZWZQdHIuc3BsaXQoJyMnKTtcbiAgICAgICAgdmFyIHJlZkRldGFpbHMgPSByZXN1bHRzLnJlZnNbcmVmUHRyXTtcbiAgICAgICAgdmFyIHJlZkRlcHM7XG5cbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZWZlcmVuY2UgKHJlbGF0aXZlIHRvIHRoZSByb290IGRvY3VtZW50IHVubGVzcyB0aGUgcmVmZXJlbmNlIGlzIGluIHRoZSByb290IGRvY3VtZW50KVxuICAgICAgICBhbGxSZWZzW3JlZlB0clBhcnRzWzBdID09PSBvcHRpb25zLmxvY2F0aW9uID9cbiAgICAgICAgICAgICAgICAgICcjJyArIHJlZlB0clBhcnRzWzFdIDpcbiAgICAgICAgICAgICAgICAgIHBhdGhUb1B0cihvcHRpb25zLnN1YkRvY1BhdGguY29uY2F0KHJlZlBhdGgpKV0gPSByZWZEZXRhaWxzO1xuXG4gICAgICAgIC8vIERvIG5vdCB3YWxrIGludmFsaWQgcmVmZXJlbmNlc1xuICAgICAgICBpZiAocmVmRGV0YWlscy5jaXJjdWxhciB8fCAhaXNWYWxpZChyZWZEZXRhaWxzKSkge1xuICAgICAgICAgIC8vIFNhbml0aXplIGVycm9yc1xuICAgICAgICAgIGlmICghcmVmRGV0YWlscy5jaXJjdWxhciAmJiByZWZEZXRhaWxzLmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2F5IHdlIHVzZSBmaW5kUmVmcyBub3cgcmVzdWx0cyBpbiBhbiBlcnJvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGF0aW9uXG4gICAgICAgICAgICByZWZEZXRhaWxzLmVycm9yID0gcmVmRGV0YWlscy5lcnJvci5yZXBsYWNlKCdvcHRpb25zLnN1YkRvY1BhdGgnLCAnSlNPTiBQb2ludGVyJyk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXJyb3IgdG8gdXNlIHRoZSBhcHByb3ByaWF0ZSBKU09OIFBvaW50ZXJcbiAgICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmVycm9yLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHJlZkRldGFpbHMuZXJyb3IgPSByZWZEZXRhaWxzLmVycm9yLnJlcGxhY2UocmVmRGV0YWlscy51cmkuc3Vic3RyKHJlZkRldGFpbHMudXJpLmluZGV4T2YoJyMnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmRGV0YWlscy51cmkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JzIG9wZW5pbmcgZmlsZXMgYXMgSlNPTiBQb2ludGVyIGVycm9yc1xuICAgICAgICAgICAgaWYgKHJlZkRldGFpbHMuZXJyb3IuaW5kZXhPZignRU5PRU5UOicpID09PSAwIHx8IHJlZkRldGFpbHMuZXJyb3IuaW5kZXhPZignTm90IEZvdW5kJykgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVmRGV0YWlscy5lcnJvciA9ICdKU09OIFBvaW50ZXIgcG9pbnRzIHRvIG1pc3NpbmcgbG9jYXRpb246ICcgKyByZWZEZXRhaWxzLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWZEZXBzID0gcmVzdWx0cy5kZXBzW3JlZkRldGFpbHMucmVmZElkXTtcblxuICAgICAgICBpZiAocmVmRGV0YWlscy5yZWZkSWQuaW5kZXhPZihyb290KSAhPT0gMCkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJlZkRlcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHdhbGtSZWZzKHJlZkRldGFpbHMucmVmZElkLCByZWZEZXRhaWxzLnJlZmRJZCArIHByb3Auc3Vic3RyKDEpLCByZWZQYXRoLmNvbmNhdChwYXRoRnJvbVB0cihwcm9wKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBvbmx5IHByb2Nlc3MgYSBkb2N1bWVudCAob3Igc3ViIGRvY3VtZW50KSBhbmQgZWFjaCByZWZlcmVuY2Ugb25jZSBldmVyLiAgVGhpcyBtZWFuc1xuICAgICAgLy8gdGhhdCBpZiB3ZSB3YW50IHRvIHByb3ZpZGUgdGhlIGZ1bGwgcGljdHVyZSBhcyB0byB3aGF0IHBhdGhzIGluIHRoZSByZXNvbHZlZCBkb2N1bWVudCB3ZXJlIGNyZWF0ZWQgYXMgYSByZXN1bHRcbiAgICAgIC8vIG9mIGEgcmVmZXJlbmNlLCB3ZSBoYXZlIHRvIHRha2Ugb3VyIGZ1bGx5LXF1YWxpZmllZCByZWZlcmVuY2UgbG9jYXRpb25zIGFuZCBleHBhbmQgdGhlbSB0byBiZSBhbGwgbG9jYWwgYmFzZWRcbiAgICAgIC8vIG9uIHRoZSBvcmlnaW5hbCBkb2N1bWVudC5cbiAgICAgIE9iamVjdC5rZXlzKHJlc3VsdHMucmVmcykuZm9yRWFjaChmdW5jdGlvbiAocmVmUHRyKSB7XG4gICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW3JlZlB0cl07XG4gICAgICAgIHZhciBmcVVSSVNlZ21lbnRzO1xuICAgICAgICB2YXIgdXJpU2VnbWVudHM7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZnVsbHktcXVhbGlmaWVkIHJlZmVyZW5jZSBVUklzIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCByb290IChpZiBuZWNlc3NhcnkpLiAgVGhpcyBzdGVwIGlzIGRvbmUgaGVyZVxuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBpbnN0ZWFkIG9mIGJlbG93IHdoZW4gdGhlIG9mZmljaWFsIHNhbml0aXphdGlvbiBwcm9jZXNzIHJ1bnMuXG4gICAgICAgIGlmIChyZWZEZXRhaWxzLnR5cGUgIT09ICdpbnZhbGlkJykge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdHJhaWxpbmcgaGFzaCBmcm9tIGRvY3VtZW50IHJvb3QgcmVmZXJlbmNlcyBpZiB0aGV5IHdlcmVuJ3QgaW4gdGhlIG9yaWdpbmFsIFVSSVxuICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmZxVVJJW3JlZkRldGFpbHMuZnFVUkkubGVuZ3RoIC0gMV0gPT09ICcjJyAmJlxuICAgICAgICAgICAgICAgIHJlZkRldGFpbHMudXJpW3JlZkRldGFpbHMudXJpLmxlbmd0aCAtIDFdICE9PSAnIycpIHtcbiAgICAgICAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSByZWZEZXRhaWxzLmZxVVJJLnN1YnN0cigwLCByZWZEZXRhaWxzLmZxVVJJLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZxVVJJU2VnbWVudHMgPSByZWZEZXRhaWxzLmZxVVJJLnNwbGl0KCcvJyk7XG4gICAgICAgICAgdXJpU2VnbWVudHMgPSByZWZEZXRhaWxzLnVyaS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgLy8gVGhlIGZ1bGx5LXF1YWxpZmllZCBVUkkgaXMgdW5lbmNvZGVkIHNvIHRvIGtlZXAgdGhlIG9yaWdpbmFsIGZvcm1hdHRpbmcgb2YgdGhlIFVSSSAoZW5jb2RlZCB2cy4gdW5lbmNvZGVkKSxcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlcGxhY2UgZWFjaCBVUkkgc2VnbWVudCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICAgIF8udGltZXModXJpU2VnbWVudHMubGVuZ3RoIC0gMSwgZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBuU2VnID0gdXJpU2VnbWVudHNbdXJpU2VnbWVudHMubGVuZ3RoIC0gdGltZSAtIDFdO1xuICAgICAgICAgICAgdmFyIHBTZWcgPSB1cmlTZWdtZW50c1t1cmlTZWdtZW50cy5sZW5ndGggLSB0aW1lXTtcbiAgICAgICAgICAgIHZhciBmcVNlZ0luZGV4ID0gZnFVUklTZWdtZW50cy5sZW5ndGggLSB0aW1lIC0gMTtcblxuICAgICAgICAgICAgaWYgKG5TZWcgPT09ICcuJyB8fCBuU2VnID09PSAnLi4nIHx8IHBTZWcgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcVVSSVNlZ21lbnRzW2ZxU2VnSW5kZXhdID0gblNlZztcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSBmcVVSSVNlZ21lbnRzLmpvaW4oJy8nKTtcblxuICAgICAgICAgIC8vIE1ha2UgdGhlIGZ1bGx5LXF1YWxpZmllZCBVUklzIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCByb290XG4gICAgICAgICAgaWYgKHJlZkRldGFpbHMuZnFVUkkuaW5kZXhPZihmdWxsTG9jYXRpb24pID09PSAwKSB7XG4gICAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gcmVmRGV0YWlscy5mcVVSSS5yZXBsYWNlKGZ1bGxMb2NhdGlvbiwgJycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVmRGV0YWlscy5mcVVSSS5pbmRleE9mKHJlbGF0aXZlQmFzZSkgPT09IDApIHtcbiAgICAgICAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSByZWZEZXRhaWxzLmZxVVJJLnJlcGxhY2UocmVsYXRpdmVCYXNlLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlZkRldGFpbHMuZnFVUklbMF0gPT09ICcvJykge1xuICAgICAgICAgICAgcmVmRGV0YWlscy5mcVVSSSA9ICcuJyArIHJlZkRldGFpbHMuZnFVUkk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHByb2Nlc3MgcmVmZXJlbmNlcyBmb3VuZCBhdCBvciBiZW5lYXRoIHRoZSBwcm92aWRlZCBkb2N1bWVudCBhbmQgc3ViLWRvY3VtZW50IHBhdGhcbiAgICAgICAgaWYgKHJlZlB0ci5pbmRleE9mKHJlZnNSb290KSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhbGtSZWZzKHJlZnNSb290LCByZWZQdHIsIHBhdGhGcm9tUHRyKHJlZlB0ci5zdWJzdHIocmVmc1Jvb3QubGVuZ3RoKSkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNhbml0aXplIHRoZSByZWZlcmVuY2UgZGV0YWlsc1xuICAgICAgXy5mb3JPd24oYWxsUmVmcywgZnVuY3Rpb24gKHJlZkRldGFpbHMsIHJlZlB0cikge1xuICAgICAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBpZCB1c2VkIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nIGFuZCBjaXJjdWxhciBpZGVudGlmaWNhdGlvblxuICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5yZWZkSWQ7XG5cbiAgICAgICAgLy8gRm9yIGxvY2FsbHktY2lyY3VsYXIgcmVmZXJlbmNlcywgdXBkYXRlIHRoZSAkcmVmIHRvIGJlIGZ1bGx5IHF1YWxpZmllZCAoSXNzdWUgIzE3NSlcbiAgICAgICAgaWYgKHJlZkRldGFpbHMuY2lyY3VsYXIgJiYgcmVmRGV0YWlscy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgcmVmRGV0YWlscy52YWx1ZS4kcmVmID0gcmVmRGV0YWlscy5mcVVSSTtcblxuICAgICAgICAgIHNldFZhbHVlKHJlc3VsdHMuZG9jc1tmdWxsTG9jYXRpb25dLCBwYXRoRnJvbVB0cihyZWZQdHIpLCByZWZEZXRhaWxzLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGF2b2lkIHRoZSBlcnJvciBtZXNzYWdlIGJlaW5nIFVSSSBlbmNvZGVkL2RlY29kZWQgYnkgbWlzdGFrZSwgcmVwbGFjZSB0aGUgY3VycmVudCBKU09OIFBvaW50ZXIgd2l0aCB0aGVcbiAgICAgICAgLy8gdmFsdWUgaW4gdGhlIEpTT04gUmVmZXJlbmNlIGRlZmluaXRpb24uXG4gICAgICAgIGlmIChyZWZEZXRhaWxzLm1pc3NpbmcpIHtcbiAgICAgICAgICByZWZEZXRhaWxzLmVycm9yID0gcmVmRGV0YWlscy5lcnJvci5zcGxpdCgnOiAnKVswXSArICc6ICcgKyByZWZEZXRhaWxzLmRlZi4kcmVmO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmczogYWxsUmVmcyxcbiAgICAgICAgcmVzb2x2ZWQ6IHJlc3VsdHMuZG9jc1tmdWxsTG9jYXRpb25dXG4gICAgICB9O1xuICAgIH0pO1xuXG4gIHJldHVybiBhbGxUYXNrcztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKGxvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsb2NhdGlvbiB0byB0aGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZy92YWxpZGF0aW9uXG4gICAgICAgIG9wdGlvbnMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KG9wdGlvbnMubG9jYXRpb24sIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVSZWZzKHJlcywgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlczIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmczogcmVzMi5yZWZzLFxuICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlczIucmVzb2x2ZWQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG4vLyBzcGxpdHMgYSBmcmFnbWVudCBmcm9tIGEgVVJJIHVzaW5nIHRoZSBmaXJzdCBoYXNoIGZvdW5kXG5mdW5jdGlvbiBzcGxpdEZyYWdtZW50KHVyaSkge1xuICB2YXIgaGFzaCA9IHVyaS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoIDwgMCkge1xuICAgIHJldHVybiBbdXJpXTtcbiAgfVxuICB2YXIgcGFydHMgPSBbXTtcbiAgcGFydHMucHVzaCh1cmkuc3Vic3RyaW5nKDAsIGhhc2gpKTtcbiAgcGFydHMucHVzaCh1cmkuc3Vic3RyaW5nKGhhc2ggKyAxKSk7XG4gIHJldHVybiBwYXJ0cztcbn1cblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyBmb3IgSlNPTiBSZWZlcmVuY2VzICooaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMykqIGFuZFxuICogSlNPTiBQb2ludGVycyAqKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxKSouXG4gKlxuICogQG1vZHVsZSBqc29uLXJlZnNcbiAqL1xuXG4vKipcbiAqIEEgbnVtYmVyIG9mIGZ1bmN0aW9ucyBleHBvcnRlZCBiZWxvdyBhcmUgdXNlZCB3aXRoaW4gdGhlIGV4cG9ydGVkIGZ1bmN0aW9ucy4gIFR5cGljYWxseSwgSSB3b3VsZCB1c2UgYSBmdW5jdGlvblxuICogZGVjbGFyYXRpb24gXyh3aXRoIGRvY3VtZW5hdGlvbilfIGFib3ZlIGFuZCB0aGVuIGp1c3QgZXhwb3J0IGEgcmVmZXJlbmNlIHRvIHRoZSBmdW5jdGlvbiBidXQgZHVlIHRvIGEgYnVnIGluIEpTRG9jXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL2pzZG9jMy9qc2RvYy9pc3N1ZXMvNjc5KSwgdGhpcyBicmVha3MgdGhlIGdlbmVyYXRlZCBBUEkgZG9jdW1lbnRhdGlvbiBhbmQgVHlwZVNjcmlwdFxuICogZGVjbGFyYXRpb25zLiAgU28gdGhhdCdzIHdoeSBlYWNoIGBtb2R1bGUuZXhwb3J0c2AgYmVsb3cgYmFzaWNhbGx5IGp1c3Qgd3JhcHMgYSBjYWxsIHRvIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbi5cbiAqL1xuXG4gLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGNhY2hlIG9mIHJlbW90ZSBkb2N1bWVudHMsIHJlZmVyZW5jZSBkZXRhaWxzLCBldGMuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJlbW90ZUNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMgYW5kIGRlY29kZXMgdGhlIEpTT04gUG9pbnRlciB0b2tlbnMgaW4gdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIC0gVGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBkZWNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgcmV0dXJuIGRlY29kZVBhdGgocGF0aCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMgYW5kIGVuY29kZXMgdGhlIHNwZWNpYWwgSlNPTiBQb2ludGVyIGNoYXJhY3RlcnMgaW4gdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIC0gVGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBlbmNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgcmV0dXJuIGVuY29kZVBhdGgocGF0aCk7XG59O1xuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgYXJyYXkvb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvYmogLSBUaGUgc3RydWN0dXJlIHRvIGZpbmQgSlNPTiBSZWZlcmVuY2VzIHdpdGhpblxuICogQHBhcmFtIHttb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpqc29uLXJlZnMuVW5yZXNvbHZlZFJlZkRldGFpbHN8dW5kZWZpbmVkPn0gYW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIEpTT04gUG9pbnRlcnNcbiAqICooZnJhZ21lbnQgdmVyc2lvbikqIHRvIHdoZXJlIHRoZSBKU09OIFJlZmVyZW5jZSBpcyBkZWZpbmVkIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHtAbGluayBVbnJlc29sdmVkUmVmRGV0YWlsc30uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gdGhlIGlucHV0IGFyZ3VtZW50cyBmYWlsIHZhbGlkYXRpb24gb3IgaWYgYG9wdGlvbnMuc3ViRG9jUGF0aGAgcG9pbnRzIHRvIGFuIGludmFsaWQgbG9jYXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRmluZGluZyBhbGwgdmFsaWQgcmVmZXJlbmNlc1xuICogdmFyIGFsbFJlZnMgPSBKc29uUmVmcy5maW5kUmVmcyhvYmopO1xuICogLy8gRmluZGluZyBhbGwgcmVtb3RlIHJlZmVyZW5jZXNcbiAqIHZhciByZW1vdGVSZWZzID0gSnNvblJlZnMuZmluZFJlZnMob2JqLCB7ZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddfSk7XG4gKiAvLyBGaW5kaW5nIGFsbCBpbnZhbGlkIHJlZmVyZW5jZXNcbiAqIHZhciBpbnZhbGlkUmVmcyA9IEpzb25SZWZzLmZpbmRSZWZzKG9iaiwge2ZpbHRlcjogJ2ludmFsaWQnLCBpbmNsdWRlSW52YWxpZDogdHJ1ZX0pO1xuICovXG5tb2R1bGUuZXhwb3J0cy5maW5kUmVmcyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZpbmRSZWZzKG9iaiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uLlxuICpcbiAqIFRoaXMgQVBJIGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZmluZFJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZCB0aGVuXG4gKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgZmluZFJlZnN9IG9uIHRoZSByZXRyaWV2ZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHJldHJpZXZlICooQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLCBqdXN0IG1ha2Ugc3VyZSB5b3UgbG9vayBhdCB0aGVcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc3xvcHRpb25zIGRvY3VtZW50YXRpb259IHRvIHNlZSBob3cgcmVsYXRpdmUgcmVmZXJlbmNlcyBhcmUgaGFuZGxlZC4pKlxuICogQHBhcmFtIHttb2R1bGU6anNvbi1yZWZzLkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxtb2R1bGU6anNvbi1yZWZzLlJldHJpZXZlZFJlZnNSZXN1bHRzPn0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMuUmV0cmlldmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVmZXJlbmNlcyB3aXRoaW4gYSBzdWIgZG9jdW1lbnRcbiAqIEpzb25SZWZzLmZpbmRSZWZzQXQoJ2h0dHA6Ly9wZXRzdG9yZS5zd2FnZ2VyLmlvL3YyL3N3YWdnZXIuanNvbicsIHtcbiAqICAgICBzdWJEb2NQYXRoOiAnIy9kZWZpbml0aW9ucydcbiAqICAgfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzcG9uc2VcbiAqICAgICAgLy9cbiAqICAgICAgLy8gcmVzLnJlZnM6IEpTT04gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZGV0YWlsc1xuICogICAgICAvLyByZXMudmFsdWU6IFRoZSByZXRyaWV2ZWQgZG9jdW1lbnRcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cy5maW5kUmVmc0F0ID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBmaW5kUmVmc0F0KGxvY2F0aW9uLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgSlNPTiBSZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBKU09OIFJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKlxuICogQHJldHVybnMge21vZHVsZTpqc29uLXJlZnMuVW5yZXNvbHZlZFJlZkRldGFpbHN9IHRoZSBkZXRhaWxlZCBpbmZvcm1hdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRSZWZEZXRhaWxzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gZ2V0UmVmRGV0YWlscyhvYmopO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBKU09OIFBvaW50ZXIuXG4gKlxuICogQSBzdHJpbmcgaXMgYSBKU09OIFBvaW50ZXIgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBzdHJpbmcgaXMgb2YgdHlwZSBgU3RyaW5nYFxuICogICAqIFRoZSBzdHJpbmcgbXVzdCBiZSBlbXB0eSwgYCNgIG9yIHN0YXJ0IHdpdGggYSBgL2Agb3IgYCMvYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdHIgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXBhcmF0aW5nIHRoZSBkaWZmZXJlbnQgd2F5cyB0byBpbnZva2UgaXNQdHIgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXNcbiAqIGlmIChpc1B0cihzdHIpKSB7XG4gKiAgIC8vIEhhbmRsZSBhIHZhbGlkIEpTT04gUG9pbnRlclxuICogfSBlbHNlIHtcbiAqICAgLy8gR2V0IHRoZSByZWFzb24gYXMgdG8gd2h5IHRoZSB2YWx1ZSBpcyBub3QgYSBKU09OIFBvaW50ZXIgc28geW91IGNhbiBmaXgvcmVwb3J0IGl0XG4gKiAgIHRyeSB7XG4gKiAgICAgaXNQdHIoc3RyLCB0cnVlKTtcbiAqICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBKU09OIFBvaW50ZXJcbiAqICAgfVxuICogfVxuICovXG5tb2R1bGUuZXhwb3J0cy5pc1B0ciA9IGZ1bmN0aW9uIChwdHIsIHRocm93V2l0aERldGFpbHMpIHtcbiAgcmV0dXJuIGlzUHRyKHB0ciwgdGhyb3dXaXRoRGV0YWlscyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgYXJndW1lbnQgcmVwcmVzZW50cyBhIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEFuIG9iamVjdCBpcyBhIEpTT04gUmVmZXJlbmNlIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBvYmplY3QgaXMgb2YgdHlwZSBgT2JqZWN0YFxuICogICAqIFRoZSBvYmplY3QgaGFzIGEgYCRyZWZgIHByb3BlcnR5XG4gKiAgICogVGhlIGAkcmVmYCBwcm9wZXJ0eSBpcyBhIHZhbGlkIFVSSSAqKFdlIGRvIG5vdCByZXF1aXJlIDEwMCUgc3RyaWN0IFVSSXMgYW5kIHdpbGwgaGFuZGxlIHVuZXNjYXBlZCBzcGVjaWFsXG4gKiAgICAgY2hhcmFjdGVycy4pKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMyNzZWN0aW9uLTN9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNlcGFyYXRpbmcgdGhlIGRpZmZlcmVudCB3YXlzIHRvIGludm9rZSBpc1JlZiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICogaWYgKGlzUmVmKG9iaikpIHtcbiAqICAgLy8gSGFuZGxlIGEgdmFsaWQgSlNPTiBSZWZlcmVuY2VcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIEdldCB0aGUgcmVhc29uIGFzIHRvIHdoeSB0aGUgdmFsdWUgaXMgbm90IGEgSlNPTiBSZWZlcmVuY2Ugc28geW91IGNhbiBmaXgvcmVwb3J0IGl0XG4gKiAgIHRyeSB7XG4gKiAgICAgaXNSZWYoc3RyLCB0cnVlKTtcbiAqICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBKU09OIFJlZmVyZW5jZVxuICogICB9XG4gKiB9XG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzUmVmID0gZnVuY3Rpb24gKG9iaiwgdGhyb3dXaXRoRGV0YWlscykge1xuICByZXR1cm4gaXNSZWYob2JqLCB0aHJvd1dpdGhEZXRhaWxzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIGZvciB0aGUgcHJvdmlkZWQgSlNPTiBQb2ludGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdHIgLSBUaGUgSlNPTiBQb2ludGVyXG4gKlxuICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgcGF0aCBzZWdtZW50c1xuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgcHJvdmlkZWQgYHB0cmAgYXJndW1lbnQgaXMgbm90IGEgSlNPTiBQb2ludGVyXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhdGhGcm9tUHRyID0gZnVuY3Rpb24gKHB0cikge1xuICByZXR1cm4gcGF0aEZyb21QdHIocHRyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIEpTT04gUG9pbnRlciBmb3IgdGhlIHByb3ZpZGVkIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gKlxuICogKipOb3RlOioqIElmIGEgcGF0aCBzZWdtZW50IGluIGBwYXRoYCBpcyBub3QgYSBgU3RyaW5nYCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gb25lIHVzaW5nIGBKU09OLnN0cmluZ2lmeWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIFRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNoUHJlZml4PXRydWVdIC0gV2hldGhlciBvciBub3QgY3JlYXRlIGEgaGFzaC1wcmVmaXhlZCBKU09OIFBvaW50ZXJcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBKU09OIFBvaW50ZXJcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGBwYXRoYCBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXlcbiAqL1xubW9kdWxlLmV4cG9ydHMucGF0aFRvUHRyID0gZnVuY3Rpb24gKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgcmV0dXJuIHBhdGhUb1B0cihwYXRoLCBoYXNoUHJlZml4KTtcbn07XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBhcnJheS9vYmplY3QgYW5kIHJlc29sdmVzIHRoZW0uXG4gKlxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IG9iaiAtIFRoZSBzdHJ1Y3R1cmUgdG8gZmluZCBKU09OIFJlZmVyZW5jZXMgd2l0aGluXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG1vZHVsZTpqc29uLXJlZnMuUmVzb2x2ZWRSZWZzUmVzdWx0cz59IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLlJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVsYXRpdmUgYW5kIHJlbW90ZSByZWZlcmVuY2VzXG4gKiBKc29uUmVmcy5yZXNvbHZlUmVmcyhzd2FnZ2VyT2JqLCB7XG4gKiAgICAgZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddXG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnJlc29sdmVkOiBUaGUgZG9jdW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSlNPTiBSZWZlcmVuY2VzIHJlc29sdmVkXG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZVJlZnMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXNvbHZlUmVmcyhvYmosIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBKU09OIFJlZmVyZW5jZXMgZGVmaW5lZCB3aXRoaW4gdGhlIGRvY3VtZW50IGF0IHRoZSBwcm92aWRlZCBsb2NhdGlvbi5cbiAqXG4gKiBUaGlzIEFQSSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMucmVzb2x2ZVJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZFxuICogdGhlbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgbW9kdWxlOmpzb24tcmVmcy5yZXNvbHZlUmVmc30gb24gdGhlIHJldHJpZXZlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gcmV0cmlldmUgKihDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIGp1c3QgbWFrZSBzdXJlIHlvdSBsb29rIGF0IHRoZVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfG9wdGlvbnMgZG9jdW1lbnRhdGlvbn0gdG8gc2VlIGhvdyByZWxhdGl2ZSByZWZlcmVuY2VzIGFyZSBoYW5kbGVkLikqXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnMuSnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG1vZHVsZTpqc29uLXJlZnMuUmV0cmlldmVkUmVzb2x2ZWRSZWZzUmVzdWx0cz59IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLlJldHJpZXZlZFJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbFxuICogdmFsaWRhdGlvbiwgd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW5cbiAqIHVubG9hZGFibGUgcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IGxvYWRzIGEgSlNPTiBkb2N1bWVudCAoTm8gb3B0aW9ucy5sb2FkZXJPcHRpb25zLnByb2Nlc3NDb250ZW50IHJlcXVpcmVkKSBhbmQgcmVzb2x2ZXMgYWxsIHJlZmVyZW5jZXNcbiAqIEpzb25SZWZzLnJlc29sdmVSZWZzQXQoJy4vc3dhZ2dlci5qc29uJylcbiAqICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzcG9uc2VcbiAqICAgICAgLy9cbiAqICAgICAgLy8gcmVzLnJlZnM6IEpTT04gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZGV0YWlsc1xuICogICAgICAvLyByZXMucmVzb2x2ZWQ6IFRoZSBkb2N1bWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBKU09OIFJlZmVyZW5jZXMgcmVzb2x2ZWRcbiAqICAgICAgLy8gcmVzLnZhbHVlOiBUaGUgcmV0cmlldmVkIGRvY3VtZW50XG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZVJlZnNBdCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gcmVzb2x2ZVJlZnNBdChsb2NhdGlvbiwgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcbnZhciBzZXRGdW5jdGlvbkxlbmd0aCA9IHJlcXVpcmUoJ3NldC1mdW5jdGlvbi1sZW5ndGgnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ2luYWxGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGgoXG5cdFx0ZnVuYyxcblx0XHQxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpLFxuXHRcdHRydWVcblx0KTtcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xuXG52YXIgZ29wZCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lRGF0YVByb3BlcnR5KFxuXHRvYmosXG5cdHByb3BlcnR5LFxuXHR2YWx1ZVxuKSB7XG5cdGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgb2JqYCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uYCcpO1xuXHR9XG5cdGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHByb3BlcnR5YCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sYCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzNdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25FbnVtZXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdHlwZW9mIGFyZ3VtZW50c1s0XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s0XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uV3JpdGFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNSAmJiB0eXBlb2YgYXJndW1lbnRzWzVdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzVdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Db25maWd1cmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNiAmJiB0eXBlb2YgYXJndW1lbnRzWzZdICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxvb3NlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgbm9uRW51bWVyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblx0dmFyIG5vbldyaXRhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXHR2YXIgbm9uQ29uZmlndXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNiA/IGFyZ3VtZW50c1s2XSA6IGZhbHNlO1xuXG5cdC8qIEB0eXBlIHtmYWxzZSB8IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPHVua25vd24+fSAqL1xuXHR2YXIgZGVzYyA9ICEhZ29wZCAmJiBnb3BkKG9iaiwgcHJvcGVydHkpO1xuXG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBub25Db25maWd1cmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuY29uZmlndXJhYmxlIDogIW5vbkNvbmZpZ3VyYWJsZSxcblx0XHRcdGVudW1lcmFibGU6IG5vbkVudW1lcmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuZW51bWVyYWJsZSA6ICFub25FbnVtZXJhYmxlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IG5vbldyaXRhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLndyaXRhYmxlIDogIW5vbldyaXRhYmxlXG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAobG9vc2UgfHwgKCFub25FbnVtZXJhYmxlICYmICFub25Xcml0YWJsZSAmJiAhbm9uQ29uZmlndXJhYmxlKSkge1xuXHRcdC8vIG11c3QgZmFsbCBiYWNrIHRvIFtbU2V0XV0sIGFuZCB3YXMgbm90IGV4cGxpY2l0bHkgYXNrZWQgdG8gbWFrZSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tY29uZmlndXJhYmxlXG5cdFx0b2JqW3Byb3BlcnR5XSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGRlZmluaW5nIGEgcHJvcGVydHkgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tZW51bWVyYWJsZS4nKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc3ludGF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRheEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdXJpJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFVSSUVycm9yO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSdcblxudmFyIGFyciA9IFtdXG52YXIgcmVwbGFjZXJTdGFjayA9IFtdXG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKVxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywgeyB2YWx1ZTogcmVwbGFjZSB9KVxuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2VcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcFxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPVxuICAgIHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gcmVwbGFjZXJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycycpO1xudmFyICRFdmFsRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvZXZhbCcpO1xudmFyICRSYW5nZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JhbmdlJyk7XG52YXIgJFJlZmVyZW5jZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JlZicpO1xudmFyICRTeW50YXhFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9zeW50YXgnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkVVJJRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdXJpJyk7XG5cbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNQcm90byA9IHJlcXVpcmUoJ2hhcy1wcm90bycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogJFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogJFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiAkVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBDaHJpcyBQZXR0aXR0XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuICogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXG4gKiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxuICogT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGxpYiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiBsaWIuR3JhcGgsXG4gIGpzb246IHJlcXVpcmUoXCIuL2xpYi9qc29uXCIpLFxuICBhbGc6IHJlcXVpcmUoXCIuL2xpYi9hbGdcIiksXG4gIHZlcnNpb246IGxpYi52ZXJzaW9uXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHM7XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHMoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgY21wdHMgPSBbXTtcbiAgdmFyIGNtcHQ7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBjbXB0LnB1c2godik7XG4gICAgXy5lYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgY21wdCA9IFtdO1xuICAgIGRmcyh2KTtcbiAgICBpZiAoY21wdC5sZW5ndGgpIHtcbiAgICAgIGNtcHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY21wdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGZzO1xuXG4vKlxuICogQSBoZWxwZXIgdGhhdCBwcmVmb3JtcyBhIHByZS0gb3IgcG9zdC1vcmRlciB0cmF2ZXJzYWwgb24gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgcmV0dXJucyB0aGUgbm9kZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSB2aXNpdGVkLiBJZiB0aGUgZ3JhcGggaXNcbiAqIHVuZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIG5laWdoYm9ycy4gSWYgdGhlIGdyYXBoXG4gKiBpcyBkaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgc3VjY2Vzc29ycy5cbiAqXG4gKiBPcmRlciBtdXN0IGJlIG9uZSBvZiBcInByZVwiIG9yIFwicG9zdFwiLlxuICovXG5mdW5jdGlvbiBkZnMoZywgdnMsIG9yZGVyKSB7XG4gIGlmICghXy5pc0FycmF5KHZzKSkge1xuICAgIHZzID0gW3ZzXTtcbiAgfVxuXG4gIHZhciBuYXZpZ2F0aW9uID0gKGcuaXNEaXJlY3RlZCgpID8gZy5zdWNjZXNzb3JzIDogZy5uZWlnaGJvcnMpLmJpbmQoZyk7XG5cbiAgdmFyIGFjYyA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIWcuaGFzTm9kZSh2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggZG9lcyBub3QgaGF2ZSBub2RlOiBcIiArIHYpO1xuICAgIH1cblxuICAgIGRvRGZzKGcsIHYsIG9yZGVyID09PSBcInBvc3RcIiwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIGRvRGZzKGcsIHYsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKSB7XG4gIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIGlmICghcG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gICAgXy5lYWNoKG5hdmlnYXRpb24odiksIGZ1bmN0aW9uKHcpIHtcbiAgICAgIGRvRGZzKGcsIHcsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgICB9KTtcbiAgICBpZiAocG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gIH1cbn1cbiIsInZhciBkaWprc3RyYSA9IHJlcXVpcmUoXCIuL2RpamtzdHJhXCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhQWxsO1xuXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBlZGdlRnVuYykge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZy5ub2RlcygpLCBmdW5jdGlvbihhY2MsIHYpIHtcbiAgICBhY2Nbdl0gPSBkaWprc3RyYShnLCB2LCB3ZWlnaHRGdW5jLCBlZGdlRnVuYyk7XG4gIH0sIHt9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5EaWprc3RyYShnLCBTdHJpbmcoc291cmNlKSxcbiAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgIGVkZ2VGbiB8fCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm91dEVkZ2VzKHYpOyB9KTtcbn1cblxuZnVuY3Rpb24gcnVuRGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHZhciByZXN1bHRzID0ge307XG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIHZhciB2LCB2RW50cnk7XG5cbiAgdmFyIHVwZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiAhPT0gdiA/IGVkZ2UudiA6IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gcmVzdWx0c1t3XTtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgdmFyIGRpc3RhbmNlID0gdkVudHJ5LmRpc3RhbmNlICsgd2VpZ2h0O1xuXG4gICAgaWYgKHdlaWdodCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpamtzdHJhIGRvZXMgbm90IGFsbG93IG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0cy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiQmFkIGVkZ2U6IFwiICsgZWRnZSArIFwiIFdlaWdodDogXCIgKyB3ZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChkaXN0YW5jZSA8IHdFbnRyeS5kaXN0YW5jZSkge1xuICAgICAgd0VudHJ5LmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB3RW50cnkucHJlZGVjZXNzb3IgPSB2O1xuICAgICAgcHEuZGVjcmVhc2UodywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfTtcblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgdmFyIGRpc3RhbmNlID0gdiA9PT0gc291cmNlID8gMCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICByZXN1bHRzW3ZdID0geyBkaXN0YW5jZTogZGlzdGFuY2UgfTtcbiAgICBwcS5hZGQodiwgZGlzdGFuY2UpO1xuICB9KTtcblxuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICB2RW50cnkgPSByZXN1bHRzW3ZdO1xuICAgIGlmICh2RW50cnkuZGlzdGFuY2UgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZWRnZUZuKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHRhcmphbiA9IHJlcXVpcmUoXCIuL3RhcmphblwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQ3ljbGVzO1xuXG5mdW5jdGlvbiBmaW5kQ3ljbGVzKGcpIHtcbiAgcmV0dXJuIF8uZmlsdGVyKHRhcmphbihnKSwgZnVuY3Rpb24oY21wdCkge1xuICAgIHJldHVybiBjbXB0Lmxlbmd0aCA+IDEgfHwgKGNtcHQubGVuZ3RoID09PSAxICYmIGcuaGFzRWRnZShjbXB0WzBdLCBjbXB0WzBdKSk7XG4gIH0pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZsb3lkV2Fyc2hhbGw7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZmxveWRXYXJzaGFsbChnLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5GbG95ZFdhcnNoYWxsKGcsXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgbm9kZXMgPSBnLm5vZGVzKCk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgcmVzdWx0c1t2XSA9IHt9O1xuICAgIHJlc3VsdHNbdl1bdl0gPSB7IGRpc3RhbmNlOiAwIH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAodiAhPT0gdykge1xuICAgICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWRnZUZuKHYpLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnY7XG4gICAgICB2YXIgZCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IGQsIHByZWRlY2Vzc29yOiB2IH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciByb3dLID0gcmVzdWx0c1trXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciByb3dJID0gcmVzdWx0c1tpXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICB2YXIgaWsgPSByb3dJW2tdO1xuICAgICAgICB2YXIga2ogPSByb3dLW2pdO1xuICAgICAgICB2YXIgaWogPSByb3dJW2pdO1xuICAgICAgICB2YXIgYWx0RGlzdGFuY2UgPSBpay5kaXN0YW5jZSArIGtqLmRpc3RhbmNlO1xuICAgICAgICBpZiAoYWx0RGlzdGFuY2UgPCBpai5kaXN0YW5jZSkge1xuICAgICAgICAgIGlqLmRpc3RhbmNlID0gYWx0RGlzdGFuY2U7XG4gICAgICAgICAgaWoucHJlZGVjZXNzb3IgPSBrai5wcmVkZWNlc3NvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvbmVudHM6IHJlcXVpcmUoXCIuL2NvbXBvbmVudHNcIiksXG4gIGRpamtzdHJhOiByZXF1aXJlKFwiLi9kaWprc3RyYVwiKSxcbiAgZGlqa3N0cmFBbGw6IHJlcXVpcmUoXCIuL2RpamtzdHJhLWFsbFwiKSxcbiAgZmluZEN5Y2xlczogcmVxdWlyZShcIi4vZmluZC1jeWNsZXNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IHJlcXVpcmUoXCIuL2Zsb3lkLXdhcnNoYWxsXCIpLFxuICBpc0FjeWNsaWM6IHJlcXVpcmUoXCIuL2lzLWFjeWNsaWNcIiksXG4gIHBvc3RvcmRlcjogcmVxdWlyZShcIi4vcG9zdG9yZGVyXCIpLFxuICBwcmVvcmRlcjogcmVxdWlyZShcIi4vcHJlb3JkZXJcIiksXG4gIHByaW06IHJlcXVpcmUoXCIuL3ByaW1cIiksXG4gIHRhcmphbjogcmVxdWlyZShcIi4vdGFyamFuXCIpLFxuICB0b3Bzb3J0OiByZXF1aXJlKFwiLi90b3Bzb3J0XCIpXG59O1xuIiwidmFyIHRvcHNvcnQgPSByZXF1aXJlKFwiLi90b3Bzb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuZnVuY3Rpb24gaXNBY3ljbGljKGcpIHtcbiAgdHJ5IHtcbiAgICB0b3Bzb3J0KGcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiB0b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RvcmRlcjtcblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicG9zdFwiKTtcbn1cbiIsInZhciBkZnMgPSByZXF1aXJlKFwiLi9kZnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlb3JkZXI7XG5cbmZ1bmN0aW9uIHByZW9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicHJlXCIpO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSByZXF1aXJlKFwiLi4vZGF0YS9wcmlvcml0eS1xdWV1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmltO1xuXG5mdW5jdGlvbiBwcmltKGcsIHdlaWdodEZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgcGFyZW50cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdjtcblxuICBmdW5jdGlvbiB1cGRhdGVOZWlnaGJvcnMoZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgIHZhciBwcmkgPSBwcS5wcmlvcml0eSh3KTtcbiAgICBpZiAocHJpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0RnVuYyhlZGdlKTtcbiAgICAgIGlmIChlZGdlV2VpZ2h0IDwgcHJpKSB7XG4gICAgICAgIHBhcmVudHNbd10gPSB2O1xuICAgICAgICBwcS5kZWNyZWFzZSh3LCBlZGdlV2VpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZy5ub2RlQ291bnQoKSA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcHEuYWRkKHYsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgcmVzdWx0LnNldE5vZGUodik7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGZyb20gYW4gYXJiaXRyYXJ5IG5vZGVcbiAgcHEuZGVjcmVhc2UoZy5ub2RlcygpWzBdLCAwKTtcblxuICB2YXIgaW5pdCA9IGZhbHNlO1xuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICBpZiAoXy5oYXMocGFyZW50cywgdikpIHtcbiAgICAgIHJlc3VsdC5zZXRFZGdlKHYsIHBhcmVudHNbdl0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ3JhcGggaXMgbm90IGNvbm5lY3RlZDogXCIgKyBnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlRWRnZXModikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0YXJqYW47XG5cbmZ1bmN0aW9uIHRhcmphbihnKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9OyAvLyBub2RlIGlkIC0+IHsgb25TdGFjaywgbG93bGluaywgaW5kZXggfVxuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGVudHJ5ID0gdmlzaXRlZFt2XSA9IHtcbiAgICAgIG9uU3RhY2s6IHRydWUsXG4gICAgICBsb3dsaW5rOiBpbmRleCxcbiAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgfTtcbiAgICBzdGFjay5wdXNoKHYpO1xuXG4gICAgZy5zdWNjZXNzb3JzKHYpLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgICBkZnModyk7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmxvd2xpbmspO1xuICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddLm9uU3RhY2spIHtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10uaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVudHJ5Lmxvd2xpbmsgPT09IGVudHJ5LmluZGV4KSB7XG4gICAgICB2YXIgY21wdCA9IFtdO1xuICAgICAgdmFyIHc7XG4gICAgICBkbyB7XG4gICAgICAgIHcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmlzaXRlZFt3XS5vblN0YWNrID0gZmFsc2U7XG4gICAgICAgIGNtcHQucHVzaCh3KTtcbiAgICAgIH0gd2hpbGUgKHYgIT09IHcpO1xuICAgICAgcmVzdWx0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfVxuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICBkZnModik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b3Bzb3J0O1xudG9wc29ydC5DeWNsZUV4Y2VwdGlvbiA9IEN5Y2xlRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHN0YWNrID0ge307XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChfLmhhcyhzdGFjaywgbm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghXy5oYXModmlzaXRlZCwgbm9kZSkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKG5vZGUpLCB2aXNpdCk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgXy5lYWNoKGcuc2lua3MoKSwgdmlzaXQpO1xuXG4gIGlmIChfLnNpemUodmlzaXRlZCkgIT09IGcubm9kZUNvdW50KCkpIHtcbiAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBDeWNsZUV4Y2VwdGlvbigpIHt9XG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsgLy8gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB0byBwYXNzIHRlc3RpbmciLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpb3JpdHlRdWV1ZTtcblxuLyoqXG4gKiBBIG1pbi1wcmlvcml0eSBxdWV1ZSBkYXRhIHN0cnVjdHVyZS4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIENvcm1lbixcbiAqIGV0IGFsLiwgXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLiBUaGUgYmFzaWMgaWRlYSBvZiBhIG1pbi1wcmlvcml0eVxuICogcXVldWUgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IChpbiBPKDEpIHRpbWUpIGdldCB0aGUgc21hbGxlc3Qga2V5IGluXG4gKiB0aGUgcXVldWUuIEFkZGluZyBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgdGFrZXMgTyhsb2cgbikgdGltZS4gQSBrZXkgY2FuXG4gKiBoYXZlIGl0cyBwcmlvcml0eSBkZWNyZWFzZWQgaW4gTyhsb2cgbikgdGltZS5cbiAqL1xuZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgdGhpcy5fYXJyID0gW107XG4gIHRoaXMuX2tleUluZGljZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyB0aGF0IGFyZSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgua2V5OyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgKiprZXkqKiBpcyBpbiB0aGUgcXVldWUgYW5kIGBmYWxzZWAgaWYgbm90LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2tleUluZGljZXMsIGtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqLiBJZiAqKmtleSoqIGlzIG5vdCBwcmVzZW50IGluIHRoZSBxdWV1ZVxuICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuIFRha2VzIGBPKDEpYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHJpb3JpdHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5O1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGlzIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXNcbiAqIGVtcHR5IHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIHVuZGVyZmxvd1wiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyWzBdLmtleTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBrZXkgaW50byB0aGUgcHJpb3JpdHkgcXVldWUuIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgaW5cbiAqIHRoZSBxdWV1ZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYDsgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAqIFRha2VzIGBPKG4pYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgaW5pdGlhbCBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAga2V5ID0gU3RyaW5nKGtleSk7XG4gIGlmICghXy5oYXMoa2V5SW5kaWNlcywga2V5KSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gICAgdmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcbiAgICBrZXlJbmRpY2VzW2tleV0gPSBpbmRleDtcbiAgICBhcnIucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IGtleSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKGxvZyBuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N3YXAoMCwgdGhpcy5fYXJyLmxlbmd0aCAtIDEpO1xuICB2YXIgbWluID0gdGhpcy5fYXJyLnBvcCgpO1xuICBkZWxldGUgdGhpcy5fa2V5SW5kaWNlc1ttaW4ua2V5XTtcbiAgdGhpcy5faGVhcGlmeSgwKTtcbiAgcmV0dXJuIG1pbi5rZXk7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiogdG8gKipwcmlvcml0eSoqLiBJZiB0aGUgbmV3IHByaW9yaXR5IGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIHByaW9yaXR5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byByYWlzZSBwcmlvcml0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBuZXcgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVjcmVhc2UgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKHByaW9yaXR5ID4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBwcmlvcml0eSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBwcmlvcml0eS4gXCIgK1xuICAgICAgICBcIktleTogXCIgKyBrZXkgKyBcIiBPbGQ6IFwiICsgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSArIFwiIE5ldzogXCIgKyBwcmlvcml0eSk7XG4gIH1cbiAgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5faGVhcGlmeSA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGwgPSAyICogaTtcbiAgdmFyIHIgPSBsICsgMTtcbiAgdmFyIGxhcmdlc3QgPSBpO1xuICBpZiAobCA8IGFyci5sZW5ndGgpIHtcbiAgICBsYXJnZXN0ID0gYXJyW2xdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gbCA6IGxhcmdlc3Q7XG4gICAgaWYgKHIgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBsYXJnZXN0ID0gYXJyW3JdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gciA6IGxhcmdlc3Q7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0ICE9PSBpKSB7XG4gICAgICB0aGlzLl9zd2FwKGksIGxhcmdlc3QpO1xuICAgICAgdGhpcy5faGVhcGlmeShsYXJnZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9kZWNyZWFzZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBwcmlvcml0eSA9IGFycltpbmRleF0ucHJpb3JpdHk7XG4gIHZhciBwYXJlbnQ7XG4gIHdoaWxlIChpbmRleCAhPT0gMCkge1xuICAgIHBhcmVudCA9IGluZGV4ID4+IDE7XG4gICAgaWYgKGFycltwYXJlbnRdLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zd2FwKGluZGV4LCBwYXJlbnQpO1xuICAgIGluZGV4ID0gcGFyZW50O1xuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICB2YXIgb3JpZ0FyckkgPSBhcnJbaV07XG4gIHZhciBvcmlnQXJySiA9IGFycltqXTtcbiAgYXJyW2ldID0gb3JpZ0Fycko7XG4gIGFycltqXSA9IG9yaWdBcnJJO1xuICBrZXlJbmRpY2VzW29yaWdBcnJKLmtleV0gPSBpO1xuICBrZXlJbmRpY2VzW29yaWdBcnJJLmtleV0gPSBqO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxudmFyIERFRkFVTFRfRURHRV9OQU1FID0gXCJcXHgwMFwiO1xudmFyIEdSQVBIX05PREUgPSBcIlxceDAwXCI7XG52YXIgRURHRV9LRVlfREVMSU0gPSBcIlxceDAxXCI7XG5cbi8vIEltcGxlbWVudGF0aW9uIG5vdGVzOlxuLy9cbi8vICAqIE5vZGUgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gc3RyaW5nIGlkcyBmb3IgdGhlIG5vZGVzXG4vLyAgKiBFZGdlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIFwiZWRnZU9ialwiLCBlZGdlIG9iamVjdCwgdGhhdCBpc1xuLy8gICAgY29tcG9zZWQgb2YgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFuIGVkZ2U6IHt2LCB3LCBuYW1lfS5cbi8vICAqIEludGVybmFsbHkgd2UgdXNlIGFuIFwiZWRnZUlkXCIsIGEgc3RyaW5naWZpZWQgZm9ybSBvZiB0aGUgZWRnZU9iaiwgdG9cbi8vICAgIHJlZmVyZW5jZSBlZGdlcy4gVGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgYSBwZXJmb3JtYW50IHdheSB0byBsb29rIHRoZXNlXG4vLyAgICBlZGdlcyB1cCBhbmQsIG9iamVjdCBwcm9wZXJ0aWVzLCB3aGljaCBoYXZlIHN0cmluZyBrZXlzLCBhcmUgdGhlIGNsb3Nlc3Rcbi8vICAgIHdlJ3JlIGdvaW5nIHRvIGdldCB0byBhIHBlcmZvcm1hbnQgaGFzaHRhYmxlIGluIEphdmFTY3JpcHQuXG5cbmZ1bmN0aW9uIEdyYXBoKG9wdHMpIHtcbiAgdGhpcy5faXNEaXJlY3RlZCA9IF8uaGFzKG9wdHMsIFwiZGlyZWN0ZWRcIikgPyBvcHRzLmRpcmVjdGVkIDogdHJ1ZTtcbiAgdGhpcy5faXNNdWx0aWdyYXBoID0gXy5oYXMob3B0cywgXCJtdWx0aWdyYXBoXCIpID8gb3B0cy5tdWx0aWdyYXBoIDogZmFsc2U7XG4gIHRoaXMuX2lzQ29tcG91bmQgPSBfLmhhcyhvcHRzLCBcImNvbXBvdW5kXCIpID8gb3B0cy5jb21wb3VuZCA6IGZhbHNlO1xuXG4gIC8vIExhYmVsIGZvciB0aGUgZ3JhcGggaXRzZWxmXG4gIHRoaXMuX2xhYmVsID0gdW5kZWZpbmVkO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IG5vZGVcbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGVkZ2VcbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIHYgLT4gbGFiZWxcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIC8vIHYgLT4gcGFyZW50XG4gICAgdGhpcy5fcGFyZW50ID0ge307XG5cbiAgICAvLyB2IC0+IGNoaWxkcmVuXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXSA9IHt9O1xuICB9XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX2luID0ge307XG5cbiAgLy8gdSAtPiB2IC0+IE51bWJlclxuICB0aGlzLl9wcmVkcyA9IHt9O1xuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9vdXQgPSB7fTtcblxuICAvLyB2IC0+IHcgLT4gTnVtYmVyXG4gIHRoaXMuX3N1Y3MgPSB7fTtcblxuICAvLyBlIC0+IGVkZ2VPYmpcbiAgdGhpcy5fZWRnZU9ianMgPSB7fTtcblxuICAvLyBlIC0+IGxhYmVsXG4gIHRoaXMuX2VkZ2VMYWJlbHMgPSB7fTtcbn1cblxuLyogTnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX25vZGVDb3VudCA9IDA7XG5cbi8qIE51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9lZGdlQ291bnQgPSAwO1xuXG5cbi8qID09PSBHcmFwaCBmdW5jdGlvbnMgPT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RpcmVjdGVkO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTXVsdGlncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNNdWx0aWdyYXBoO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzQ29tcG91bmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ29tcG91bmQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0R3JhcGggPSBmdW5jdGlvbihsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWw7XG59O1xuXG5cbi8qID09PSBOb2RlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0Tm9kZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmtleXModGhpcy5fbm9kZXMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNvdXJjZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9pblt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNpbmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5fb3V0W3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXROb2RlKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbih2LCB2YWx1ZSkge1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9ub2Rlc1t2XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX25vZGVzW3ZdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbih2KTtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aGlzLl9wYXJlbnRbdl0gPSBHUkFQSF9OT0RFO1xuICAgIHRoaXMuX2NoaWxkcmVuW3ZdID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV1bdl0gPSB0cnVlO1xuICB9XG4gIHRoaXMuX2luW3ZdID0ge307XG4gIHRoaXMuX3ByZWRzW3ZdID0ge307XG4gIHRoaXMuX291dFt2XSA9IHt9O1xuICB0aGlzLl9zdWNzW3ZdID0ge307XG4gICsrdGhpcy5fbm9kZUNvdW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX25vZGVzLCB2KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gIGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgdmFyIHJlbW92ZUVkZ2UgPSBmdW5jdGlvbihlKSB7IHNlbGYucmVtb3ZlRWRnZShzZWxmLl9lZGdlT2Jqc1tlXSk7IH07XG4gICAgZGVsZXRlIHRoaXMuX25vZGVzW3ZdO1xuICAgIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdl07XG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbih2KSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgc2VsZi5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgfVxuICAgIF8uZWFjaChfLmtleXModGhpcy5faW5bdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5faW5bdl07XG4gICAgZGVsZXRlIHRoaXMuX3ByZWRzW3ZdO1xuICAgIF8uZWFjaChfLmtleXModGhpcy5fb3V0W3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XTtcbiAgICBkZWxldGUgdGhpcy5fc3Vjc1t2XTtcbiAgICAtLXRoaXMuX25vZGVDb3VudDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbih2LCBwYXJlbnQpIHtcbiAgaWYgKCF0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQgaW4gYSBub24tY29tcG91bmQgZ3JhcGhcIik7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gR1JBUEhfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2UgcGFyZW50IHRvIHN0cmluZ1xuICAgIHBhcmVudCArPSBcIlwiO1xuICAgIGZvciAodmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgIV8uaXNVbmRlZmluZWQoYW5jZXN0b3IpO1xuICAgICAgYW5jZXN0b3IgPSB0aGlzLnBhcmVudChhbmNlc3RvcikpIHtcbiAgICAgIGlmIChhbmNlc3RvciA9PT0gdikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIFwiICsgcGFyZW50KyBcIiBhcyBwYXJlbnQgb2YgXCIgKyB2ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdvdWxkIGNyZWF0ZSBhIGN5Y2xlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Tm9kZShwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgdGhpcy5fcGFyZW50W3ZdID0gcGFyZW50O1xuICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdW3ZdID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0ID0gZnVuY3Rpb24odikge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdGhpcy5fcGFyZW50W3ZdXVt2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudFt2XTtcbiAgICBpZiAocGFyZW50ICE9PSBHUkFQSF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24odikge1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2KSkge1xuICAgIHYgPSBHUkFQSF9OT0RFO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBfLmtleXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSBHUkFQSF9OT0RFKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc05vZGUodikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkc1YgPSB0aGlzLl9wcmVkc1t2XTtcbiAgaWYgKHByZWRzVikge1xuICAgIHJldHVybiBfLmtleXMocHJlZHNWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBzdWNzViA9IHRoaXMuX3N1Y3Nbdl07XG4gIGlmIChzdWNzVikge1xuICAgIHJldHVybiBfLmtleXMoc3Vjc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHMgPSB0aGlzLnByZWRlY2Vzc29ycyh2KTtcbiAgaWYgKHByZWRzKSB7XG4gICAgcmV0dXJuIF8udW5pb24ocHJlZHMsIHRoaXMuc3VjY2Vzc29ycyh2KSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAodikge1xuICB2YXIgbmVpZ2hib3JzO1xuICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLnN1Y2Nlc3NvcnModik7XG4gIH0gZWxzZSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnModik7XG4gIH1cbiAgcmV0dXJuIG5laWdoYm9ycy5sZW5ndGggPT09IDA7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgZGlyZWN0ZWQ6IHRoaXMuX2lzRGlyZWN0ZWQsXG4gICAgbXVsdGlncmFwaDogdGhpcy5faXNNdWx0aWdyYXBoLFxuICAgIGNvbXBvdW5kOiB0aGlzLl9pc0NvbXBvdW5kXG4gIH0pO1xuXG4gIGNvcHkuc2V0R3JhcGgodGhpcy5ncmFwaCgpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24odmFsdWUsIHYpIHtcbiAgICBpZiAoZmlsdGVyKHYpKSB7XG4gICAgICBjb3B5LnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5lYWNoKHRoaXMuX2VkZ2VPYmpzLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvcHkuaGFzTm9kZShlLnYpICYmIGNvcHkuaGFzTm9kZShlLncpKSB7XG4gICAgICBjb3B5LnNldEVkZ2UoZSwgc2VsZi5lZGdlKGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXJlbnRzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnQodikge1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudCh2KTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgY29weS5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudHNbdl0gPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluIHBhcmVudHMpIHtcbiAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICBfLmVhY2goY29weS5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgICBjb3B5LnNldFBhcmVudCh2LCBmaW5kUGFyZW50KHYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxuLyogPT09IEVkZ2UgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRFZGdlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX2VkZ2VPYmpzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8ucmVkdWNlKHZzLCBmdW5jdGlvbih2LCB3KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHNldEVkZ2UodiwgdywgW3ZhbHVlLCBbbmFtZV1dKVxuICogc2V0RWRnZSh7IHYsIHcsIFtuYW1lXSB9LCBbdmFsdWVdKVxuICovXG5HcmFwaC5wcm90b3R5cGUuc2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiwgdywgbmFtZSwgdmFsdWU7XG4gIHZhciB2YWx1ZVNwZWNpZmllZCA9IGZhbHNlO1xuICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAodHlwZW9mIGFyZzAgPT09IFwib2JqZWN0XCIgJiYgYXJnMCAhPT0gbnVsbCAmJiBcInZcIiBpbiBhcmcwKSB7XG4gICAgdiA9IGFyZzAudjtcbiAgICB3ID0gYXJnMC53O1xuICAgIG5hbWUgPSBhcmcwLm5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gYXJnMDtcbiAgICB3ID0gYXJndW1lbnRzWzFdO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2ID0gXCJcIiArIHY7XG4gIHcgPSBcIlwiICsgdztcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiXCIgKyBuYW1lO1xuICB9XG5cbiAgdmFyIGUgPSBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIGlmIChfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKSkge1xuICAgIGlmICh2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSAmJiAhdGhpcy5faXNNdWx0aWdyYXBoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBhIG5hbWVkIGVkZ2Ugd2hlbiBpc011bHRpZ3JhcGggPSBmYWxzZVwiKTtcbiAgfVxuXG4gIC8vIEl0IGRpZG4ndCBleGlzdCwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQuXG4gIC8vIEZpcnN0IGVuc3VyZSB0aGUgbm9kZXMgZXhpc3QuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5zZXROb2RlKHcpO1xuXG4gIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZVNwZWNpZmllZCA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuKHYsIHcsIG5hbWUpO1xuXG4gIHZhciBlZGdlT2JqID0gZWRnZUFyZ3NUb09iaih0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgLy8gRW5zdXJlIHdlIGFkZCB1bmRpcmVjdGVkIGVkZ2VzIGluIGEgY29uc2lzdGVudCB3YXkuXG4gIHYgPSBlZGdlT2JqLnY7XG4gIHcgPSBlZGdlT2JqLnc7XG5cbiAgT2JqZWN0LmZyZWV6ZShlZGdlT2JqKTtcbiAgdGhpcy5fZWRnZU9ianNbZV0gPSBlZGdlT2JqO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICB0aGlzLl9pblt3XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX291dFt2XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX2VkZ2VDb3VudCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gdGhpcy5fZWRnZUxhYmVsc1tlXTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgaWYgKGVkZ2UpIHtcbiAgICB2ID0gZWRnZS52O1xuICAgIHcgPSBlZGdlLnc7XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VPYmpzW2VdO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ddW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl1bZV07XG4gICAgdGhpcy5fZWRnZUNvdW50LS07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaW5FZGdlcyA9IGZ1bmN0aW9uKHYsIHUpIHtcbiAgdmFyIGluViA9IHRoaXMuX2luW3ZdO1xuICBpZiAoaW5WKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMoaW5WKTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLnYgPT09IHU7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBvdXRWID0gdGhpcy5fb3V0W3ZdO1xuICBpZiAob3V0Vikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKG91dFYpO1xuICAgIGlmICghdykge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudyA9PT0gdzsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlRWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBpbkVkZ2VzID0gdGhpcy5pbkVkZ2VzKHYsIHcpO1xuICBpZiAoaW5FZGdlcykge1xuICAgIHJldHVybiBpbkVkZ2VzLmNvbmNhdCh0aGlzLm91dEVkZ2VzKHYsIHcpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5jcmVtZW50T3JJbml0RW50cnkobWFwLCBrKSB7XG4gIGlmIChtYXBba10pIHtcbiAgICBtYXBba10rKztcbiAgfSBlbHNlIHtcbiAgICBtYXBba10gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkobWFwLCBrKSB7XG4gIGlmICghLS1tYXBba10pIHsgZGVsZXRlIG1hcFtrXTsgfVxufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gdiArIEVER0VfS0VZX0RFTElNICsgdyArIEVER0VfS0VZX0RFTElNICtcbiAgICAgICAgICAgICAoXy5pc1VuZGVmaW5lZChuYW1lKSA/IERFRkFVTFRfRURHRV9OQU1FIDogbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9PYmooaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICB2YXIgZWRnZU9iaiA9ICB7IHY6IHYsIHc6IHcgfTtcbiAgaWYgKG5hbWUpIHtcbiAgICBlZGdlT2JqLm5hbWUgPSBuYW1lO1xuICB9XG4gIHJldHVybiBlZGdlT2JqO1xufVxuXG5mdW5jdGlvbiBlZGdlT2JqVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqKSB7XG4gIHJldHVybiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgZWRnZU9iai52LCBlZGdlT2JqLncsIGVkZ2VPYmoubmFtZSk7XG59XG4iLCIvLyBJbmNsdWRlcyBvbmx5IHRoZSBcImNvcmVcIiBvZiBncmFwaGxpYlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiByZXF1aXJlKFwiLi9ncmFwaFwiKSxcbiAgdmVyc2lvbjogcmVxdWlyZShcIi4vdmVyc2lvblwiKVxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cml0ZTogd3JpdGUsXG4gIHJlYWQ6IHJlYWRcbn07XG5cbmZ1bmN0aW9uIHdyaXRlKGcpIHtcbiAgdmFyIGpzb24gPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgZGlyZWN0ZWQ6IGcuaXNEaXJlY3RlZCgpLFxuICAgICAgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSxcbiAgICAgIGNvbXBvdW5kOiBnLmlzQ29tcG91bmQoKVxuICAgIH0sXG4gICAgbm9kZXM6IHdyaXRlTm9kZXMoZyksXG4gICAgZWRnZXM6IHdyaXRlRWRnZXMoZylcbiAgfTtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKGcuZ3JhcGgoKSkpIHtcbiAgICBqc29uLnZhbHVlID0gXy5jbG9uZShnLmdyYXBoKCkpO1xuICB9XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB3cml0ZU5vZGVzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlVmFsdWUgPSBnLm5vZGUodik7XG4gICAgdmFyIHBhcmVudCA9IGcucGFyZW50KHYpO1xuICAgIHZhciBub2RlID0geyB2OiB2IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVkZ2VzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlVmFsdWUgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIGVkZ2UgPSB7IHY6IGUudiwgdzogZS53IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGUubmFtZSkpIHtcbiAgICAgIGVkZ2UubmFtZSA9IGUubmFtZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVkZ2VWYWx1ZSkpIHtcbiAgICAgIGVkZ2UudmFsdWUgPSBlZGdlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZChqc29uKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKGpzb24ub3B0aW9ucykuc2V0R3JhcGgoanNvbi52YWx1ZSk7XG4gIF8uZWFjaChqc29uLm5vZGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0Tm9kZShlbnRyeS52LCBlbnRyeS52YWx1ZSk7XG4gICAgaWYgKGVudHJ5LnBhcmVudCkge1xuICAgICAgZy5zZXRQYXJlbnQoZW50cnkudiwgZW50cnkucGFyZW50KTtcbiAgICB9XG4gIH0pO1xuICBfLmVhY2goanNvbi5lZGdlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldEVkZ2UoeyB2OiBlbnRyeS52LCB3OiBlbnRyeS53LCBuYW1lOiBlbnRyeS5uYW1lIH0sIGVudHJ5LnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgaGFzOiAgcmVxdWlyZShcImxvZGFzaC9oYXNcIiksXG4gICAgICBpc0FycmF5OiByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksXG4gICAgICBpc0VtcHR5OiByZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIiksXG4gICAgICBpc0Z1bmN0aW9uOiByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksXG4gICAgICBpc1VuZGVmaW5lZDogcmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSxcbiAgICAgIGtleXM6IHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSxcbiAgICAgIG1hcDogcmVxdWlyZShcImxvZGFzaC9tYXBcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc2l6ZTogcmVxdWlyZShcImxvZGFzaC9zaXplXCIpLFxuICAgICAgdHJhbnNmb3JtOiByZXF1aXJlKFwibG9kYXNoL3RyYW5zZm9ybVwiKSxcbiAgICAgIHVuaW9uOiByZXF1aXJlKFwibG9kYXNoL3VuaW9uXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFsb2Rhc2gpIHtcbiAgbG9kYXNoID0gd2luZG93Ll87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9kYXNoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMi4xLjgnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRlc3QgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1Byb3RvKCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yOiBUUyBlcnJvcnMgb24gYW4gaW5oZXJpdGVkIHByb3BlcnR5IGZvciBzb21lIHJlYXNvblxuXHRyZXR1cm4geyBfX3Byb3RvX186IHRlc3QgfS5mb28gPT09IHRlc3QuZm9vXG5cdFx0JiYgISh0ZXN0IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKGNhbGwsICRoYXNPd24pO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpU2l6ZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc01hcCA9IHJlcXVpcmUoJy4vaXNNYXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1NldCA9IHJlcXVpcmUoJy4vaXNTZXQnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGFzY2lpU2l6ZSA9IHJlcXVpcmUoJy4vX2FzY2lpU2l6ZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVNpemUgPSByZXF1aXJlKCcuL191bmljb2RlU2l6ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdTaXplO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICArK3Jlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVTaXplO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXMob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob3RoZXIsICdhJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjE1JztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gICAgICAvLyB3aXRoIGxvb2t1cCAoaW4gY2FzZSBvZiBlLmcuIHByb3RvdHlwZSBwb2xsdXRpb24pLCBhbmQgc3RyaXAgbmV3bGluZXMgaWYgYW55LlxuICAgICAgLy8gQSBuZXdsaW5lIHdvdWxkbid0IGJlIGEgdmFsaWQgc291cmNlVVJMIGFueXdheSwgYW5kIGl0J2QgZW5hYmxlIGNvZGUgaW5qZWN0aW9uLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICAgICAgICA/IChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgICAgIC8vIGFzIHRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGNvZGUgaW5qZWN0aW9uIHZlY3Rvci5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlUmVkdWNlID0gcmVxdWlyZSgnLi9fYmFzZVJlZHVjZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICogYW5kIGBzb3J0QnlgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gKiAgIHJldHVybiBzdW0gKyBuO1xuICogfSwgMCk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG4iLCJ2YXIgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9pc1N0cmluZycpLFxuICAgIHN0cmluZ1NpemUgPSByZXF1aXJlKCcuL19zdHJpbmdTaXplJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAqIC8vID0+IDdcbiAqL1xuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gIH1cbiAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaXplO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0sIFtdKTtcbiAqIC8vID0+IFs0LCA5XVxuICpcbiAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgIH1cbiAgfVxuICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbnZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG4iLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcbiIsIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgc3VwcG9ydGVkTG9hZGVycyA9IHtcclxuICBmaWxlOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2ZpbGUnKSxcclxuICBodHRwOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2h0dHAnKSxcclxuICBodHRwczogcmVxdWlyZSgnLi9saWIvbG9hZGVycy9odHRwJylcclxufTtcclxudmFyIGRlZmF1bHRMb2FkZXIgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgIHN1cHBvcnRlZExvYWRlcnMuaHR0cCA6XHJcbiAgICAgIHN1cHBvcnRlZExvYWRlcnMuZmlsZTtcclxuXHJcbi8vIExvYWQgcHJvbWlzZXMgcG9seWZpbGwgaWYgbmVjZXNzYXJ5XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY2hlbWUgKGxvY2F0aW9uKSB7XHJcbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGxvY2F0aW9uID0gbG9jYXRpb24uaW5kZXhPZignOi8vJykgPT09IC0xID8gJycgOiBsb2NhdGlvbi5zcGxpdCgnOi8vJylbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbG9jYXRpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IHRoYXQgcHJvdmlkZXMgYSBzaW5nbGUgQVBJIGZvciBsb2FkaW5nIHRoZSBjb250ZW50IG9mIGEgcGF0aC9VUkwuXHJcbiAqXHJcbiAqIEBtb2R1bGUgcGF0aC1sb2FkZXJcclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRMb2FkZXIgKGxvY2F0aW9uKSB7XHJcbiAgdmFyIHNjaGVtZSA9IGdldFNjaGVtZShsb2NhdGlvbik7XHJcbiAgdmFyIGxvYWRlciA9IHN1cHBvcnRlZExvYWRlcnNbc2NoZW1lXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBsb2FkZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAoc2NoZW1lID09PSAnJykge1xyXG4gICAgICBsb2FkZXIgPSBkZWZhdWx0TG9hZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzY2hlbWU6ICcgKyBzY2hlbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxvYWRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIGEgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uIGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVwcmVzZW50YXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byB0aGUgZG9jdW1lbnRcclxuICogQHBhcmFtIHttb2R1bGU6cGF0aC1sb2FkZXIuTG9hZE9wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBsb2FkZXIgb3B0aW9uc1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gQWx3YXlzIHJldHVybnMgYSBwcm9taXNlIGV2ZW4gaWYgdGhlcmUgaXMgYSBjYWxsYmFjayBwcm92aWRlZFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIHVzaW5nIFByb21pc2VzXHJcbiAqXHJcbiAqIFBhdGhMb2FkZXJcclxuICogICAubG9hZCgnLi9wYWNrYWdlLmpzb24nKVxyXG4gKiAgIC50aGVuKEpTT04ucGFyc2UpXHJcbiAqICAgLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhkb2N1bWVudC5uYW1lICsgJyAoJyArIGRvY3VtZW50LnZlcnNpb24gKyAnKTogJyArIGRvY3VtZW50LmRlc2NyaXB0aW9uKTtcclxuICogICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAqICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XHJcbiAqICAgfSk7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEV4YW1wbGUgdXNpbmcgb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCB0byBwcm92aWRlIGF1dGhlbnRpY2F0aW9uIGRldGFpbHMgZm9yIGEgcmVtb3RlbHkgc2VjdXJlIFVSTFxyXG4gKlxyXG4gKiBQYXRoTG9hZGVyXHJcbiAqICAgLmxvYWQoJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3Mvd2hpdGxvY2tqYy9wYXRoLWxvYWRlcicsIHtcclxuICogICAgIHByZXBhcmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxLCBjYWxsYmFjaykge1xyXG4gKiAgICAgICByZXEuYXV0aCgnbXktdXNlcm5hbWUnLCAnbXktcGFzc3dvcmQnKTtcclxuICogICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXEpO1xyXG4gKiAgICAgfVxyXG4gKiAgIH0pXHJcbiAqICAgLnRoZW4oSlNPTi5wYXJzZSlcclxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcclxuICogICAgIGNvbnNvbGUubG9nKGRvY3VtZW50LmZ1bGxfbmFtZSArICc6ICcgKyBkb2N1bWVudC5kZXNjcmlwdGlvbik7XHJcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIGxvYWRpbmcgYSBZQU1MIGZpbGVcclxuICpcclxuICogUGF0aExvYWRlclxyXG4gKiAgIC5sb2FkKCcvVXNlcnMvbm90LXlvdS9wcm9qZWN0cy9wYXRoLWxvYWRlci8udHJhdmlzLnltbCcpXHJcbiAqICAgLnRoZW4oWUFNTC5zYWZlTG9hZClcclxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcclxuICogICAgIGNvbnNvbGUubG9nKCdwYXRoLWxvYWRlciB1c2VzIHRoZScsIGRvY3VtZW50Lmxhbmd1YWdlLCAnbGFuZ3VhZ2UuJyk7XHJcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBFeGFtcGxlIGxvYWRpbmcgYSBZQU1MIGZpbGUgd2l0aCBvcHRpb25zLnByb2Nlc3NDb250ZW50IChVc2VmdWwgaWYgeW91IG5lZWQgaW5mb3JtYXRpb24gaW4gdGhlIHJhdyByZXNwb25zZSlcclxuICpcclxuICogUGF0aExvYWRlclxyXG4gKiAgIC5sb2FkKCcvVXNlcnMvbm90LXlvdS9wcm9qZWN0cy9wYXRoLWxvYWRlci8udHJhdmlzLnltbCcsIHtcclxuICogICAgIHByb2Nlc3NDb250ZW50OiBmdW5jdGlvbiAocmVzLCBjYWxsYmFjaykge1xyXG4gKiAgICAgICBjYWxsYmFjayhZQU1MLnNhZmVMb2FkKHJlcy50ZXh0KSk7XHJcbiAqICAgICB9XHJcbiAqICAgfSlcclxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcclxuICogICAgIGNvbnNvbGUubG9nKCdwYXRoLWxvYWRlciB1c2VzIHRoZScsIGRvY3VtZW50Lmxhbmd1YWdlLCAnbGFuZ3VhZ2UuJyk7XHJcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xyXG4gKiAgIH0pO1xyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucykge1xyXG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5cclxuICAvLyBEZWZhdWx0IG9wdGlvbnMgdG8gZW1wdHkgb2JqZWN0XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXHJcbiAgYWxsVGFza3MgPSBhbGxUYXNrcy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xvY2F0aW9uIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbG9jYXRpb24gbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm9jZXNzQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnByb2Nlc3NDb250ZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIExvYWQgdGhlIGRvY3VtZW50IGZyb20gdGhlIHByb3ZpZGVkIGxvY2F0aW9uIGFuZCBwcm9jZXNzIGl0XHJcbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xyXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBsb2FkZXIgPSBnZXRMb2FkZXIobG9jYXRpb24pO1xyXG5cclxuICAgICAgICBsb2FkZXIubG9hZChsb2NhdGlvbiwgb3B0aW9ucyB8fCB7fSwgZnVuY3Rpb24gKGVyciwgZG9jdW1lbnQpIHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKGRvY3VtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICBpZiAob3B0aW9ucy5wcm9jZXNzQ29udGVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAvLyBGb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBmaWxlIGFuZCBodHRwLCBhbHdheXMgc2VuZCBhbiBvYmplY3Qgd2l0aCBhICd0ZXh0JyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSByYXdcclxuICAgICAgICAgIC8vIHN0cmluZyB2YWx1ZSBiZWluZyBwcm9jZXNzZWQuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmVzID0ge3RleHQ6IHJlc307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUGFzcyB0aGUgcGF0aCBiZWluZyBsb2FkZWRcclxuICAgICAgICAgIHJlcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG5cclxuICAgICAgICAgIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQocmVzLCBmdW5jdGlvbiAoZXJyLCBwcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUocHJvY2Vzc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIGNvbnRlbnQgcHJvY2Vzc29yLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IGZvciBhbGwgb2JqZWN0cyB0aGF0IGl0IGlzIGEgU3VwZXJhZ2VudCByZXNwb25zZVxyXG4gICAgICAgIC8vIGFuZCB3aWxsIHJldHVybiBpdHMgYHRleHRgIHByb3BlcnR5IHZhbHVlLiAgT3RoZXJ3aXNlLCB3ZSB3aWxsIHJldHVybiB0aGUgcmF3IHJlc3BvbnNlLlxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyA/IHJlcy50ZXh0IDogcmVzO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgcmV0dXJuIGFsbFRhc2tzO1xyXG59O1xyXG4iLCIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IEplcmVteSBXaGl0bG9ja1xyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHVuc3VwcG9ydGVkRXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUaGUgXFwnZmlsZVxcJyBzY2hlbWUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBmaWxlIGxvYWRlciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyLlxyXG4gKlxyXG4gKiBAdGhyb3dzIHtlcnJvcn0gdGhlIGZpbGUgbG9hZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXJcclxuICovXHJcbm1vZHVsZS5leHBvcnRzLmdldEJhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhyb3cgdW5zdXBwb3J0ZWRFcnJvcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZmlsZSBsb2FkZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlci5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgZm4odW5zdXBwb3J0ZWRFcnJvcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IHVuc3VwcG9ydGVkRXJyb3I7XHJcbiAgfVxyXG59O1xyXG4iLCIvKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cclxuXHJcbi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcclxuXHJcbnZhciBzdXBwb3J0ZWRIdHRwTWV0aG9kcyA9IFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3BhdGNoJywgJ3Bvc3QnLCAncHV0J107XHJcblxyXG4vKipcclxuICogTG9hZHMgYSBmaWxlIGZyb20gYW4gaHR0cCBvciBodHRwcyBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSBkb2N1bWVudCBVUkwgKElmIHJlbGF0aXZlLCBsb2NhdGlvbiBpcyByZWxhdGl2ZSB0byB3aW5kb3cubG9jYXRpb24ub3JpZ2luKS5cclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgbG9hZGVyIG9wdGlvbnNcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIC0gVGhlIEhUVFAgbWV0aG9kIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcclxuICogQHBhcmFtIHttb2R1bGU6UGF0aExvYWRlcn5QcmVwYXJlUmVxdWVzdENhbGxiYWNrfSBbb3B0aW9ucy5wcmVwYXJlUmVxdWVzdF0gLSBUaGUgY2FsbGJhY2sgdXNlZCB0byBwcmVwYXJlIGEgcmVxdWVzdFxyXG4gKiBAcGFyYW0ge21vZHVsZTpQYXRoTG9hZGVyflByb2Nlc3NSZXNwb25zZUNhbGxiYWNrfSBbb3B0aW9ucy5wcm9jZXNzQ29udGVudF0gLSBUaGUgY2FsbGJhY2sgdXNlZCB0byBwcm9jZXNzIHRoZVxyXG4gKiByZXNwb25zZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBlcnJvci1maXJzdCBjYWxsYmFja1xyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICB2YXIgcmVhbE1ldGhvZCA9IG9wdGlvbnMubWV0aG9kID8gb3B0aW9ucy5tZXRob2QudG9Mb3dlckNhc2UoKSA6ICdnZXQnO1xyXG4gIHZhciBlcnI7XHJcbiAgdmFyIHJlYWxSZXF1ZXN0O1xyXG5cclxuICBmdW5jdGlvbiBtYWtlUmVxdWVzdCAoZXJyLCByZXEpIHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGJ1ZmZlcigpIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGUuanNcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyAmJlxyXG4gICAgICAgICAgdHlwZW9mIHJlcS5idWZmZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXEuYnVmZmVyKHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXFcclxuICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIyLCByZXMpIHtcclxuICAgICAgICAgIGlmIChlcnIyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycjIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXRob2QgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGVyciA9IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkSHR0cE1ldGhvZHMuaW5kZXhPZihvcHRpb25zLm1ldGhvZCkgPT09IC0xKSB7XHJcbiAgICAgIGVyciA9IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubWV0aG9kIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6ICcgK1xyXG4gICAgICAgIHN1cHBvcnRlZEh0dHBNZXRob2RzLnNsaWNlKDAsIHN1cHBvcnRlZEh0dHBNZXRob2RzLmxlbmd0aCAtIDEpLmpvaW4oJywgJykgKyAnIG9yICcgK1xyXG4gICAgICAgIHN1cHBvcnRlZEh0dHBNZXRob2RzW3N1cHBvcnRlZEh0dHBNZXRob2RzLmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnByZXBhcmVSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgZXJyID0gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICB9XHJcblxyXG4gIGlmICghZXJyKSB7XHJcbiAgICByZWFsUmVxdWVzdCA9IHJlcXVlc3RbcmVhbE1ldGhvZCA9PT0gJ2RlbGV0ZScgPyAnZGVsJyA6IHJlYWxNZXRob2RdKGxvY2F0aW9uKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5wcmVwYXJlUmVxdWVzdCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG9wdGlvbnMucHJlcGFyZVJlcXVlc3QocmVhbFJlcXVlc3QsIG1ha2VSZXF1ZXN0KTtcclxuICAgICAgfSBjYXRjaCAoZXJyMikge1xyXG4gICAgICAgIGNhbGxiYWNrKGVycjIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYWtlUmVxdWVzdCh1bmRlZmluZWQsIHJlYWxSZXF1ZXN0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY2FsbGJhY2soZXJyKTtcclxuICB9XHJcbn07XHJcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsImNvbnN0IGRlZmF1bHRzID0gW1xuICAndXNlJyxcbiAgJ29uJyxcbiAgJ29uY2UnLFxuICAnc2V0JyxcbiAgJ3F1ZXJ5JyxcbiAgJ3R5cGUnLFxuICAnYWNjZXB0JyxcbiAgJ2F1dGgnLFxuICAnd2l0aENyZWRlbnRpYWxzJyxcbiAgJ3NvcnRRdWVyeScsXG4gICdyZXRyeScsXG4gICdvaycsXG4gICdyZWRpcmVjdHMnLFxuICAndGltZW91dCcsXG4gICdidWZmZXInLFxuICAnc2VyaWFsaXplJyxcbiAgJ3BhcnNlJyxcbiAgJ2NhJyxcbiAgJ2tleScsXG4gICdwZngnLFxuICAnY2VydCcsXG4gICdkaXNhYmxlVExTQ2VydHMnXG5dXG5cbmNsYXNzIEFnZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2RlZmF1bHRzID0gW107XG4gIH1cblxuICBfc2V0RGVmYXVsdHMgKHJlcXVlc3QpIHtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLl9kZWZhdWx0cykge1xuICAgICAgcmVxdWVzdFtkZWYuZm5dKC4uLmRlZi5hcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZm9yIChjb25zdCBmbiBvZiBkZWZhdWx0cykge1xuICAvLyBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnRcbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7IGZuLCBhcmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iLCIvKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbmxldCByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykge1xuICAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFxuICAgICdVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50J1xuICApO1xuICByb290ID0gdGhpcztcbn0gZWxzZSB7XG4gIC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59XG5cbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuY29uc3Qgc2FmZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknKTtcbmNvbnN0IHFzID0gcmVxdWlyZSgncXMnKTtcbmNvbnN0IFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbmNvbnN0IHsgaXNPYmplY3QsIG1peGluLCBoYXNPd24gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IFJlc3BvbnNlQmFzZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UtYmFzZScpO1xuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzO1xuXG5jb25zdCByZXF1ZXN0ID0gZXhwb3J0cztcblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gKCkgPT4ge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgcm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUicpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltID8gKHMpID0+IHMudHJpbSgpIDogKHMpID0+IHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkgcmV0dXJuIG9iamVjdDtcbiAgY29uc3QgcGFpcnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093bihvYmplY3QsIGtleSkpIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9iamVjdFtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUkkoa2V5KSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBzdWJrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChoYXNPd24odmFsdWUsIHN1YmtleSkpXG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBgJHtrZXl9WyR7c3Via2V5fV1gLCB2YWx1ZVtzdWJrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUkkoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyaW5nXykge1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgY29uc3QgcGFpcnMgPSBzdHJpbmdfLnNwbGl0KCcmJyk7XG4gIGxldCBwYWlyO1xuICBsZXQgcG9zO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGhfID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuZ3RoXzsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICBvYmplY3RbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID0gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBwYWlyLnNsaWNlKHBvcyArIDEpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICBmb3JtOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHFzLnN0cmluZ2lmeShvYmosIHsgaW5kaWNlczogZmFsc2UsIHN0cmljdE51bGxIYW5kbGluZzogdHJ1ZSB9KTtcbiAgfSxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBzYWZlU3RyaW5naWZ5XG59O1xuXG4vKipcbiAqIERlZmF1bHQgcGFyc2Vycy5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyaW5nXykge1xuICBjb25zdCBsaW5lcyA9IHN0cmluZ18uc3BsaXQoL1xccj9cXG4vKTtcbiAgY29uc3QgZmllbGRzID0ge307XG4gIGxldCBpbmRleDtcbiAgbGV0IGxpbmU7XG4gIGxldCBmaWVsZDtcbiAgbGV0IHZhbHVlO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGhfID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuZ3RoXzsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvWy8rXWpzb24oJHxbXi1cXHddKS9pLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcXVlc3RfKSB7XG4gIHRoaXMucmVxID0gcmVxdWVzdF87XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9XG4gICAgKHRoaXMucmVxLm1ldGhvZCAhPT0gJ0hFQUQnICYmXG4gICAgICAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8XG4gICAgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICBsZXQgeyBzdGF0dXMgfSA9IHRoaXMueGhyO1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnM7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAodGhpcy50ZXh0ID09PSBudWxsICYmIHJlcXVlc3RfLl9yZXNwb25zZVR5cGUpIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJvZHkgPVxuICAgICAgdGhpcy5yZXEubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgfVxufVxuXG5taXhpbihSZXNwb25zZS5wcm90b3R5cGUsIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbiAoc3RyaW5nXykge1xuICBsZXQgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyaW5nXyk7XG4gIH1cblxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cblxuICByZXR1cm4gcGFyc2UgJiYgc3RyaW5nXyAmJiAoc3RyaW5nXy5sZW5ndGggPiAwIHx8IHN0cmluZ18gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHJpbmdfKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHsgcmVxIH0gPSB0aGlzO1xuICBjb25zdCB7IG1ldGhvZCB9ID0gcmVxO1xuICBjb25zdCB7IHVybCB9ID0gcmVxO1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBgY2Fubm90ICR7bWV0aG9kfSAke3VybH0gKCR7dGhpcy5zdGF0dXN9KWA7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyb3IubWV0aG9kID0gbWV0aG9kO1xuICBlcnJvci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycm9yO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGxldCByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyb3IucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyb3Iub3JpZ2luYWwgPSBlcnI7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnJvci5yYXdSZXNwb25zZSA9XG4gICAgICAgICAgdHlwZW9mIHNlbGYueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gc2VsZi54aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICA6IHNlbGYueGhyLnJlc3BvbnNlO1xuICAgICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgZXJyb3Iuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGVycm9yLnN0YXR1czsgLy8gYmFja3dhcmRzLWNvbXBhdCBvbmx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVycm9yLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIGxldCBuZXdfZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2Vycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgIHJlcy5zdGF0dXNUZXh0IHx8IHJlcy50ZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG5ld19lcnJvciA9IGVycjsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9XG5cbiAgICAvLyAjMTAwMCBkb24ndCBjYXRjaCBlcnJvcnMgZnJvbSB0aGUgY2FsbGJhY2sgdG8gYXZvaWQgZG91YmxlIGNhbGxpbmcgaXRcbiAgICBpZiAobmV3X2Vycm9yKSB7XG4gICAgICBuZXdfZXJyb3Iub3JpZ2luYWwgPSBlcnJvcjtcbiAgICAgIG5ld19lcnJvci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnJvci5zdGF0dXMgPSBuZXdfZXJyb3Iuc3RhdHVzIHx8IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnJvciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxubWl4aW4oUmVxdWVzdC5wcm90b3R5cGUsIFJlcXVlc3RCYXNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7XG4gICAgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJyA/ICdiYXNpYycgOiAnYXV0bydcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZW5jb2RlciA9IG9wdGlvbnMuZW5jb2RlclxuICAgID8gb3B0aW9ucy5lbmNvZGVyXG4gICAgOiAoc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBidG9hKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHZhbHVlID0gc2VyaWFsaXplKHZhbHVlKTtcbiAgaWYgKHZhbHVlKSB0aGlzLl9xdWVyeS5wdXNoKHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChmaWVsZCwgZmlsZSwgb3B0aW9ucykge1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvciwgcmVzKSB7XG4gIGlmICh0aGlzLl9zaG91bGRSZXRyeShlcnJvciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyb3IucmV0cmllcyA9IHRoaXMuX3JldHJpZXMgLSAxO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmbihlcnJvciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nXG4gICk7XG4gIGVycm9yLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnJvci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyb3IubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVycm9yLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyb3IpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS53YXJuKCdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50O1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2E7XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudCdcbiAgKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGhvc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpcyBhIGhvc3Qgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAhQXJyYXkuaXNBcnJheShvYmplY3QpICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgIT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICk7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnQnXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9zZXRVcGxvYWRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyB1cGxvYWQgdGltZW91dCBpdCdzIHdva3JzIG9ubHkgaWYgZGVhZGxpbmUgdGltZW91dCBpcyBvZmZcbiAgaWYgKHRoaXMuX3VwbG9hZFRpbWVvdXQgJiYgIXRoaXMuX3VwbG9hZFRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3VwbG9hZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKFxuICAgICAgICAnVXBsb2FkIHRpbWVvdXQgb2YgJyxcbiAgICAgICAgc2VsZi5fdXBsb2FkVGltZW91dCxcbiAgICAgICAgJ0VUSU1FRE9VVCdcbiAgICAgICk7XG4gICAgfSwgdGhpcy5fdXBsb2FkVGltZW91dCk7XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5SZXF1ZXN0LnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYWJvcnRlZClcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhcbiAgICAgIG5ldyBFcnJvcignVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZCcpXG4gICAgKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpO1xuICBjb25zdCB7IHhociB9ID0gdGhpcztcbiAgbGV0IGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVhZHlTdGF0ZSB9ID0geGhyO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuXG4gICAgaWYgKHJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgbGV0IHN0YXR1cztcbiAgICB0cnkge1xuICAgICAgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN0YXR1cyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9KTtcblxuICAvLyBwcm9ncmVzc1xuICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChkaXJlY3Rpb24sIGUpID0+IHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IChlLmxvYWRlZCAvIGUudG90YWwpICogMTAwO1xuXG4gICAgICBpZiAoZS5wZXJjZW50ID09PSAxMDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3VwbG9hZFRpbWVvdXRUaW1lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuXG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAgIGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIGlmICh4aHIudXBsb2FkKSB7XG4gICAgdGhpcy5fc2V0VXBsb2FkVGltZW91dCgpO1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmIChcbiAgICAhdGhpcy5fZm9ybURhdGEgJiZcbiAgICB0aGlzLm1ldGhvZCAhPT0gJ0dFVCcgJiZcbiAgICB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnICYmXG4gICAgdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmXG4gICAgIXRoaXMuX2lzSG9zdChkYXRhKVxuICApIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgbGV0IHNlcmlhbGl6ZSA9XG4gICAgICB0aGlzLl9zZXJpYWxpemVyIHx8XG4gICAgICByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG5cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yIChjb25zdCBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmICh0aGlzLmhlYWRlcltmaWVsZF0gPT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGhhc093bih0aGlzLmhlYWRlciwgZmllbGQpKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRhdGEpO1xufTtcblxucmVxdWVzdC5hZ2VudCA9ICgpID0+IG5ldyBBZ2VudCgpO1xuXG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ0dFVCcsICdQT1NUJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUFVUJywgJ0RFTEVURSddKSB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAodXJsLCBmbikge1xuICAgIGNvbnN0IHJlcXVlc3RfID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxdWVzdF8pO1xuICAgIGlmIChmbikge1xuICAgICAgcmVxdWVzdF8uZW5kKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdF87XG4gIH07XG59XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGUuZGVsZXRlO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxdWVzdF8gPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSkgcmVxdWVzdF8ucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxdWVzdF8uZW5kKGZuKTtcbiAgcmV0dXJuIHJlcXVlc3RfO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxdWVzdF8gPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgaWYgKGRhdGEpIHJlcXVlc3RfLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcXVlc3RfLmVuZChmbik7XG4gIHJldHVybiByZXF1ZXN0Xztcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RfID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXF1ZXN0Xy5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcXVlc3RfLmVuZChmbik7XG4gIHJldHVybiByZXF1ZXN0Xztcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXF1ZXN0XyA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXF1ZXN0Xy5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcXVlc3RfLmVuZChmbik7XG4gIHJldHVybiByZXF1ZXN0Xztcbn1cblxucmVxdWVzdC5kZWwgPSBkZWw7XG5yZXF1ZXN0LmRlbGV0ZSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RfID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSkgcmVxdWVzdF8uc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXF1ZXN0Xy5lbmQoZm4pO1xuICByZXR1cm4gcmVxdWVzdF87XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RfID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXF1ZXN0Xy5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcXVlc3RfLmVuZChmbik7XG4gIHJldHVybiByZXF1ZXN0Xztcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RfID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgaWYgKGRhdGEpIHJlcXVlc3RfLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxdWVzdF8uZW5kKGZuKTtcbiAgcmV0dXJuIHJlcXVlc3RfO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG5jb25zdCB7IGlzT2JqZWN0LCBoYXNPd24gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3RCYXNlKCkge31cblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdXBsb2FkVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIGRlbGV0ZSB0aGlzLl91cGxvYWRUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZm9ybWF0IG9mIGJpbmFyeSByZXNwb25zZSBib2R5LlxuICogSW4gYnJvd3NlciB2YWxpZCBmb3JtYXRzIGFyZSAnYmxvYicgYW5kICdhcnJheWJ1ZmZlcicsXG4gKiB3aGljaCByZXR1cm4gQmxvYiBhbmQgQXJyYXlCdWZmZXIsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJbiBOb2RlIGFsbCB2YWx1ZXMgcmVzdWx0IGluIEJ1ZmZlci5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqIC0gdXBsb2FkIGlzIHRoZSB0aW1lICBzaW5jZSBsYXN0IGJpdCBvZiBkYXRhIHdhcyBzZW50IG9yIHJlY2VpdmVkLiBUaGlzIHRpbWVvdXQgd29ya3Mgb25seSBpZiBkZWFkbGluZSB0aW1lb3V0IGlzIG9mZlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gMDtcbiAgICB0aGlzLl91cGxvYWRUaW1lb3V0ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzT3duKG9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VwbG9hZCc6XG4gICAgICAgICAgdGhpcy5fdXBsb2FkVGltZW91dCA9IG9wdGlvbnMudXBsb2FkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biB0aW1lb3V0IG9wdGlvbicsIG9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIChjb3VudCwgZm4pIHtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gTk9URTogd2UgZG8gbm90IGluY2x1ZGUgRVNPQ0tFVFRJTUVET1VUIGJlY2F1c2UgdGhhdCBpcyBmcm9tIGByZXF1ZXN0YCBwYWNrYWdlXG4vLyAgICAgICA8aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nb3QvcHVsbC81Mzc+XG4vL1xuLy8gTk9URTogd2UgZG8gbm90IGluY2x1ZGUgRUFERFJJTkZPIGJlY2F1c2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBsaWJ1diBpbiAyMDE0XG4vLyAgICAgICA8aHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2L2NvbW1pdC8wMmUxZWJkNDBiODA3YmU1YWY0NjM0M2VhODczMzMxYjJlZTRlOWMxPlxuLy8gICAgICAgPGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3Qvc2VhcmNoP3E9RVNPQ0tFVFRJTUVET1VUJnVuc2NvcGVkX3E9RVNPQ0tFVFRJTUVET1VUPlxuLy9cbi8vXG4vLyBUT0RPOiBleHBvc2UgdGhlc2UgYXMgY29uZmlndXJhYmxlIGRlZmF1bHRzXG4vL1xuY29uc3QgRVJST1JfQ09ERVMgPSBuZXcgU2V0KFtcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQ09OTlJFU0VUJyxcbiAgJ0VBRERSSU5VU0UnLFxuICAnRUNPTk5SRUZVU0VEJyxcbiAgJ0VQSVBFJyxcbiAgJ0VOT1RGT1VORCcsXG4gICdFTkVUVU5SRUFDSCcsXG4gICdFQUlfQUdBSU4nXG5dKTtcblxuY29uc3QgU1RBVFVTX0NPREVTID0gbmV3IFNldChbXG4gIDQwOCwgNDEzLCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNCwgNTIxLCA1MjIsIDUyNFxuXSk7XG5cbi8vIFRPRE86IHdlIHdvdWxkIG5lZWQgdG8gbWFrZSB0aGlzIGVhc2lseSBjb25maWd1cmFibGUgYmVmb3JlIGFkZGluZyBpdCBpbiAoZS5nLiBzb21lIG1pZ2h0IHdhbnQgdG8gYWRkIFBPU1QpXG4vLyBjb25zdCBNRVRIT0RTID0gbmV3IFNldChbJ0dFVCcsICdQVVQnLCAnSEVBRCcsICdERUxFVEUnLCAnT1BUSU9OUycsICdUUkFDRSddKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290I3JldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBhbiBlcnJvclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc10gcmVzcG9uc2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpZiBzZWdtZW50IHNob3VsZCBiZSByZXRyaWVkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2hvdWxkUmV0cnkgPSBmdW5jdGlvbiAoZXJyb3IsIHJlcykge1xuICBpZiAoIXRoaXMuX21heFJldHJpZXMgfHwgdGhpcy5fcmV0cmllcysrID49IHRoaXMuX21heFJldHJpZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyb3IsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiB3ZSB3b3VsZCBuZWVkIHRvIG1ha2UgdGhpcyBlYXNpbHkgY29uZmlndXJhYmxlIGJlZm9yZSBhZGRpbmcgaXQgaW4gKGUuZy4gc29tZSBtaWdodCB3YW50IHRvIGFkZCBQT1NUKVxuICAvKlxuICBpZiAoXG4gICAgdGhpcy5yZXEgJiZcbiAgICB0aGlzLnJlcS5tZXRob2QgJiZcbiAgICAhTUVUSE9EUy5oYXModGhpcy5yZXEubWV0aG9kLnRvVXBwZXJDYXNlKCkpXG4gIClcbiAgICByZXR1cm4gZmFsc2U7XG4gICovXG4gIGlmIChyZXMgJiYgcmVzLnN0YXR1cyAmJiBTVEFUVVNfQ09ERVMuaGFzKHJlcy5zdGF0dXMpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgJiYgRVJST1JfQ09ERVMuaGFzKGVycm9yLmNvZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgICBpZiAoZXJyb3IudGltZW91dCAmJiBlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVycm9yLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAvLyBub2RlXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXRFcnJvciA9IG51bGw7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlcydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZWxmLm9uKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21heFJldHJpZXMgJiYgdGhpcy5fbWF4UmV0cmllcyA+IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50aW1lZG91dCAmJiB0aGlzLnRpbWVkb3V0RXJyb3IpIHtcbiAgICAgICAgICByZWplY3QodGhpcy50aW1lZG91dEVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ0FCT1JURUQnO1xuICAgICAgICBlcnJvci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgZXJyb3IubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gICAgICAgIGVycm9yLnVybCA9IHRoaXMudXJsO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLmVuZCgoZXJyb3IsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJlamVjdChlcnJvcik7XG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZCkge1xuICAgICAgaWYgKGhhc093bihmaWVsZCwga2V5KSkgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIGZpZWxkIG5hbWVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBuYW1lIG9mIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbCB2YWx1ZSBvZiBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMgZXh0cmEgb3B0aW9ucywgZS5nLiAnYmxvYidcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChuYW1lID09PSBudWxsIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIlxuICAgICk7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICBpZiAoaGFzT3duKG5hbWUsIGtleSkpIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHZhbHVlKSB7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpKSkgdGhpcy5maWVsZChuYW1lLCB2YWx1ZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLy8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9sYWRqcy9zdXBlcmFnZW50L2lzc3Vlcy8xNjgwXG4gIGlmIChvcHRpb25zKSB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIGVsc2UgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy54aHIpIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB9XG5cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmFzaWMgJHtiYXNlNjRFbmNvZGVyKGAke3VzZXJ9OiR7cGFzc31gKX1gKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dXNlcn1gKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbj10cnVlXSAtIFNldCAnd2l0aENyZWRlbnRpYWxzJyBzdGF0ZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbiAobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgaXNPYmplY3RfID0gaXNPYmplY3QoZGF0YSk7XG4gIGxldCB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiXG4gICAgKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdF8gJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iamVjdF8gJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFba2V5XSA9PSAnYmlnaW50JyAmJiAhZGF0YVtrZXldLnRvSlNPTilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2VyaWFsaXplIEJpZ0ludCB2YWx1ZSB0byBqc29uJyk7XG4gICAgICBpZiAoaGFzT3duKGRhdGEsIGtleSkpIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdiaWdpbnQnKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VuZCB2YWx1ZSBvZiB0eXBlIEJpZ0ludFwiKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICh0eXBlKSB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBpZiAodHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhID8gYCR7dGhpcy5fZGF0YX0mJHtkYXRhfWAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0XyB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uIChzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBxdWVyeUFycmF5ID0gdGhpcy51cmwuc2xpY2UoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXJ5QXJyYXkuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyYXkuc29ydCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnNsaWNlKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyYXkuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9ICgpID0+IHtcbiAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCcpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24gKHJlYXNvbiwgdGltZW91dCwgZXJybm8pIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtyZWFzb24gKyB0aW1lb3V0fW1zIGV4Y2VlZGVkYCk7XG4gIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnJvci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVycm9yLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLnRpbWVkb3V0RXJyb3IgPSBlcnJvcjtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycm9yKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cblxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJyxcbiAgICAgICAgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LFxuICAgICAgICAnRVRJTUVET1VUJ1xuICAgICAgKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKCkge31cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgLy8gVE9ETzogbW9hciFcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gIC8vIGNvbnRlbnQtdHlwZVxuICBjb25zdCBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICBjb25zdCBwYXJhbWV0ZXJzID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1ldGVycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1ldGVycywga2V5KSlcbiAgICAgIHRoaXNba2V5XSA9IHBhcmFtZXRlcnNba2V5XTtcbiAgfVxuXG4gIHRoaXMubGlua3MgPSB7fTtcblxuICAvLyBsaW5rc1xuICB0cnkge1xuICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgY29uc3QgdHlwZSA9IE1hdGgudHJ1bmMoc3RhdHVzIC8gMTAwKTtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlO1xuICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gIC8vIGJhc2ljc1xuICB0aGlzLmluZm8gPSB0eXBlID09PSAxO1xuICB0aGlzLm9rID0gdHlwZSA9PT0gMjtcbiAgdGhpcy5yZWRpcmVjdCA9IHR5cGUgPT09IDM7XG4gIHRoaXMuY2xpZW50RXJyb3IgPSB0eXBlID09PSA0O1xuICB0aGlzLnNlcnZlckVycm9yID0gdHlwZSA9PT0gNTtcbiAgdGhpcy5lcnJvciA9IHR5cGUgPT09IDQgfHwgdHlwZSA9PT0gNSA/IHRoaXMudG9FcnJvcigpIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5jcmVhdGVkID0gc3RhdHVzID09PSAyMDE7XG4gIHRoaXMuYWNjZXB0ZWQgPSBzdGF0dXMgPT09IDIwMjtcbiAgdGhpcy5ub0NvbnRlbnQgPSBzdGF0dXMgPT09IDIwNDtcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gc3RhdHVzID09PSA0MDA7XG4gIHRoaXMudW5hdXRob3JpemVkID0gc3RhdHVzID09PSA0MDE7XG4gIHRoaXMubm90QWNjZXB0YWJsZSA9IHN0YXR1cyA9PT0gNDA2O1xuICB0aGlzLmZvcmJpZGRlbiA9IHN0YXR1cyA9PT0gNDAzO1xuICB0aGlzLm5vdEZvdW5kID0gc3RhdHVzID09PSA0MDQ7XG4gIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IHN0YXR1cyA9PT0gNDIyO1xufTtcbiIsIlxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IChzdHJpbmdfKSA9PiBzdHJpbmdfLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyYW1zID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBmb3IgKGNvbnN0IHN0cmluZ18gb2YgdmFsdWUuc3BsaXQoLyAqOyAqLykpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHN0cmluZ18uc3BsaXQoLyAqPSAqLyk7XG4gICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbHVlKSBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgZm9yIChjb25zdCBzdHJpbmdfIG9mIHZhbHVlLnNwbGl0KC8gKiwgKi8pKSB7XG4gICAgY29uc3QgcGFydHMgPSBzdHJpbmdfLnNwbGl0KC8gKjsgKi8pO1xuICAgIGNvbnN0IHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICBjb25zdCByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqZWN0W3JlbF0gPSB1cmw7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSAoaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKSA9PiB7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyLmhvc3Q7XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlci5hdXRob3JpemF0aW9uO1xuICAgIGRlbGV0ZSBoZWFkZXIuY29va2llO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pc09iamVjdCA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcbn07XG5cbi8qKlxuICogT2JqZWN0Lmhhc093biBmYWxsYmFjay9wb2x5ZmlsbC5cbiAqXG4gKiBAdHlwZSB7KG9iamVjdDogb2JqZWN0LCBwcm9wZXJ0eTogc3RyaW5nKSA9PiBib29sZWFufSBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnRzLmhhc093biA9XG4gIE9iamVjdC5oYXNPd24gfHxcbiAgZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV3IE9iamVjdChvYmplY3QpLCBwcm9wZXJ0eSk7XG4gIH07XG5cbmV4cG9ydHMubWl4aW4gPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGV4cG9ydHMuaGFzT3duKHNvdXJjZSwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGlzIGNvbXByZXNzZWQgdXNpbmcgR3ppcCBvciBEZWZsYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHJlc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzR3ppcE9yRGVmbGF0ZUVuY29kaW5nID0gKHJlcykgPT4ge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgvXlxccyooPzpkZWZsYXRlfGd6aXApXFxzKiQvKS50ZXN0KHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVzcG9uc2UgaXMgY29tcHJlc3NlZCB1c2luZyBCcm90bGkuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNCcm90bGlFbmNvZGluZyA9IChyZXMpID0+IHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoL15cXHMqKD86YnIpXFxzKiQvKS50ZXN0KHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pO1xufTtcbiIsIi8qISBOYXRpdmUgUHJvbWlzZSBPbmx5XG4gICAgdjAuOC4xIChjKSBLeWxlIFNpbXBzb25cbiAgICBNSVQgTGljZW5zZTogaHR0cDovL2dldGlmeS5taXQtbGljZW5zZS5vcmdcbiovXG5cbihmdW5jdGlvbiBVTUQobmFtZSxjb250ZXh0LGRlZmluaXRpb24pe1xuXHQvLyBzcGVjaWFsIGZvcm0gb2YgVU1EIGZvciBwb2x5ZmlsbGluZyBhY3Jvc3MgZXZpcm9ubWVudHNcblx0Y29udGV4dFtuYW1lXSA9IGNvbnRleHRbbmFtZV0gfHwgZGVmaW5pdGlvbigpO1xuXHRpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7IG1vZHVsZS5leHBvcnRzID0gY29udGV4dFtuYW1lXTsgfVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7IGRlZmluZShmdW5jdGlvbiAkQU1EJCgpeyByZXR1cm4gY29udGV4dFtuYW1lXTsgfSk7IH1cbn0pKFwiUHJvbWlzZVwiLHR5cGVvZiBnbG9iYWwgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMsZnVuY3Rpb24gREVGKCl7XG5cdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBidWlsdEluUHJvcCwgY3ljbGUsIHNjaGVkdWxpbmdfcXVldWUsXG5cdFx0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRcdHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT0gXCJ1bmRlZmluZWRcIikgP1xuXHRcdFx0ZnVuY3Rpb24gdGltZXIoZm4pIHsgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7IH0gOlxuXHRcdFx0c2V0VGltZW91dFxuXHQ7XG5cblx0Ly8gZGFtbWl0LCBJRTguXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwieFwiLHt9KTtcblx0XHRidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLG5hbWUse1xuXHRcdFx0XHR2YWx1ZTogdmFsLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiBjb25maWcgIT09IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cdGNhdGNoIChlcnIpIHtcblx0XHRidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuXHRcdFx0b2JqW25hbWVdID0gdmFsO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cblx0Ly8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5cdHNjaGVkdWxpbmdfcXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG5cdFx0dmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG5cdFx0ZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG5cdFx0XHR0aGlzLmZuID0gZm47XG5cdFx0XHR0aGlzLnNlbGYgPSBzZWxmO1xuXHRcdFx0dGhpcy5uZXh0ID0gdm9pZCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIGFkZChmbixzZWxmKSB7XG5cdFx0XHRcdGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcblx0XHRcdFx0aWYgKGxhc3QpIHtcblx0XHRcdFx0XHRsYXN0Lm5leHQgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZpcnN0ID0gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0ID0gaXRlbTtcblx0XHRcdFx0aXRlbSA9IHZvaWQgMDtcblx0XHRcdH0sXG5cdFx0XHRkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG5cdFx0XHRcdHZhciBmID0gZmlyc3Q7XG5cdFx0XHRcdGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG5cdFx0XHRcdHdoaWxlIChmKSB7XG5cdFx0XHRcdFx0Zi5mbi5jYWxsKGYuc2VsZik7XG5cdFx0XHRcdFx0ZiA9IGYubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuXHRcdHNjaGVkdWxpbmdfcXVldWUuYWRkKGZuLHNlbGYpO1xuXHRcdGlmICghY3ljbGUpIHtcblx0XHRcdGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ19xdWV1ZS5kcmFpbik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuXHRmdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcblx0XHR2YXIgX3RoZW4sIG9fdHlwZSA9IHR5cGVvZiBvO1xuXG5cdFx0aWYgKG8gIT0gbnVsbCAmJlxuXHRcdFx0KFxuXHRcdFx0XHRvX3R5cGUgPT0gXCJvYmplY3RcIiB8fCBvX3R5cGUgPT0gXCJmdW5jdGlvblwiXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHRfdGhlbiA9IG8udGhlbjtcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGVvZiBfdGhlbiA9PSBcImZ1bmN0aW9uXCIgPyBfdGhlbiA6IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbm90aWZ5KCkge1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRub3RpZnlJc29sYXRlZChcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0KHRoaXMuc3RhdGUgPT09IDEpID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLFxuXHRcdFx0XHR0aGlzLmNoYWluW2ldXG5cdFx0XHQpO1xuXHRcdH1cblx0XHR0aGlzLmNoYWluLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuXHQvLyB0aGUgYHRyeS4uY2F0Y2hgIHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gYmVcblx0Ly8gb3B0aW1pemVkIGJldHRlclxuXHRmdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG5cdFx0dmFyIHJldCwgX3RoZW47XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChjYiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoY2IgPT09IHRydWUpIHtcblx0XHRcdFx0XHRyZXQgPSBzZWxmLm1zZztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXQgPSBjYi5jYWxsKHZvaWQgMCxzZWxmLm1zZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVqZWN0KFR5cGVFcnJvcihcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG5cdFx0XHRcdFx0X3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNoYWluLnJlc29sdmUocmV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRjaGFpbi5yZWplY3QoZXJyKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlKG1zZykge1xuXHRcdHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG5cdFx0XHRcdHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGRlZl93cmFwcGVyID0gbmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRfdGhlbi5jYWxsKG1zZyxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gJHJlc29sdmUkKCl7IHJlc29sdmUuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gJHJlamVjdCQoKXsgcmVqZWN0LmFwcGx5KGRlZl93cmFwcGVyLGFyZ3VtZW50cyk7IH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlamVjdC5jYWxsKGRlZl93cmFwcGVyLGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNlbGYubXNnID0gbXNnO1xuXHRcdFx0XHRzZWxmLnN0YXRlID0gMTtcblx0XHRcdFx0aWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRyZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZWplY3QobXNnKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG5cdFx0aWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG5cdFx0c2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG5cdFx0Ly8gdW53cmFwXG5cdFx0aWYgKHNlbGYuZGVmKSB7XG5cdFx0XHRzZWxmID0gc2VsZi5kZWY7XG5cdFx0fVxuXG5cdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0c2VsZi5zdGF0ZSA9IDI7XG5cdFx0aWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIscmVzb2x2ZXIscmVqZWN0ZXIpIHtcblx0XHRmb3IgKHZhciBpZHg9MDsgaWR4PGFyci5sZW5ndGg7IGlkeCsrKSB7XG5cdFx0XHQoZnVuY3Rpb24gSUlGRShpZHgpe1xuXHRcdFx0XHRDb25zdHJ1Y3Rvci5yZXNvbHZlKGFycltpZHhdKVxuXHRcdFx0XHQudGhlbihcblx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZXIkKG1zZyl7XG5cdFx0XHRcdFx0XHRyZXNvbHZlcihpZHgsbXNnKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlamVjdGVyXG5cdFx0XHRcdCk7XG5cdFx0XHR9KShpZHgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcblx0XHR0aGlzLmRlZiA9IHNlbGY7XG5cdFx0dGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuXHRcdHRoaXMucHJvbWlzZSA9IHNlbGY7XG5cdFx0dGhpcy5zdGF0ZSA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcblx0XHR0aGlzLmNoYWluID0gW107XG5cdFx0dGhpcy5tc2cgPSB2b2lkIDA7XG5cdH1cblxuXHRmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjdXRvciAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9fTlBPX18gIT09IDApIHtcblx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIHByb21pc2VcIik7XG5cdFx0fVxuXG5cdFx0Ly8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG5cdFx0Ly8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2Vcblx0XHR0aGlzLl9fTlBPX18gPSAxO1xuXG5cdFx0dmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG5cdFx0dGhpc1tcInRoZW5cIl0gPSBmdW5jdGlvbiB0aGVuKHN1Y2Nlc3MsZmFpbHVyZSkge1xuXHRcdFx0dmFyIG8gPSB7XG5cdFx0XHRcdHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09IFwiZnVuY3Rpb25cIiA/IHN1Y2Nlc3MgOiB0cnVlLFxuXHRcdFx0XHRmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PSBcImZ1bmN0aW9uXCIgPyBmYWlsdXJlIDogZmFsc2Vcblx0XHRcdH07XG5cdFx0XHQvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG5cdFx0XHQvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcblx0XHRcdC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cblx0XHRcdG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLHJlamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHRvLnJlamVjdCA9IHJlamVjdDtcblx0XHRcdH0pO1xuXHRcdFx0ZGVmLmNoYWluLnB1c2gobyk7XG5cblx0XHRcdGlmIChkZWYuc3RhdGUgIT09IDApIHtcblx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LGRlZik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvLnByb21pc2U7XG5cdFx0fTtcblx0XHR0aGlzW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAkY2F0Y2gkKGZhaWx1cmUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuXHRcdH07XG5cblx0XHR0cnkge1xuXHRcdFx0ZXhlY3V0b3IuY2FsbChcblx0XHRcdFx0dm9pZCAwLFxuXHRcdFx0XHRmdW5jdGlvbiBwdWJsaWNSZXNvbHZlKG1zZyl7XG5cdFx0XHRcdFx0cmVzb2x2ZS5jYWxsKGRlZixtc2cpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG5cdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKGRlZixlcnIpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sXCJjb25zdHJ1Y3RvclwiLFByb21pc2UsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5cdFByb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuXHQvLyBidWlsdC1pbiBcImJyYW5kXCIgdG8gc2lnbmFsIGFuIFwidW5pbml0aWFsaXplZFwiIHByb21pc2Vcblx0YnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSxcIl9fTlBPX19cIiwwLFxuXHRcdC8qY29uZmlndXJhYmxlPSovZmFsc2Vcblx0KTtcblxuXHRidWlsdEluUHJvcChQcm9taXNlLFwicmVzb2x2ZVwiLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcblx0XHR2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG5cdFx0Ly8gc3BlYyBtYW5kYXRlZCBjaGVja3Ncblx0XHQvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG5cdFx0aWYgKG1zZyAmJiB0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnLl9fTlBPX18gPT09IDEpIHtcblx0XHRcdHJldHVybiBtc2c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNvbHZlKG1zZyk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZWplY3RcIixmdW5jdGlvbiBQcm9taXNlJHJlamVjdChtc2cpIHtcblx0XHRyZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuXHRcdFx0aWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0cmVqZWN0KG1zZyk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJhbGxcIixmdW5jdGlvbiBQcm9taXNlJGFsbChhcnIpIHtcblx0XHR2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG5cdFx0Ly8gc3BlYyBtYW5kYXRlZCBjaGVja3Ncblx0XHRpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0cmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpO1xuXHRcdH1cblx0XHRpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuXHRcdFx0aWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZykge1xuXHRcdFx0XHRtc2dzW2lkeF0gPSBtc2c7XG5cdFx0XHRcdGlmICgrK2NvdW50ID09PSBsZW4pIHtcblx0XHRcdFx0XHRyZXNvbHZlKG1zZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LHJlamVjdCk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyYWNlXCIsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuXHRcdFx0XHRyZXNvbHZlKG1zZyk7XG5cdFx0XHR9LHJlamVjdCk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlO1xufSk7XG4iLCIvLyAncGF0aCcgbW9kdWxlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSAob25seSB0aGUgcG9zaXggcGFydClcbi8vIHRyYW5zcGxpdGVkIHdpdGggQmFiZWxcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gIH1cbn1cblxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCBhbGxvd0Fib3ZlUm9vdCkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIHZhciBsYXN0U2xhc2ggPSAtMTtcbiAgdmFyIGRvdHMgPSAwO1xuICB2YXIgY29kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgY29kZSA9IDQ3IC8qLyovO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAvLyBOT09QXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiAvKi4qLyB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMgPSAnLi4nO1xuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJlcyArPSAnLycgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2IC8qLiovICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgdmFyIGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgKHBhdGhPYmplY3QubmFtZSB8fCAnJykgKyAocGF0aE9iamVjdC5leHQgfHwgJycpO1xuICBpZiAoIWRpcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChkaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG4gIHJldHVybiBkaXIgKyBzZXAgKyBiYXNlO1xufVxuXG52YXIgcG9zaXggPSB7XG4gIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgY3dkO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3dkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgcGF0aCA9IGN3ZDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcblxuICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3IC8qLyovO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsICFpc0Fic29sdXRlKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkgcGF0aCA9ICcuJztcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKSBwYXRoICs9ICcvJztcblxuICAgIGlmIChpc0Fic29sdXRlKSByZXR1cm4gJy8nICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICcuJztcbiAgICB2YXIgam9pbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBqb2luZWQgKz0gJy8nICsgYXJnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcblxuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBhc3NlcnRQYXRoKGZyb20pO1xuICAgIGFzc2VydFBhdGgodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICB0byA9IHBvc2l4LnJlc29sdmUodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIGZyb21TdGFydCA9IDE7XG4gICAgZm9yICg7IGZyb21TdGFydCA8IGZyb20ubGVuZ3RoOyArK2Zyb21TdGFydCkge1xuICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciB0b1N0YXJ0ID0gMTtcbiAgICBmb3IgKDsgdG9TdGFydCA8IHRvLmxlbmd0aDsgKyt0b1N0YXJ0KSB7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgdG9FbmQgPSB0by5sZW5ndGg7XG4gICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuXG4gICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgdmFyIGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vJzsgdG89Jy8nXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICB2YXIgdG9Db2RlID0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSk7XG4gICAgICBpZiAoZnJvbUNvZGUgIT09IHRvQ29kZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gNDcgLyovKi8pXG4gICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgIC8vIGFuZCBgZnJvbWBcbiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgb3V0ICs9ICcuLic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXQgKz0gJy8uLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gb3V0ICsgdG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApO1xuICAgIGVsc2Uge1xuICAgICAgdG9TdGFydCArPSBsYXN0Q29tbW9uU2VwO1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IDQ3IC8qLyovKVxuICAgICAgICArK3RvU3RhcnQ7XG4gICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCk7XG4gICAgfVxuICB9LFxuXG4gIF9tYWtlTG9uZzogZnVuY3Rpb24gX21ha2VMb25nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSByZXR1cm4gJy8vJztcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICB9LFxuXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aC5sZW5ndGggJiYgZXh0ID09PSBwYXRoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7ZWxzZSBpZiAoZW5kID09PSAtMSkgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcblxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChwYXRoT2JqZWN0KSB7XG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHBhdGhPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdCgnLycsIHBhdGhPYmplY3QpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgc3RhcnQ7XG4gICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgIHJldC5yb290ID0gJy8nO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcblxuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG5cbiAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSBzdGFydERvdCA9IGk7ZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHByZURvdFN0YXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIGVuZCk7ZWxzZSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhcnQgPiAwKSByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtlbHNlIGlmIChpc0Fic29sdXRlKSByZXQuZGlyID0gJy8nO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIHdpbjMyOiBudWxsLFxuICBwb3NpeDogbnVsbFxufTtcblxucG9zaXgucG9zaXggPSBwb3NpeDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpeDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG52YXIgRm9ybWF0ID0ge1xuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG4gICAgZm9ybWF0dGVyczoge1xuICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgfSxcbiAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXG4gICAgUkZDMzk4NjogRm9ybWF0LlJGQzM5ODZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlRG90SW5LZXlzOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgZHVwbGljYXRlczogJ2NvbWJpbmUnLFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0RGVwdGg6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyhcXGQrKTsvZywgZnVuY3Rpb24gKCQwLCBudW1iZXJTdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobnVtYmVyU3RyLCAxMCkpO1xuICAgIH0pO1xufTtcblxudmFyIHBhcnNlQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyB3aGF0IGJyb3dzZXJzIHdpbGwgc3VibWl0IHdoZW4gdGhlIOKckyBjaGFyYWN0ZXIgb2NjdXJzIGluIGFuXG4vLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxuLy8gYXR0cmlidXRlIG9mIGlzby04ODU5LTEuIFByZXN1bWFibHkgYWxzbyB3aXRoIG90aGVyIGNoYXJzZXRzIHRoYXQgZG8gbm90IGNvbnRhaW5cbi8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcblxuLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50LWVuY29kZWQgdXRmLTggb2N0ZXRzIHJlcHJlc2VudGluZyBhIGNoZWNrbWFyaywgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IGFjdHVhbGx5IGlzIHV0Zi04IGVuY29kZWQuXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuXG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIGNsZWFuU3RyID0gY2xlYW5TdHIucmVwbGFjZSgvJTVCL2dpLCAnWycpLnJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcbiAgICB2YXIgc2tpcEluZGV4ID0gLTE7IC8vIEtlZXAgdHJhY2sgb2Ygd2hlcmUgdGhlIHV0Zjggc2VudGluZWwgd2FzIGZvdW5kXG4gICAgdmFyIGk7XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldDtcbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbaV0uaW5kZXhPZigndXRmOD0nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAndXRmLTgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV0gPT09IGlzb1NlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAnaXNvLTg4NTktMSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXBJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcnRzLmxlbmd0aDsgLy8gVGhlIGVzbGludCBzZXR0aW5ncyBkbyBub3QgYWxsb3cgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IHNraXBJbmRleCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPyBudWxsIDogJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSB1dGlscy5tYXliZU1hcChcbiAgICAgICAgICAgICAgICBwYXJzZUFycmF5VmFsdWUocGFydC5zbGljZShwb3MgKyAxKSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVuY29kZWRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVjb2RlcihlbmNvZGVkVmFsLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAndmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCAmJiBvcHRpb25zLmludGVycHJldE51bWVyaWNFbnRpdGllcyAmJiBjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIHZhbCA9IGludGVycHJldE51bWVyaWNFbnRpdGllcyh2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignW109JykgPiAtMSkge1xuICAgICAgICAgICAgdmFsID0gaXNBcnJheSh2YWwpID8gW3ZhbF0gOiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBoYXMuY2FsbChvYmosIGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyAmJiBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdjb21iaW5lJykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZyB8fCBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdsYXN0Jykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLmFsbG93RW1wdHlBcnJheXMgJiYgKGxlYWYgPT09ICcnIHx8IChvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyAmJiBsZWFmID09PSBudWxsKSlcbiAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgOiBbXS5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkUm9vdCA9IG9wdGlvbnMuZGVjb2RlRG90SW5LZXlzID8gY2xlYW5Sb290LnJlcGxhY2UoLyUyRS9nLCAnLicpIDogY2xlYW5Sb290O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZGVjb2RlZFJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBkZWNvZGVkUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGRlY29kZWRSb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gZGVjb2RlZFJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29kZWRSb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtkZWNvZGVkUm9vdF0gPSBsZWFmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZiA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5cyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG9wdGlvbnMuZGVwdGggPiAwICYmIChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBjaGVjayBzdHJpY3REZXB0aCBvcHRpb24gZm9yIHRocm93LCBlbHNlIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdERlcHRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5wdXQgZGVwdGggZXhjZWVkZWQgZGVwdGggb3B0aW9uIG9mICcgKyBvcHRpb25zLmRlcHRoICsgJyBhbmQgc3RyaWN0RGVwdGggaXMgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFsbG93RW1wdHlBcnJheXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5kZWNvZGVEb3RJbktleXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmRlY29kZURvdEluS2V5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BkZWNvZGVEb3RJbktleXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSB0eXBlb2Ygb3B0cy5jaGFyc2V0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmNoYXJzZXQgOiBvcHRzLmNoYXJzZXQ7XG5cbiAgICB2YXIgZHVwbGljYXRlcyA9IHR5cGVvZiBvcHRzLmR1cGxpY2F0ZXMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZHVwbGljYXRlcyA6IG9wdHMuZHVwbGljYXRlcztcblxuICAgIGlmIChkdXBsaWNhdGVzICE9PSAnY29tYmluZScgJiYgZHVwbGljYXRlcyAhPT0gJ2ZpcnN0JyAmJiBkdXBsaWNhdGVzICE9PSAnbGFzdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGR1cGxpY2F0ZXMgb3B0aW9uIG11c3QgYmUgZWl0aGVyIGNvbWJpbmUsIGZpcnN0LCBvciBsYXN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmRlY29kZURvdEluS2V5cyA9PT0gdHJ1ZSA/IHRydWUgOiBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsb3dEb3RzOiBhbGxvd0RvdHMsXG4gICAgICAgIGFsbG93RW1wdHlBcnJheXM6IHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgPT09ICdib29sZWFuJyA/ICEhb3B0cy5hbGxvd0VtcHR5QXJyYXlzIDogZGVmYXVsdHMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgYWxsb3dQcm90b3R5cGVzOiB0eXBlb2Ygb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzLFxuICAgICAgICBhbGxvd1NwYXJzZTogdHlwZW9mIG9wdHMuYWxsb3dTcGFyc2UgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dTcGFyc2UgOiBkZWZhdWx0cy5hbGxvd1NwYXJzZSxcbiAgICAgICAgYXJyYXlMaW1pdDogdHlwZW9mIG9wdHMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0LFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGNvbW1hOiB0eXBlb2Ygb3B0cy5jb21tYSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jb21tYSA6IGRlZmF1bHRzLmNvbW1hLFxuICAgICAgICBkZWNvZGVEb3RJbktleXM6IHR5cGVvZiBvcHRzLmRlY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5kZWNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5kZWNvZGVEb3RJbktleXMsXG4gICAgICAgIGRlY29kZXI6IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvbiwgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG4gICAgICAgIGR1cGxpY2F0ZXM6IGR1cGxpY2F0ZXMsXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxuICAgICAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IHR5cGVvZiBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgOiBkZWZhdWx0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMsXG4gICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcbiAgICAgICAgcGxhaW5PYmplY3RzOiB0eXBlb2Ygb3B0cy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdHMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzLFxuICAgICAgICBzdHJpY3REZXB0aDogdHlwZW9mIG9wdHMuc3RyaWN0RGVwdGggPT09ICdib29sZWFuJyA/ICEhb3B0cy5zdHJpY3REZXB0aCA6IGRlZmF1bHRzLnN0cmljdERlcHRoLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1NwYXJzZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0U2lkZUNoYW5uZWwgPSByZXF1aXJlKCdzaWRlLWNoYW5uZWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGFycmF5UHJlZml4R2VuZXJhdG9ycyA9IHtcbiAgICBicmFja2V0czogZnVuY3Rpb24gYnJhY2tldHMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuICAgIH0sXG4gICAgY29tbWE6ICdjb21tYScsXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgIH0sXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xuICAgIHB1c2guYXBwbHkoYXJyLCBpc0FycmF5KHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgYWxsb3dFbXB0eUFycmF5czogZmFsc2UsXG4gICAgYXJyYXlGb3JtYXQ6ICdpbmRpY2VzJyxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZURvdEluS2V5czogZmFsc2UsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHMuZm9ybWF0dGVyc1tkZWZhdWx0Rm9ybWF0XSxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgaW5kaWNlczogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaXNOb25OdWxsaXNoUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNOb25OdWxsaXNoUHJpbWl0aXZlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG59O1xuXG52YXIgc2VudGluZWwgPSB7fTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgY29tbWFSb3VuZFRyaXAsXG4gICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZURvdEluS2V5cyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdCxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICBjaGFyc2V0LFxuICAgIHNpZGVDaGFubmVsXG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gICAgdmFyIHRtcFNjID0gc2lkZUNoYW5uZWw7XG4gICAgdmFyIHN0ZXAgPSAwO1xuICAgIHZhciBmaW5kRmxhZyA9IGZhbHNlO1xuICAgIHdoaWxlICgodG1wU2MgPSB0bXBTYy5nZXQoc2VudGluZWwpKSAhPT0gdm9pZCB1bmRlZmluZWQgJiYgIWZpbmRGbGFnKSB7XG4gICAgICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxuICAgICAgICB2YXIgcG9zID0gdG1wU2MuZ2V0KG9iamVjdCk7XG4gICAgICAgIHN0ZXAgKz0gMTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0N5Y2xpYyBvYmplY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluZEZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG1wU2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgICAgIGlmIChlbmNvZGVWYWx1ZXNPbmx5ICYmIGVuY29kZXIpIHtcbiAgICAgICAgICAgIG9iaiA9IHV0aWxzLm1heWJlTWFwKG9iaiwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZWRQcmVmaXggPSBlbmNvZGVEb3RJbktleXMgPyBwcmVmaXgucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IHByZWZpeDtcblxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gZW5jb2RlZFByZWZpeCArICdbXScgOiBlbmNvZGVkUHJlZml4O1xuXG4gICAgaWYgKGFsbG93RW1wdHlBcnJheXMgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdGVkUHJlZml4ICsgJ1tdJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iaktleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbal07XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkudmFsdWUgIT09ICd1bmRlZmluZWQnID8ga2V5LnZhbHVlIDogb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5jb2RlZEtleSA9IGFsbG93RG90cyAmJiBlbmNvZGVEb3RJbktleXMgPyBrZXkucmVwbGFjZSgvXFwuL2csICclMkUnKSA6IGtleTtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGlzQXJyYXkob2JqKVxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGVuY29kZWRLZXkpIDogYWRqdXN0ZWRQcmVmaXhcbiAgICAgICAgICAgIDogYWRqdXN0ZWRQcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsgZW5jb2RlZEtleSA6ICdbJyArIGVuY29kZWRLZXkgKyAnXScpO1xuXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuICAgICAgICB2YXIgdmFsdWVTaWRlQ2hhbm5lbCA9IGdldFNpZGVDaGFubmVsKCk7XG4gICAgICAgIHZhbHVlU2lkZUNoYW5uZWwuc2V0KHNlbnRpbmVsLCBzaWRlQ2hhbm5lbCk7XG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBrZXlQcmVmaXgsXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXG4gICAgICAgICAgICBhbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBlbmNvZGVWYWx1ZXNPbmx5ICYmIGlzQXJyYXkob2JqKSA/IG51bGwgOiBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgIHZhbHVlU2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhbGxvd0VtcHR5QXJyYXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVEb3RJbktleXMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgZW5jb2RlRG90SW5LZXlzYCBvcHRpb24gY2FuIG9ubHkgYmUgYHRydWVgIG9yIGBmYWxzZWAsIHdoZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cy5jaGFyc2V0O1xuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5mb3JtYXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgdmFyIGZpbHRlciA9IGRlZmF1bHRzLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGlzQXJyYXkob3B0cy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0cy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAoJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9IGRlZmF1bHRzLmFycmF5Rm9ybWF0O1xuICAgIH1cblxuICAgIGlmICgnY29tbWFSb3VuZFRyaXAnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMuY29tbWFSb3VuZFRyaXAgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IG9wdHMuZW5jb2RlRG90SW5LZXlzID09PSB0cnVlID8gdHJ1ZSA6IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcbiAgICAgICAgYWxsb3dEb3RzOiBhbGxvd0RvdHMsXG4gICAgICAgIGFsbG93RW1wdHlBcnJheXM6IHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgPT09ICdib29sZWFuJyA/ICEhb3B0cy5hbGxvd0VtcHR5QXJyYXlzIDogZGVmYXVsdHMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgYXJyYXlGb3JtYXQ6IGFycmF5Rm9ybWF0LFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgICAgICBjaGFyc2V0U2VudGluZWw6IHR5cGVvZiBvcHRzLmNoYXJzZXRTZW50aW5lbCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaGFyc2V0U2VudGluZWwgOiBkZWZhdWx0cy5jaGFyc2V0U2VudGluZWwsXG4gICAgICAgIGNvbW1hUm91bmRUcmlwOiBvcHRzLmNvbW1hUm91bmRUcmlwLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICAgICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgICAgICBlbmNvZGVEb3RJbktleXM6IHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5lbmNvZGVEb3RJbktleXMsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1tvcHRpb25zLmFycmF5Rm9ybWF0XTtcbiAgICB2YXIgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdGlvbnMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hUb0FycmF5KGtleXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlRG90SW5LZXlzLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzZXQsXG4gICAgICAgICAgICBzaWRlQ2hhbm5lbFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0ga2V5cy5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXCJudW1lcmljIGVudGl0eVwiIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlY2ttYXJrXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lRTIlOUMlOTMmJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLm9ialtpdGVtLnByb3BdID0gY29tcGFjdGVkO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKSB8fCAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCBzb3VyY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgIWlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SXRlbSA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSAmJiB0eXBlb2YgdGFyZ2V0SXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgZGVjb2RlciwgY2hhcnNldCkge1xuICAgIHZhciBzdHJXaXRob3V0UGx1cyA9IHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIC8vIHVuZXNjYXBlIG5ldmVyIHRocm93cywgbm8gdHJ5Li4uY2F0Y2ggbmVlZGVkOlxuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XG4gICAgfVxuICAgIC8vIHV0Zi04XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJXaXRob3V0UGx1cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXM7XG4gICAgfVxufTtcblxudmFyIGxpbWl0ID0gMTAyNDtcblxuLyogZXNsaW50IG9wZXJhdG9yLWxpbmVicmVhazogWzIsIFwiYmVmb3JlXCJdICovXG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQnJpYW4gV2hpdGUgKG1zY2RleCkgZm9yIHRoZSBpby5qcyBjb3JlIHF1ZXJ5c3RyaW5nIGxpYnJhcnkuXG4gICAgLy8gSXQgaGFzIGJlZW4gYWRhcHRlZCBoZXJlIGZvciBzdHJpY3RlciBhZGhlcmVuY2UgdG8gUkZDIDM5ODZcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzdHI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyUyNiUyMycgKyBwYXJzZUludCgkMC5zbGljZSgyKSwgMTYpICsgJyUzQic7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmluZy5sZW5ndGg7IGogKz0gbGltaXQpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzdHJpbmcubGVuZ3RoID49IGxpbWl0ID8gc3RyaW5nLnNsaWNlKGosIGogKyBsaW1pdCkgOiBzdHJpbmc7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gc2VnbWVudC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4NUYgLy8gX1xuICAgICAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgICAgICB8fCAoYyA+PSAweDQxICYmIGMgPD0gMHg1QSkgLy8gYS16XG4gICAgICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICAgICAgICAgIHx8IChmb3JtYXQgPT09IGZvcm1hdHMuUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBzZWdtZW50LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4VGFibGVbY107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildXG4gICAgICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildXG4gICAgICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzZWdtZW50LmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuXG4gICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBhcnIuam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLWRhdGEtcHJvcGVydHknKTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpKCk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG52YXIgJFdlYWtNYXAgPSBHZXRJbnRyaW5zaWMoJyVXZWFrTWFwJScsIHRydWUpO1xudmFyICRNYXAgPSBHZXRJbnRyaW5zaWMoJyVNYXAlJywgdHJ1ZSk7XG5cbnZhciAkd2Vha01hcEdldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBTZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbnZhciAkbWFwR2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICRtYXBTZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcblxuLypcbiogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGxpc3QgcmV0dXJuaW5nIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleS5cbipcbiogVGhhdCBub2RlIGlzIGFsc28gbW92ZWQgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3QsIHNvIHRoYXQgaWYgaXQncyBhY2Nlc3NlZCBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseSB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4qL1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5saXN0R2V0Tm9kZX0gKi9cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHQvKiogQHR5cGUge3R5cGVvZiBsaXN0IHwgTm9uTnVsbGFibGU8KHR5cGVvZiBsaXN0KVsnbmV4dCddPn0gKi9cblx0dmFyIHByZXYgPSBsaXN0O1xuXHQvKiogQHR5cGUgeyh0eXBlb2YgbGlzdClbJ25leHQnXX0gKi9cblx0dmFyIGN1cnI7XG5cdGZvciAoOyAoY3VyciA9IHByZXYubmV4dCkgIT09IG51bGw7IHByZXYgPSBjdXJyKSB7XG5cdFx0aWYgKGN1cnIua2V5ID09PSBrZXkpIHtcblx0XHRcdHByZXYubmV4dCA9IGN1cnIubmV4dDtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHRcdGN1cnIubmV4dCA9IC8qKiBAdHlwZSB7Tm9uTnVsbGFibGU8dHlwZW9mIGxpc3QubmV4dD59ICovIChsaXN0Lm5leHQpO1xuXHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpLmxpc3RHZXR9ICovXG52YXIgbGlzdEdldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xufTtcbi8qKiBAdHlwZSB7aW1wb3J0KCcuJykubGlzdFNldH0gKi9cbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5MaXN0Tm9kZTx0eXBlb2YgdmFsdWU+fSAqLyAoeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBuby1leHRyYS1wYXJlbnNcblx0XHRcdGtleToga2V5LFxuXHRcdFx0bmV4dDogb2JqZWN0cy5uZXh0LFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fSk7XG5cdH1cbn07XG4vKiogQHR5cGUge2ltcG9ydCgnLicpLmxpc3RIYXN9ICovXG52YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNpZGVDaGFubmVsKCkge1xuXHQvKiogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCB1bmtub3duPn0gKi8gdmFyICR3bTtcblx0LyoqIEB0eXBlIHtNYXA8b2JqZWN0LCB1bmtub3duPn0gKi8gdmFyICRtO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLicpLlJvb3ROb2RlPHVua25vd24+fSAqLyB2YXIgJG87XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4nKS5DaGFubmVsfSAqL1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEdldCgkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RHZXQoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEhhcygkbSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdGlmICghJHdtKSB7XG5cdFx0XHRcdFx0JHdtID0gbmV3ICRXZWFrTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoJE1hcCkge1xuXHRcdFx0XHRpZiAoISRtKSB7XG5cdFx0XHRcdFx0JG0gPSBuZXcgJE1hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRtYXBTZXQoJG0sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCEkbykge1xuXHRcdFx0XHRcdC8vIEluaXRpYWxpemUgdGhlIGxpbmtlZCBsaXN0IGFzIGFuIGVtcHR5IG5vZGUsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG8gaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0XHQkbyA9IHsga2V5OiB7fSwgbmV4dDogbnVsbCB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3RTZXQoJG8sIGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGNoYW5uZWw7XG59O1xuIiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrUmVmID0gdHlwZW9mIFdlYWtSZWYgPT09ICdmdW5jdGlvbicgJiYgV2Vha1JlZi5wcm90b3R5cGU7XG52YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbnZhciAkc2xpY2UgPSBTdHJpbmcucHJvdG90eXBlLnNsaWNlO1xudmFyICRyZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XG52YXIgJHRvTG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbnZhciAkdGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciAkam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyICRhcnJTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcbnZhciBnT1BTID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcbnZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG4vLyBpZSwgYGhhcy10b3N0cmluZ3RhZy9zaGFtc1xudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcbiAgICA/IFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgIDogbnVsbDtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljU2VwYXJhdG9yKG51bSwgc3RyKSB7XG4gICAgaWYgKFxuICAgICAgICBudW0gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG51bSA9PT0gLUluZmluaXR5XG4gICAgICAgIHx8IG51bSAhPT0gbnVtXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcbiAgICAgICAgfHwgJHRlc3QuY2FsbCgvZS8sIHN0cilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIHNlcFJlZ2V4ID0gL1swLTldKD89KD86WzAtOV17M30pKyg/IVswLTldKSkvZztcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGludCA9IG51bSA8IDAgPyAtJGZsb29yKC1udW0pIDogJGZsb29yKG51bSk7IC8vIHRydW5jKG51bSlcbiAgICAgICAgaWYgKGludCAhPT0gbnVtKSB7XG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XG4gICAgICAgICAgICB2YXIgZGVjID0gJHNsaWNlLmNhbGwoc3RyLCBpbnRTdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChpbnRTdHIsIHNlcFJlZ2V4LCAnJCZfJykgKyAnLicgKyAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoZGVjLCAvKFswLTldezN9KS9nLCAnJCZfJyksIC9fJC8sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChzdHIsIHNlcFJlZ2V4LCAnJCZfJyk7XG59XG5cbnZhciB1dGlsSW5zcGVjdCA9IHJlcXVpcmUoJy4vdXRpbC5pbnNwZWN0Jyk7XG52YXIgaW5zcGVjdEN1c3RvbSA9IHV0aWxJbnNwZWN0LmN1c3RvbTtcbnZhciBpbnNwZWN0U3ltYm9sID0gaXNTeW1ib2woaW5zcGVjdEN1c3RvbSkgPyBpbnNwZWN0Q3VzdG9tIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNSZWdFeHAob2JqKSkgeyAvLyBpbiBvbGRlciBlbmdpbmVzLCByZWdleGVzIGFyZSBjYWxsYWJsZVxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsSW5zcGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxJbnNwZWN0KG9iaiwgeyBkZXB0aDogbWF4RGVwdGggLSBkZXB0aCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hcChvYmopKSB7XG4gICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAobWFwRm9yRWFjaCkge1xuICAgICAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBtYXBQYXJ0cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmosIHRydWUpICsgJyA9PiAnICsgaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1NldChvYmopKSB7XG4gICAgICAgIHZhciBzZXRQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAoc2V0Rm9yRWFjaCkge1xuICAgICAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtSZWYnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgLy8gbm90ZTogaW4gSUUgOCwgc29tZXRpbWVzIGBnbG9iYWwgIT09IHdpbmRvd2AgYnV0IGJvdGggYXJlIHRoZSBwcm90b3R5cGVzIG9mIGVhY2ggb3RoZXJcbiAgICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuICd7IFtvYmplY3QgV2luZG93XSB9JztcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsVGhpcylcbiAgICAgICAgfHwgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsKVxuICAgICkge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBnbG9iYWxUaGlzXSB9JztcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgICAgIHZhciBwcm90b1RhZyA9IG9iaiBpbnN0YW5jZW9mIE9iamVjdCA/ICcnIDogJ251bGwgcHJvdG90eXBlJztcbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9ICFpc1BsYWluT2JqZWN0ICYmIHRvU3RyaW5nVGFnICYmIE9iamVjdChvYmopID09PSBvYmogJiYgdG9TdHJpbmdUYWcgaW4gb2JqID8gJHNsaWNlLmNhbGwodG9TdHIob2JqKSwgOCwgLTEpIDogcHJvdG9UYWcgPyAnT2JqZWN0JyA6ICcnO1xuICAgICAgICB2YXIgY29uc3RydWN0b3JUYWcgPSBpc1BsYWluT2JqZWN0IHx8IHR5cGVvZiBvYmouY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgPyAnJyA6IG9iai5jb25zdHJ1Y3Rvci5uYW1lID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgOiAnJztcbiAgICAgICAgdmFyIHRhZyA9IGNvbnN0cnVjdG9yVGFnICsgKHN0cmluZ1RhZyB8fCBwcm90b1RhZyA/ICdbJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKFtdLCBzdHJpbmdUYWcgfHwgW10sIHByb3RvVGFnIHx8IFtdKSwgJzogJykgKyAnXSAnIDogJycpO1xuICAgICAgICBpZiAoeXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB0YWcgKyAne30nOyB9XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgKyAneycgKyBpbmRlbnRlZEpvaW4oeXMsIGluZGVudCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyAkam9pbi5jYWxsKHlzLCAnLCAnKSArICcgfSc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHdyYXBRdW90ZXMocywgZGVmYXVsdFN0eWxlLCBvcHRzKSB7XG4gICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXCInIDogXCInXCI7XG4gICAgcmV0dXJuIHF1b3RlQ2hhciArIHMgKyBxdW90ZUNoYXI7XG59XG5cbmZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChTdHJpbmcocyksIC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNEYXRlKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBTdHJpbmddJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5cbi8vIFN5bWJvbCBhbmQgQmlnSW50IGRvIGhhdmUgU3ltYm9sLnRvU3RyaW5nVGFnIGJ5IHNwZWMsIHNvIHRoYXQgY2FuJ3QgYmUgdXNlZCB0byBlbGltaW5hdGUgZmFsc2UgcG9zaXRpdmVzXG5mdW5jdGlvbiBpc1N5bWJvbChvYmopIHtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBTeW1ib2w7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIXN5bVRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3ltVG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnQob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIWJpZ0ludFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiB0aGlzOyB9O1xuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn1cblxuZnVuY3Rpb24gdG9TdHIob2JqKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gbmFtZU9mKGYpIHtcbiAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cbiAgICB2YXIgbSA9ICRtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1JlZih4KSB7XG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1JlZkRlcmVmLmNhbGwoeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZygkc2xpY2UuY2FsbChzdHIsIDAsIG9wdHMubWF4U3RyaW5nTGVuZ3RoKSwgb3B0cykgKyB0cmFpbGVyO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHZhciBzID0gJHJlcGxhY2UuY2FsbCgkcmVwbGFjZS5jYWxsKHN0ciwgLyhbJ1xcXFxdKS9nLCAnXFxcXCQxJyksIC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJyxcbiAgICAgICAgOTogJ3QnLFxuICAgICAgICAxMDogJ24nLFxuICAgICAgICAxMjogJ2YnLFxuICAgICAgICAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgJHRvVXBwZXJDYXNlLmNhbGwobi50b1N0cmluZygxNikpO1xufVxuXG5mdW5jdGlvbiBtYXJrQm94ZWQoc3RyKSB7XG4gICAgcmV0dXJuICdPYmplY3QoJyArIHN0ciArICcpJztcbn1cblxuZnVuY3Rpb24gd2Vha0NvbGxlY3Rpb25PZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9Jztcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKHR5cGUsIHNpemUsIGVudHJpZXMsIGluZGVudCkge1xuICAgIHZhciBqb2luZWRFbnRyaWVzID0gaW5kZW50ID8gaW5kZW50ZWRKb2luKGVudHJpZXMsIGluZGVudCkgOiAkam9pbi5jYWxsKGVudHJpZXMsICcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAkam9pbi5jYWxsKEFycmF5KG9wdHMuaW5kZW50ICsgMSksICcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXG4gICAgICAgIHByZXY6ICRqb2luLmNhbGwoQXJyYXkoZGVwdGggKyAxKSwgYmFzZUluZGVudClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkge1xuICAgIGlmICh4cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGxpbmVKb2luZXIgPSAnXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XG4gICAgcmV0dXJuIGxpbmVKb2luZXIgKyAkam9pbi5jYWxsKHhzLCAnLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuICAgIHZhciBzeW1NYXA7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHN5bU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHN5bXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN5bU1hcFsnJCcgKyBzeW1zW2tdXSA9IHN5bXNba107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChpc0FyciAmJiBTdHJpbmcoTnVtYmVyKGtleSkpID09PSBrZXkgJiYga2V5IDwgb2JqLmxlbmd0aCkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBzaGFtbWVkIFN5bWJvbHMsIHdoaWNoIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgZnJvbSBiZWluZyBpbmNsdWRlZCBpbiB0aGUgc3RyaW5nIGtleSBzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmICgkdGVzdC5jYWxsKC9bXlxcdyRdLywga2V5KSkge1xuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpc0VudW1lcmFibGUuY2FsbChvYmosIHN5bXNbal0pKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCgnWycgKyBpbnNwZWN0KHN5bXNbal0pICsgJ106ICcgKyBpbnNwZWN0KG9ialtzeW1zW2pdXSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoID0+IHtcblx0Y29uc3QgaXNFeHRlbmRlZExlbmd0aFBhdGggPSAvXlxcXFxcXFxcXFw/XFxcXC8udGVzdChwYXRoKTtcblx0Y29uc3QgaGFzTm9uQXNjaWkgPSAvW15cXHUwMDAwLVxcdTAwODBdKy8udGVzdChwYXRoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblx0aWYgKGlzRXh0ZW5kZWRMZW5ndGhQYXRoIHx8IGhhc05vbkFzY2lpKSB7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblxuXHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG59O1xuIiwiaW1wb3J0IHsgU0NIRU1FUyB9IGZyb20gXCIuL3VyaVwiO1xuXG5pbXBvcnQgaHR0cCBmcm9tIFwiLi9zY2hlbWVzL2h0dHBcIjtcblNDSEVNRVNbaHR0cC5zY2hlbWVdID0gaHR0cDtcblxuaW1wb3J0IGh0dHBzIGZyb20gXCIuL3NjaGVtZXMvaHR0cHNcIjtcblNDSEVNRVNbaHR0cHMuc2NoZW1lXSA9IGh0dHBzO1xuXG5pbXBvcnQgbWFpbHRvIGZyb20gXCIuL3NjaGVtZXMvbWFpbHRvXCI7XG5TQ0hFTUVTW21haWx0by5zY2hlbWVdID0gbWFpbHRvO1xuXG5pbXBvcnQgdXJuIGZyb20gXCIuL3NjaGVtZXMvdXJuXCI7XG5TQ0hFTUVTW3Vybi5zY2hlbWVdID0gdXJuO1xuXG5pbXBvcnQgdXVpZCBmcm9tIFwiLi9zY2hlbWVzL3Vybi11dWlkXCI7XG5TQ0hFTUVTW3V1aWQuc2NoZW1lXSA9IHV1aWQ7XG5cbmV4cG9ydCAqIGZyb20gXCIuL3VyaVwiO1xuIiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB7IFVSTkNvbXBvbmVudHMgfSBmcm9tIFwiLi91cm5cIjtcbmltcG9ydCB7IFNDSEVNRVMgfSBmcm9tIFwiLi4vdXJpXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVVJRENvbXBvbmVudHMgZXh0ZW5kcyBVUk5Db21wb25lbnRzIHtcblx0dXVpZD86IHN0cmluZztcbn1cblxuY29uc3QgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbmNvbnN0IFVVSURfUEFSU0UgPSAvXlswLTlBLUZhLWZcXC1dezM2fS87XG5cbi8vUkZDIDQxMjJcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxVVUlEQ29tcG9uZW50cywgVVJJT3B0aW9ucywgVVJOQ29tcG9uZW50cz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuOnV1aWRcIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uICh1cm5Db21wb25lbnRzOlVSTkNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVVJRENvbXBvbmVudHMge1xuXHRcdGNvbnN0IHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cyBhcyBVVUlEQ29tcG9uZW50cztcblx0XHR1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuXHRcdHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcblxuXHRcdGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG5cdFx0XHR1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHV1aWRDb21wb25lbnRzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZSA6IGZ1bmN0aW9uICh1dWlkQ29tcG9uZW50czpVVUlEQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUk5Db21wb25lbnRzIHtcblx0XHRjb25zdCB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHMgYXMgVVJOQ29tcG9uZW50cztcblx0XHQvL25vcm1hbGl6ZSBVVUlEXG5cdFx0dXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiB1cm5Db21wb25lbnRzO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUk5Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdG5pZD86c3RyaW5nO1xuXHRuc3M/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUk5PcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyB7XG5cdG5pZD86c3RyaW5nO1xufVxuXG5jb25zdCBOSUQkID0gXCIoPzpbMC05QS1aYS16XVswLTlBLVphLXpcXFxcLV17MSwzMX0pXCI7XG5jb25zdCBQQ1RfRU5DT0RFRCQgPSBcIig/OlxcXFwlWzAtOUEtRmEtZl17Mn0pXCI7XG5jb25zdCBUUkFOUyQkID0gXCJbMC05QS1aYS16XFxcXChcXFxcKVxcXFwrXFxcXCxcXFxcLVxcXFwuXFxcXDpcXFxcPVxcXFxAXFxcXDtcXFxcJFxcXFxfXFxcXCFcXFxcKlxcXFwnXFxcXC9cXFxcP1xcXFwjXVwiO1xuY29uc3QgTlNTJCA9IFwiKD86KD86XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFRSQU5TJCQgKyBcIikrKVwiO1xuY29uc3QgVVJOX1NDSEVNRSA9IG5ldyBSZWdFeHAoXCJedXJuXFxcXDooXCIgKyBOSUQkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVRIID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBOSUQkICsgXCIpXFxcXDooXCIgKyBOU1MkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG5jb25zdCBVUk5fRVhDTFVERUQgPSAvW1xceDAwLVxceDIwXFxcXFxcXCJcXCZcXDxcXD5cXFtcXF1cXF5cXGBcXHtcXHxcXH1cXH5cXHg3Ri1cXHhGRl0vZztcblxuLy9SRkMgMjE0MVxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVSTkNvbXBvbmVudHMsVVJOT3B0aW9ucz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG5cdFx0bGV0IHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0Y29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcblx0XHRcdGNvbnN0IG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IG5zcyA9IG1hdGNoZXNbMl07XG5cdFx0XHRjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWA7XG5cdFx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0XHR1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcblx0XHRcdHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuXHRcdFx0dXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0XHR1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0Y29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG5cdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG5cblx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVJJQ29tcG9uZW50cztcblx0XHRjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcblx0XHR1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWA7XG5cblx0XHRyZXR1cm4gdXJpQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB7IHBjdEVuY0NoYXIsIHBjdERlY0NoYXJzLCB1bmVzY2FwZUNvbXBvbmVudCB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCBwdW55Y29kZSBmcm9tIFwicHVueWNvZGVcIjtcbmltcG9ydCB7IG1lcmdlLCBzdWJleHAsIHRvVXBwZXJDYXNlLCB0b0FycmF5IH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNYWlsdG9IZWFkZXJzIHtcblx0W2hmbmFtZTpzdHJpbmddOnN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1haWx0b0NvbXBvbmVudHMgZXh0ZW5kcyBVUklDb21wb25lbnRzIHtcblx0dG86QXJyYXk8c3RyaW5nPixcblx0aGVhZGVycz86TWFpbHRvSGVhZGVycyxcblx0c3ViamVjdD86c3RyaW5nLFxuXHRib2R5PzpzdHJpbmdcbn1cblxuY29uc3QgTzpNYWlsdG9IZWFkZXJzID0ge307XG5jb25zdCBpc0lSSSA9IHRydWU7XG5cbi8vUkZDIDM5ODZcbmNvbnN0IFVOUkVTRVJWRUQkJCA9IFwiW0EtWmEtejAtOVxcXFwtXFxcXC5cXFxcX1xcXFx+XCIgKyAoaXNJUkkgPyBcIlxcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRlwiIDogXCJcIikgKyBcIl1cIjtcbmNvbnN0IEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAgLy9jYXNlLWluc2Vuc2l0aXZlXG5jb25zdCBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7ICAvL2V4cGFuZGVkXG5cbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbmNvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuY29uc3QgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiO1xuY29uc3QgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xuY29uc3QgRE9UX0FUT01fVEVYVCQgPSBzdWJleHAoQVRFWFQkJCArIFwiK1wiICsgc3ViZXhwKFwiXFxcXC5cIiArIEFURVhUJCQgKyBcIitcIikgKyBcIipcIik7XG5jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgVkNIQVIkJCk7XG5jb25zdCBRQ09OVEVOVCQgPSBzdWJleHAoUVRFWFQkJCArIFwifFwiICsgUVVPVEVEX1BBSVIkKTtcbmNvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgUUNPTlRFTlQkICsgXCIqXCIgKyAnXFxcXFwiJyk7XG5cbi8vUkZDIDYwNjhcbmNvbnN0IERURVhUX05PX09CUyQkID0gXCJbXFxcXHgyMS1cXFxceDVBXFxcXHg1RS1cXFxceDdFXVwiOyAgLy8lZDMzLTkwIC8gJWQ5NC0xMjZcbmNvbnN0IFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xuY29uc3QgUUNIQVIkID0gc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBTT01FX0RFTElNUyQkKTtcbmNvbnN0IERPTUFJTiQgPSBzdWJleHAoRE9UX0FUT01fVEVYVCQgKyBcInxcIiArIFwiXFxcXFtcIiArIERURVhUX05PX09CUyQkICsgXCIqXCIgKyBcIlxcXFxdXCIpO1xuY29uc3QgTE9DQUxfUEFSVCQgPSBzdWJleHAoRE9UX0FUT01fVEVYVCQgKyBcInxcIiArIFFVT1RFRF9TVFJJTkckKTtcbmNvbnN0IEFERFJfU1BFQyQgPSBzdWJleHAoTE9DQUxfUEFSVCQgKyBcIlxcXFxAXCIgKyBET01BSU4kKTtcbmNvbnN0IFRPJCA9IHN1YmV4cChBRERSX1NQRUMkICsgc3ViZXhwKFwiXFxcXCxcIiArIEFERFJfU1BFQyQpICsgXCIqXCIpO1xuY29uc3QgSEZOQU1FJCA9IHN1YmV4cChRQ0hBUiQgKyBcIipcIik7XG5jb25zdCBIRlZBTFVFJCA9IEhGTkFNRSQ7XG5jb25zdCBIRklFTEQkID0gc3ViZXhwKEhGTkFNRSQgKyBcIlxcXFw9XCIgKyBIRlZBTFVFJCk7XG5jb25zdCBIRklFTERTMiQgPSBzdWJleHAoSEZJRUxEJCArIHN1YmV4cChcIlxcXFwmXCIgKyBIRklFTEQkKSArIFwiKlwiKTtcbmNvbnN0IEhGSUVMRFMkID0gc3ViZXhwKFwiXFxcXD9cIiArIEhGSUVMRFMyJCk7XG5jb25zdCBNQUlMVE9fVVJJID0gbmV3IFJlZ0V4cChcIl5tYWlsdG9cXFxcOlwiICsgVE8kICsgXCI/XCIgKyBIRklFTERTJCArIFwiPyRcIik7XG5cbmNvbnN0IFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xuY29uc3QgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xuY29uc3QgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpO1xuY29uc3QgTk9UX0RPTUFJTiA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsIFwiW1xcXFxbXVwiLCBEVEVYVF9OT19PQlMkJCwgXCJbXFxcXF1dXCIpLCBcImdcIik7XG5jb25zdCBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG5jb25zdCBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUU7XG5jb25zdCBUTyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBUTyQgKyBcIiRcIik7XG5jb25zdCBIRklFTERTID0gbmV3IFJlZ0V4cChcIl5cIiArIEhGSUVMRFMyJCArIFwiJFwiKTtcblxuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRjb25zdCBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuXHRyZXR1cm4gKCFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHIpO1xufVxuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXI8TWFpbHRvQ29tcG9uZW50cz4gPSAge1xuXHRzY2hlbWUgOiBcIm1haWx0b1wiLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpNYWlsdG9Db21wb25lbnRzIHtcblx0XHRjb25zdCBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cyBhcyBNYWlsdG9Db21wb25lbnRzO1xuXHRcdGNvbnN0IHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IChtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW10pO1xuXHRcdG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcblxuXHRcdGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG5cdFx0XHRsZXQgdW5rbm93bkhlYWRlcnMgPSBmYWxzZVxuXHRcdFx0Y29uc3QgaGVhZGVyczpNYWlsdG9IZWFkZXJzID0ge307XG5cdFx0XHRjb25zdCBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG5cblx0XHRcdGZvciAobGV0IHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRjb25zdCBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcblxuXHRcdFx0XHRzd2l0Y2ggKGhmaWVsZFswXSkge1xuXHRcdFx0XHRcdGNhc2UgXCJ0b1wiOlxuXHRcdFx0XHRcdFx0Y29uc3QgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0b0FkZHJzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0XHRcdFx0dG8ucHVzaCh0b0FkZHJzW3hdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJzdWJqZWN0XCI6XG5cdFx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImJvZHlcIjpcblx0XHRcdFx0XHRcdG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dW5rbm93bkhlYWRlcnMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodW5rbm93bkhlYWRlcnMpIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0fVxuXG5cdFx0bWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcblxuXHRcdGZvciAobGV0IHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdGNvbnN0IGFkZHIgPSB0b1t4XS5zcGxpdChcIkBcIik7XG5cblx0XHRcdGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcblxuXHRcdFx0aWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG5cdFx0XHRcdC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0dG9beF0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZSA6IGZ1bmN0aW9uIChtYWlsdG9Db21wb25lbnRzOk1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHMgYXMgVVJJQ29tcG9uZW50cztcblx0XHRjb25zdCB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG5cdFx0aWYgKHRvKSB7XG5cdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdGNvbnN0IHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG5cdFx0XHRcdGNvbnN0IGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcblx0XHRcdFx0Y29uc3QgbG9jYWxQYXJ0ID0gKHRvQWRkci5zbGljZSgwLCBhdElkeCkpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcblx0XHRcdFx0bGV0IGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuXG5cdFx0XHRcdC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZG9tYWluID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcblxuXHRcdGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuXHRcdGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuXG5cdFx0Y29uc3QgZmllbGRzID0gW107XG5cdFx0Zm9yIChjb25zdCBuYW1lIGluIGhlYWRlcnMpIHtcblx0XHRcdGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG5cdFx0XHRcdGZpZWxkcy5wdXNoKFxuXHRcdFx0XHRcdG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgK1xuXHRcdFx0XHRcdFwiPVwiICtcblx0XHRcdFx0XHRoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZmllbGRzLmxlbmd0aCkge1xuXHRcdFx0Y29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgaHR0cCBmcm9tIFwiLi9odHRwXCI7XG5cbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlciA9IHtcblx0c2NoZW1lIDogXCJodHRwc1wiLFxuXHRkb21haW5Ib3N0IDogaHR0cC5kb21haW5Ib3N0LFxuXHRwYXJzZSA6IGh0dHAucGFyc2UsXG5cdHNlcmlhbGl6ZSA6IGh0dHAuc2VyaWFsaXplXG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyID0ge1xuXHRzY2hlbWUgOiBcImh0dHBcIixcblxuXHRkb21haW5Ib3N0IDogdHJ1ZSxcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVJJQ29tcG9uZW50cyB7XG5cdFx0Ly9yZXBvcnQgbWlzc2luZyBob3N0XG5cdFx0aWYgKCFjb21wb25lbnRzLmhvc3QpIHtcblx0XHRcdGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHQvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG5cdFx0aWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSAhPT0gXCJodHRwc1wiID8gODAgOiA0NDMpIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuXHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRcblx0XHQvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuXHRcdGlmICghY29tcG9uZW50cy5wYXRoKSB7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcblx0XHR9XG5cblx0XHQvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcblx0XHQvL2FzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuXHRcdC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cblxuaW1wb3J0IFVSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLXVyaVwiO1xuaW1wb3J0IElSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLWlyaVwiO1xuaW1wb3J0IHB1bnljb2RlIGZyb20gXCJwdW55Y29kZVwiO1xuaW1wb3J0IHsgdG9VcHBlckNhc2UsIHR5cGVPZiwgYXNzaWduIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVSSUNvbXBvbmVudHMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0dXNlcmluZm8/OnN0cmluZztcblx0aG9zdD86c3RyaW5nO1xuXHRwb3J0PzpudW1iZXJ8c3RyaW5nO1xuXHRwYXRoPzpzdHJpbmc7XG5cdHF1ZXJ5PzpzdHJpbmc7XG5cdGZyYWdtZW50PzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHRlcnJvcj86c3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSU9wdGlvbnMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0cmVmZXJlbmNlPzpzdHJpbmc7XG5cdHRvbGVyYW50Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG5cdGlyaT86Ym9vbGVhbjtcblx0dW5pY29kZVN1cHBvcnQ/OmJvb2xlYW47XG5cdGRvbWFpbkhvc3Q/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJU2NoZW1lSGFuZGxlcjxDb21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyA9IFVSSUNvbXBvbmVudHMsIE9wdGlvbnMgZXh0ZW5kcyBVUklPcHRpb25zID0gVVJJT3B0aW9ucywgUGFyZW50Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzPiB7XG5cdHNjaGVtZTpzdHJpbmc7XG5cdHBhcnNlKGNvbXBvbmVudHM6UGFyZW50Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpDb21wb25lbnRzO1xuXHRzZXJpYWxpemUoY29tcG9uZW50czpDb21wb25lbnRzLCBvcHRpb25zOk9wdGlvbnMpOlBhcmVudENvbXBvbmVudHM7XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJUmVnRXhwcyB7XG5cdE5PVF9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9VU0VSSU5GTyA6IFJlZ0V4cCxcblx0Tk9UX0hPU1QgOiBSZWdFeHAsXG5cdE5PVF9QQVRIIDogUmVnRXhwLFxuXHROT1RfUEFUSF9OT1NDSEVNRSA6IFJlZ0V4cCxcblx0Tk9UX1FVRVJZIDogUmVnRXhwLFxuXHROT1RfRlJBR01FTlQgOiBSZWdFeHAsXG5cdEVTQ0FQRSA6IFJlZ0V4cCxcblx0VU5SRVNFUlZFRCA6IFJlZ0V4cCxcblx0T1RIRVJfQ0hBUlMgOiBSZWdFeHAsXG5cdFBDVF9FTkNPREVEIDogUmVnRXhwLFxuXHRJUFY0QUREUkVTUyA6IFJlZ0V4cCxcblx0SVBWNkFERFJFU1MgOiBSZWdFeHAsXG59XG5cbmV4cG9ydCBjb25zdCBTQ0hFTUVTOntbc2NoZW1lOnN0cmluZ106VVJJU2NoZW1lSGFuZGxlcn0gPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuXHRsZXQgZTpzdHJpbmc7XG5cblx0aWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoKGMgPj4gNikgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGUgPSBcIiVcIiArICgoYyA+PiAxMikgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKChjID4+IDYpICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuXHRyZXR1cm4gZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdGxldCBuZXdTdHIgPSBcIlwiO1xuXHRsZXQgaSA9IDA7XG5cdGNvbnN0IGlsID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaSA8IGlsKSB7XG5cdFx0Y29uc3QgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG5cblx0XHRpZiAoYyA8IDEyOCkge1xuXHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG5cdFx0XHRpICs9IDM7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA2KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA2O1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDIyNCkge1xuXHRcdFx0aWYgKChpbCAtIGkpID49IDkpIHtcblx0XHRcdFx0Y29uc3QgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuXHRcdFx0XHRjb25zdCBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA5O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdTdHI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIHByb3RvY29sOlVSSVJlZ0V4cHMpIHtcblx0ZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRcdGNvbnN0IGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG5cdFx0cmV0dXJuICghZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcblx0aWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzc10gPSBtYXRjaGVzO1xuXHRcblx0aWYgKGFkZHJlc3MpIHtcblx0XHRyZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzcywgem9uZV0gPSBtYXRjaGVzO1xuXG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0Y29uc3QgW2xhc3QsIGZpcnN0XSA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCk7XG5cdFx0Y29uc3QgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuXHRcdGNvbnN0IGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcblx0XHRjb25zdCBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuXHRcdGNvbnN0IGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG5cdFx0Y29uc3QgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuXHRcdGNvbnN0IGZpZWxkcyA9IEFycmF5PHN0cmluZz4oZmllbGRDb3VudCk7XG5cblx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuXHRcdFx0ZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcblx0XHR9XG5cblx0XHRpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuXHRcdFx0ZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHRjb25zdCBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZTxBcnJheTx7aW5kZXg6bnVtYmVyLGxlbmd0aDpudW1iZXJ9Pj4oKGFjYywgZmllbGQsIGluZGV4KSA9PiB7XG5cdFx0XHRpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuXHRcdFx0XHRjb25zdCBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcblx0XHRcdFx0XHRsYXN0TG9uZ2VzdC5sZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY2MucHVzaCh7IGluZGV4LCBsZW5ndGggOiAxIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIFtdKTtcblxuXHRcdGNvbnN0IGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVswXTtcblxuXHRcdGxldCBuZXdIb3N0OnN0cmluZztcblx0XHRpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Y29uc3QgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpIDtcblx0XHRcdGNvbnN0IG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuXHRcdFx0bmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcblx0XHR9XG5cblx0XHRpZiAoem9uZSkge1xuXHRcdFx0bmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld0hvc3Q7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG5jb25zdCBOT19NQVRDSF9JU19VTkRFRklORUQgPSAoPFJlZ0V4cE1hdGNoQXJyYXk+KFwiXCIpLm1hdGNoKC8oKXswfS8pKVsxXSA9PT0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nOnN0cmluZywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCBjb21wb25lbnRzOlVSSUNvbXBvbmVudHMgPSB7fTtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcblxuXHRjb25zdCBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG5cblx0aWYgKG1hdGNoZXMpIHtcblx0XHRpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG5cdFx0XHQvL3N0b3JlIGVhY2ggY29tcG9uZW50XG5cdFx0XHRjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcblx0XHRcdGNvbXBvbmVudHMudXNlcmluZm8gPSAodXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSAodXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQpO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gKHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29tcG9uZW50cy5ob3N0KSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBJUCBob3N0c1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHQvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuXHRcdGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuXHRcdH1cblxuXHRcdC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcblx0XHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG5cdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuXHRcdH1cblxuXHRcdC8vZmluZCBzY2hlbWUgaGFuZGxlclxuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHRcdC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG5cdFx0aWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcblx0XHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdFx0aWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpKSB7XG5cdFx0XHRcdC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly9jb252ZXJ0IElSSSAtPiBVUklcblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBlbmNvZGluZ3Ncblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG5cdFx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuXHRcdFx0c2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG5cdH1cblxuXHRyZXR1cm4gY29tcG9uZW50cztcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOnN0cmluZ3x1bmRlZmluZWQge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0wpO1xuXHRjb25zdCB1cmlUb2tlbnM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcblx0XHR1cmlUb2tlbnMucHVzaChcIkBcIik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcblx0XHR1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgKF8sICQxLCAkMikgPT4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCIpKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucG9ydC50b1N0cmluZygxMCkpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xuY29uc3QgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG5jb25zdCBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbmNvbnN0IFJEUzQgPSAvXlxcLlxcLj8kLztcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dDpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IG91dHB1dDpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuXHRcdGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG5cdFx0fSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcblx0XHRcdG91dHB1dC5wb3AoKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG5cdFx0XHRpbnB1dCA9IFwiXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG5cdFx0XHRpZiAoaW0pIHtcblx0XHRcdFx0Y29uc3QgcyA9IGltWzBdO1xuXHRcdFx0XHRpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcblx0XHRcdFx0b3V0cHV0LnB1c2gocyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOnN0cmluZyB7XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuXG5cdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuXHRpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG5cdFx0aWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge1xuXHRcdFx0Ly9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXHRcdH1cblxuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG5cdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9ub3JtYWxpemUgZW5jb2Rpbmdcblx0X25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHR9XG5cblx0Y29uc3QgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0aWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG5cblx0XHRpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi9cIik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bGV0IHMgPSBjb21wb25lbnRzLnBhdGg7XG5cblx0XHRpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG5cdFx0XHRzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG5cdFx0fVxuXG5cdFx0aWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKHMpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIiNcIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG5cdH1cblxuXHRyZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7ICAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZTpVUklDb21wb25lbnRzLCByZWxhdGl2ZTpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMgPSB7fSwgc2tpcE5vcm1hbGl6YXRpb24/OmJvb2xlYW4pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCB0YXJnZXQ6VVJJQ29tcG9uZW50cyA9IHt9O1xuXG5cdGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcblx0XHRiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgIC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuXHRcdHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG5cdH1cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuXHRcdHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG5cdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuXHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHR0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG5cdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHR9IGVsc2Uge1xuXHRcdGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghcmVsYXRpdmUucGF0aCkge1xuXHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG5cdFx0XHR0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcblx0XHR9XG5cdFx0dGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuXHR9XG5cblx0dGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGJhc2VVUkk6c3RyaW5nLCByZWxhdGl2ZVVSSTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lIDogJ251bGwnIH0sIG9wdGlvbnMpO1xuXHRyZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodXJpOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHM7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmFueSB7XG5cdGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpID0gcGFyc2Uoc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOnN0cmluZywgdXJpQjpzdHJpbmcsIG9wdGlvbnM/OiBVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6VVJJQ29tcG9uZW50cywgdXJpQjpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6YW55LCB1cmlCOmFueSwgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbiB7XG5cdGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUoPFVSSUNvbXBvbmVudHM+dXJpQSwgb3B0aW9ucyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaUEgPT09IHVyaUI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0cjpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUpLCBwY3RFbmNDaGFyKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCksIHBjdERlY0NoYXJzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGFycmF5ID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG5jb25zdCBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGxldCBvbGRpID0gaTtcblx0XHRmb3IgKGxldCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdGxldCBtID0gbWF4SW50O1xuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHRjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IGJ1aWxkRXhwcyB9IGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyh0cnVlKTtcbiIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IG1lcmdlLCBzdWJleHAgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHMoaXNJUkk6Ym9vbGVhbik6VVJJUmVnRXhwcyB7XG5cdGNvbnN0XG5cdFx0QUxQSEEkJCA9IFwiW0EtWmEtel1cIixcblx0XHRDUiQgPSBcIltcXFxceDBEXVwiLFxuXHRcdERJR0lUJCQgPSBcIlswLTldXCIsXG5cdFx0RFFVT1RFJCQgPSBcIltcXFxceDIyXVwiLFxuXHRcdEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSwgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdExGJCQgPSBcIltcXFxceDBBXVwiLFxuXHRcdFNQJCQgPSBcIltcXFxceDIwXVwiLFxuXHRcdFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSwgIC8vZXhwYW5kZWRcblx0XHRHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcblx0XHRTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuXHRcdFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksXG5cdFx0VUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsICAvL3N1YnNldCwgZXhjbHVkZXMgYmlkaSBjb250cm9sIGNoYXJhY3RlcnNcblx0XHRJUFJJVkFURSQkID0gaXNJUkkgPyBcIltcXFxcdUUwMDAtXFxcXHVGOEZGXVwiIDogXCJbXVwiLCAgLy9zdWJzZXRcblx0XHRVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcblx0XHRTQ0hFTUUkID0gc3ViZXhwKEFMUEhBJCQgKyBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpICsgXCIqXCIpLFxuXHRcdFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcblx0XHRERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcblx0XHRERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLCAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcblx0XHRIMTYkID0gc3ViZXhwKEhFWERJRyQkICsgXCJ7MSw0fVwiKSxcblx0XHRMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuXHRcdElQVjZBRERSRVNTMSQgPSBzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSwgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1MyJCA9IHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLCAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSwgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArICAgICAgICBIMTYkICsgXCJcXFxcOlwiICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG5cdFx0SVBWNkFERFJFU1M3JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw0fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgTFMzMiQpLCAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuXHRcdElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIEgxNiQgKSwgLy9bICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuXHRcdElQVjZBRERSRVNTOSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSwgLy9bICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcblx0XHRJUFY2QUREUkVTUyQgPSBzdWJleHAoW0lQVjZBRERSRVNTMSQsIElQVjZBRERSRVNTMiQsIElQVjZBRERSRVNTMyQsIElQVjZBRERSRVNTNCQsIElQVjZBRERSRVNTNSQsIElQVjZBRERSRVNTNiQsIElQVjZBRERSRVNTNyQsIElQVjZBRERSRVNTOCQsIElQVjZBRERSRVNTOSRdLmpvaW4oXCJ8XCIpKSxcblx0XHRaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksICAvL1JGQyA2ODc0XG5cdFx0SVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NFxuXHRcdElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLCAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0XHRJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcblx0XHRJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSwgIC8vUkZDIDY4NzRcblx0XHRSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcblx0XHRIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuXHRcdFBPUlQkID0gc3ViZXhwKERJR0lUJCQgKyBcIipcIiksXG5cdFx0QVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG5cdFx0UENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcblx0XHRTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksXG5cdFx0U0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuXHRcdFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuXHRcdFBBVEhfQUJFTVBUWSQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cIiArIFNFR01FTlQkKSArIFwiKlwiKSxcblx0XHRQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfTk9TQ0hFTUUkID0gc3ViZXhwKFNFR01FTlRfTlpfTkMkICsgUEFUSF9BQkVNUFRZJCksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG5cdFx0UEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFFVRVJZJCA9IHN1YmV4cChzdWJleHAoUENIQVIkICsgXCJ8XCIgKyBtZXJnZShcIltcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSkgKyBcIipcIiksXG5cdFx0RlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG5cdFx0SElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFVSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0UkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcblx0XHRSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG5cdFx0VVJJX1JFRkVSRU5DRSQgPSBzdWJleHAoVVJJJCArIFwifFwiICsgUkVMQVRJVkUkKSxcblx0XHRBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG5cblx0XHRHRU5FUklDX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0UkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRTQU1FRE9DX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCJcblx0O1xuXG5cdHJldHVybiB7XG5cdFx0Tk9UX1NDSEVNRSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSwgXCJnXCIpLFxuXHRcdE5PVF9VU0VSSU5GTyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9IT1NUIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcW1xcXFxdXFxcXDpdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9QQVRIX05PU0NIRU1FIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHROT1RfUVVFUlkgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuXHRcdE5PVF9GUkFHTUVOVCA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIpLCBcImdcIiksXG5cdFx0RVNDQVBFIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcblx0XHRVTlJFU0VSVkVEIDogbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKSxcblx0XHRPVEhFUl9DSEFSUyA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFJFU0VSVkVEJCQpLCBcImdcIiksXG5cdFx0UENUX0VOQ09ERUQgOiBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpLFxuXHRcdElQVjRBRERSRVNTIDogbmV3IFJlZ0V4cChcIl4oXCIgKyBJUFY0QUREUkVTUyQgKyBcIikkXCIpLFxuXHRcdElQVjZBRERSRVNTIDogbmV3IFJlZ0V4cChcIl5cXFxcWz8oXCIgKyBJUFY2QUREUkVTUyQgKyBcIilcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIikgIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyhmYWxzZSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gbWVyZ2UoLi4uc2V0czpBcnJheTxzdHJpbmc+KTpzdHJpbmcge1xuXHRpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG5cdFx0c2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuXHRcdGNvbnN0IHhsID0gc2V0cy5sZW5ndGggLSAxO1xuXHRcdGZvciAobGV0IHggPSAxOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0c2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuXHRcdH1cblx0XHRzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuXHRcdHJldHVybiBzZXRzLmpvaW4oJycpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzZXRzWzBdO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJleHAoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZihvOmFueSk6c3RyaW5nIHtcblx0cmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiAobyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkob2JqOmFueSk6QXJyYXk8YW55PiB7XG5cdHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyAob2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiAodHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSkpIDogW107XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IG9iamVjdCwgc291cmNlOiBhbnkpOiBhbnkge1xuXHRjb25zdCBvYmogPSB0YXJnZXQgYXMgYW55O1xuXHRpZiAoc291cmNlKSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb2JqO1xufSIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uYW1kTyA9IHt9OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgdXNlZCAnbW9kdWxlJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjk4Nyk7XG4iLCIiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJnbCIsInBhdGgiLCJQYXRoTG9hZGVyIiwicXMiLCJzbGFzaCIsIlVSSSIsImJhZFB0clRva2VuUmVnZXgiLCJyZW1vdGVDYWNoZSIsInJlbW90ZVR5cGVzIiwicmVtb3RlVXJpVHlwZXMiLCJ1cmlEZXRhaWxzQ2FjaGUiLCJQcm9taXNlIiwiY29tYmluZVF1ZXJ5UGFyYW1zIiwicXMxIiwicXMyIiwiY29tYmluZWQiLCJtZXJnZVF1ZXJ5UGFyYW1zIiwib2JqIiwiZm9yT3duIiwidmFsIiwia2V5IiwicGFyc2UiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwic3RyaW5naWZ5IiwiY29tYmluZVVSSXMiLCJ1MSIsInUyIiwiaXNTdHJpbmciLCJ1MkRldGFpbHMiLCJwYXJzZVVSSSIsImlzVW5kZWZpbmVkIiwidTFEZXRhaWxzIiwiY29tYmluZWREZXRhaWxzIiwiaW5kZXhPZiIsInJlZmVyZW5jZSIsImpvaW4iLCJxdWVyeSIsImZyYWdtZW50Iiwic2VyaWFsaXplIiwiZmluZEFuY2VzdG9ycyIsImFuY2VzdG9ycyIsIm5vZGUiLCJzbGljZSIsImZvckVhY2giLCJzZWciLCJwdXNoIiwiaXNSZW1vdGUiLCJyZWZEZXRhaWxzIiwiZ2V0UmVmVHlwZSIsImlzVmFsaWQiLCJlcnJvciIsInR5cGUiLCJmaW5kVmFsdWUiLCJ2YWx1ZSIsIkVycm9yIiwicGF0aFRvUHRyIiwiZ2V0RXh0cmFSZWZLZXlzIiwicmVmIiwiZmlsdGVyIiwidXJpRGV0YWlscyIsImdldFJlbW90ZURvY3VtZW50IiwidXJsIiwib3B0aW9ucyIsImNhY2hlRW50cnkiLCJhbGxUYXNrcyIsInJlc29sdmUiLCJsb2FkZXJPcHRpb25zIiwiY2xvbmVEZWVwIiwicHJvY2Vzc0NvbnRlbnQiLCJyZXMiLCJjYWxsYmFjayIsIkpTT04iLCJ0ZXh0IiwibG9hZCIsImRlY29kZVVSSSIsInRoZW4iLCJlcnIiLCJpc0Vycm9yIiwiaXNSZWZMaWtlIiwidGhyb3dXaXRoRGV0YWlscyIsInJlZkxpa2UiLCJpc1BsYWluT2JqZWN0IiwiJHJlZiIsIm1ha2VBYnNvbHV0ZSIsImxvY2F0aW9uIiwiaXNBYnNvbHV0ZSIsInByb2Nlc3MiLCJjd2QiLCJtYWtlUmVmRmlsdGVyIiwicmVmRmlsdGVyIiwidmFsaWRUeXBlcyIsImlzQXJyYXkiLCJpc0Z1bmN0aW9uIiwiaW5jbHVkZUludmFsaWQiLCJtYWtlU3ViRG9jUGF0aCIsInN1YkRvY1BhdGgiLCJwYXRoRnJvbVB0ciIsIm1hcmtNaXNzaW5nIiwibWVzc2FnZSIsIm1pc3NpbmciLCJ1cmkiLCJidWlsZFJlZk1vZGVsIiwiZG9jdW1lbnQiLCJtZXRhZGF0YSIsInN1YkRvY1B0ciIsImFic0xvY2F0aW9uIiwicmVsYXRpdmVCYXNlIiwiZGlybmFtZSIsImRvY0RlcEtleSIsInJlZnMiLCJyT3B0aW9ucyIsImRvY3MiLCJkZXBzIiwiZmluZFJlZnMiLCJyZWZQdHIiLCJyZWZLZXkiLCJyZWZkS2V5IiwicmVmZElkIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3BsaXQiLCJmcVVSSSIsInJlcGxhY2UiLCJjaXJjdWxhciIsIm5NZXRhZGF0YSIsIm5PcHRpb25zIiwickFic0xvY2F0aW9uIiwickRvYyIsIm5SZWZEZXRhaWxzIiwiZG9jIiwic2V0VmFsdWUiLCJyZWZQYXRoIiwid2FsayIsImZuIiwicHJvY2Vzc0NoaWxkcmVuIiwid2Fsa0l0ZW0iLCJpdGVtIiwic2VnbWVudCIsInBvcCIsIm1lbWJlciIsImluZGV4IiwidG9TdHJpbmciLCJpc09iamVjdCIsImNOb2RlIiwidmFsaWRhdGVPcHRpb25zIiwibG9jYXRpb25QYXJ0cyIsInNob3VsZERlY29kZSIsIlR5cGVFcnJvciIsInJlc29sdmVDaXJjdWxhcnMiLCJpc0Jvb2xlYW4iLCJyZWZQcmVQcm9jZXNzb3IiLCJyZWZQb3N0UHJvY2Vzc29yIiwiaXNQdHIiLCJkZWNvZGVQYXRoIiwibWFwIiwiZW5jb2RlUGF0aCIsImdldFJlZkRldGFpbHMiLCJmaW5kUmVmc0F0IiwiY09wdGlvbnMiLCJkZXRhaWxzIiwiZGVmIiwiY2FjaGVLZXkiLCJleHRyYUtleXMiLCJ3YXJuaW5nIiwicHRyIiwidmFsaWQiLCJmaXJzdENoYXIiLCJjaGFyQXQiLCJtYXRjaCIsImlzUmVmIiwic2VnbWVudHMiLCJzaGlmdCIsImhhc2hQcmVmaXgiLCJyZXNvbHZlUmVmcyIsInJlc3VsdHMiLCJhbGxSZWZzIiwiY2lyY3VsYXJQYXRocyIsImNpcmN1bGFycyIsImRlcEdyYXBoIiwiR3JhcGgiLCJmdWxsTG9jYXRpb24iLCJyZWZzUm9vdCIsInNldE5vZGUiLCJwcm9wcyIsImRlcCIsInNldEVkZ2UiLCJhbGciLCJmaW5kQ3ljbGVzIiwicHJvcCIsImlzQ2lyY3VsYXIiLCJyZW1vdGUiLCJwYXRoSW5kZXgiLCJyZXZlcnNlIiwicGFyZW50UHRyIiwicFB0clBhcnRzIiwicERvY3VtZW50IiwicFB0clBhdGgiLCJkZXBQYXJ0cyIsInNwbGl0RnJhZ21lbnQiLCJkRG9jdW1lbnQiLCJkUHRyUGF0aCIsImNvbmNhdCIsIndhbGtSZWZzIiwicm9vdCIsInJlZlB0clBhcnRzIiwicmVmRGVwcyIsInN1YnN0ciIsImZxVVJJU2VnbWVudHMiLCJ1cmlTZWdtZW50cyIsInRpbWVzIiwidGltZSIsIm5TZWciLCJwU2VnIiwiZnFTZWdJbmRleCIsInJlc29sdmVkIiwicmVzb2x2ZVJlZnNBdCIsInJlczIiLCJoYXNoIiwicGFydHMiLCJzdWJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIiwiY2xlYXJDYWNoZSIsIkdldEludHJpbnNpYyIsImNhbGxCaW5kIiwiJGluZGV4T2YiLCJjYWxsQm91bmRJbnRyaW5zaWMiLCJuYW1lIiwiYWxsb3dNaXNzaW5nIiwiaW50cmluc2ljIiwiYmluZCIsInNldEZ1bmN0aW9uTGVuZ3RoIiwiJFR5cGVFcnJvciIsIiRhcHBseSIsIiRjYWxsIiwiJHJlZmxlY3RBcHBseSIsImNhbGwiLCIkZGVmaW5lUHJvcGVydHkiLCIkbWF4Iiwib3JpZ2luYWxGdW5jdGlvbiIsImZ1bmMiLCJhcmd1bWVudHMiLCJhcHBseUJpbmQiLCJhcHBseSIsIiRTeW50YXhFcnJvciIsImdvcGQiLCJkZWZpbmVEYXRhUHJvcGVydHkiLCJwcm9wZXJ0eSIsIm5vbkVudW1lcmFibGUiLCJub25Xcml0YWJsZSIsIm5vbkNvbmZpZ3VyYWJsZSIsImxvb3NlIiwiZGVzYyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImUiLCJFdmFsRXJyb3IiLCJSYW5nZUVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJTeW50YXhFcnJvciIsIlVSSUVycm9yIiwic3RhYmxlIiwiZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSIsInN0YWJsZVN0cmluZ2lmeSIsIkxJTUlUX1JFUExBQ0VfTk9ERSIsIkNJUkNVTEFSX1JFUExBQ0VfTk9ERSIsImFyciIsInJlcGxhY2VyU3RhY2siLCJkZWZhdWx0T3B0aW9ucyIsImRlcHRoTGltaXQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZWRnZXNMaW1pdCIsInJlcGxhY2VyIiwic3BhY2VyIiwiZGVjaXJjIiwicmVwbGFjZUdldHRlclZhbHVlcyIsInBhcnQiLCJkZWZpbmVQcm9wZXJ0eSIsInNldFJlcGxhY2UiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJBcnJheSIsImNvbXBhcmVGdW5jdGlvbiIsImEiLCJiIiwidG1wIiwiZGV0ZXJtaW5pc3RpY0RlY2lyYyIsInRvSlNPTiIsInNvcnQiLCJ2Iiwic3BsaWNlIiwiRVJST1JfTUVTU0FHRSIsInRvU3RyIiwicHJvdG90eXBlIiwibWF4IiwiTWF0aCIsImZ1bmNUeXBlIiwiY29uY2F0dHkiLCJqIiwic2xpY3kiLCJhcnJMaWtlIiwib2Zmc2V0Iiwiam9pbnkiLCJqb2luZXIiLCJzdHIiLCJ0aGF0IiwidGFyZ2V0IiwiYXJncyIsImJvdW5kIiwiYmluZGVyIiwicmVzdWx0IiwiYm91bmRMZW5ndGgiLCJib3VuZEFyZ3MiLCJGdW5jdGlvbiIsIkVtcHR5IiwiaW1wbGVtZW50YXRpb24iLCIkRXJyb3IiLCIkRXZhbEVycm9yIiwiJFJhbmdlRXJyb3IiLCIkUmVmZXJlbmNlRXJyb3IiLCIkVVJJRXJyb3IiLCIkRnVuY3Rpb24iLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJleHByZXNzaW9uU3ludGF4IiwiJGdPUEQiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1N5bWJvbHMiLCJoYXNQcm90byIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJ4IiwiX19wcm90b19fIiwibmVlZHNFdmFsIiwiVHlwZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJJTlRSSU5TSUNTIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiQXRvbWljcyIsIkJpZ0ludCIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsIkJvb2xlYW4iLCJEYXRhVmlldyIsIkRhdGUiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiaXNOYU4iLCJNYXAiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJQcm94eSIsIlJlZmxlY3QiLCJSZWdFeHAiLCJTZXQiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIlN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIldlYWtNYXAiLCJXZWFrUmVmIiwiV2Vha1NldCIsImVycm9yUHJvdG8iLCJkb0V2YWwiLCJnZW4iLCJMRUdBQ1lfQUxJQVNFUyIsImhhc093biIsIiRjb25jYXQiLCIkc3BsaWNlQXBwbHkiLCIkcmVwbGFjZSIsIiRzdHJTbGljZSIsIiRleGVjIiwiZXhlYyIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJzdHJpbmciLCJmaXJzdCIsImxhc3QiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImdldEJhc2VJbnRyaW5zaWMiLCJpbnRyaW5zaWNOYW1lIiwiYWxpYXMiLCJpbnRyaW5zaWNCYXNlTmFtZSIsImludHJpbnNpY1JlYWxOYW1lIiwic2tpcEZ1cnRoZXJDYWNoaW5nIiwiaXNPd24iLCJsaWIiLCJqc29uIiwidmVyc2lvbiIsImNvbXBvbmVudHMiLCJnIiwidmlzaXRlZCIsImNtcHRzIiwiY21wdCIsImRmcyIsImhhcyIsImVhY2giLCJzdWNjZXNzb3JzIiwicHJlZGVjZXNzb3JzIiwibm9kZXMiLCJ2cyIsIm9yZGVyIiwibmF2aWdhdGlvbiIsImlzRGlyZWN0ZWQiLCJuZWlnaGJvcnMiLCJhY2MiLCJoYXNOb2RlIiwiZG9EZnMiLCJwb3N0b3JkZXIiLCJ3IiwiZGlqa3N0cmEiLCJkaWprc3RyYUFsbCIsIndlaWdodEZ1bmMiLCJlZGdlRnVuYyIsInRyYW5zZm9ybSIsIlByaW9yaXR5UXVldWUiLCJERUZBVUxUX1dFSUdIVF9GVU5DIiwiY29uc3RhbnQiLCJzb3VyY2UiLCJ3ZWlnaHRGbiIsImVkZ2VGbiIsInJ1bkRpamtzdHJhIiwib3V0RWRnZXMiLCJwcSIsInZFbnRyeSIsInVwZGF0ZU5laWdoYm9ycyIsImVkZ2UiLCJ3RW50cnkiLCJ3ZWlnaHQiLCJkaXN0YW5jZSIsInByZWRlY2Vzc29yIiwiZGVjcmVhc2UiLCJQT1NJVElWRV9JTkZJTklUWSIsImFkZCIsInNpemUiLCJyZW1vdmVNaW4iLCJ0YXJqYW4iLCJoYXNFZGdlIiwiZmxveWRXYXJzaGFsbCIsInJ1bkZsb3lkV2Fyc2hhbGwiLCJkIiwicm93SyIsInJvd0kiLCJpayIsImtqIiwiaWoiLCJhbHREaXN0YW5jZSIsImlzQWN5Y2xpYyIsInByZW9yZGVyIiwicHJpbSIsInRvcHNvcnQiLCJDeWNsZUV4Y2VwdGlvbiIsInBhcmVudHMiLCJwcmkiLCJwcmlvcml0eSIsImVkZ2VXZWlnaHQiLCJub2RlQ291bnQiLCJpbml0Iiwibm9kZUVkZ2VzIiwiZW50cnkiLCJvblN0YWNrIiwibG93bGluayIsIm1pbiIsInZpc2l0Iiwic2lua3MiLCJfYXJyIiwiX2tleUluZGljZXMiLCJrZXlJbmRpY2VzIiwiX2RlY3JlYXNlIiwiX3N3YXAiLCJfaGVhcGlmeSIsImwiLCJyIiwibGFyZ2VzdCIsIm9yaWdBcnJJIiwib3JpZ0FyckoiLCJERUZBVUxUX0VER0VfTkFNRSIsIkdSQVBIX05PREUiLCJFREdFX0tFWV9ERUxJTSIsIm9wdHMiLCJfaXNEaXJlY3RlZCIsImRpcmVjdGVkIiwiX2lzTXVsdGlncmFwaCIsIm11bHRpZ3JhcGgiLCJfaXNDb21wb3VuZCIsImNvbXBvdW5kIiwiX2xhYmVsIiwiX2RlZmF1bHROb2RlTGFiZWxGbiIsIl9kZWZhdWx0RWRnZUxhYmVsRm4iLCJfbm9kZXMiLCJfcGFyZW50IiwiX2NoaWxkcmVuIiwiX2luIiwiX3ByZWRzIiwiX291dCIsIl9zdWNzIiwiX2VkZ2VPYmpzIiwiX2VkZ2VMYWJlbHMiLCJfbm9kZUNvdW50IiwiX2VkZ2VDb3VudCIsImlzTXVsdGlncmFwaCIsImlzQ29tcG91bmQiLCJzZXRHcmFwaCIsImxhYmVsIiwiZ3JhcGgiLCJzZXREZWZhdWx0Tm9kZUxhYmVsIiwibmV3RGVmYXVsdCIsInNvdXJjZXMiLCJzZWxmIiwiaXNFbXB0eSIsInNldE5vZGVzIiwicmVtb3ZlTm9kZSIsInJlbW92ZUVkZ2UiLCJfcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3QiLCJjaGlsZHJlbiIsImNoaWxkIiwic2V0UGFyZW50IiwiYW5jZXN0b3IiLCJwcmVkc1YiLCJzdWNzViIsInByZWRzIiwidW5pb24iLCJpc0xlYWYiLCJmaWx0ZXJOb2RlcyIsImNvcHkiLCJjb25zdHJ1Y3RvciIsImZpbmRQYXJlbnQiLCJzZXREZWZhdWx0RWRnZUxhYmVsIiwiZWRnZUNvdW50IiwiZWRnZXMiLCJ2YWx1ZXMiLCJzZXRQYXRoIiwicmVkdWNlIiwidmFsdWVTcGVjaWZpZWQiLCJhcmcwIiwiZWRnZUFyZ3NUb0lkIiwiZWRnZU9iaiIsImVkZ2VBcmdzVG9PYmoiLCJmcmVlemUiLCJpbmNyZW1lbnRPckluaXRFbnRyeSIsImVkZ2VPYmpUb0lkIiwiZGVjcmVtZW50T3JSZW1vdmVFbnRyeSIsImluRWRnZXMiLCJ1IiwiaW5WIiwib3V0ViIsInZfIiwid18iLCJ3cml0ZSIsInJlYWQiLCJ3cml0ZU5vZGVzIiwid3JpdGVFZGdlcyIsImNsb25lIiwibm9kZVZhbHVlIiwiZWRnZVZhbHVlIiwibG9kYXNoIiwid2luZG93IiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsImhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnIiwidGVzdCIsImZvbyIsIiRPYmplY3QiLCJvcmlnU3ltYm9sIiwiaGFzU3ltYm9sU2hhbSIsImhhc05hdGl2ZVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW0iLCJzeW1PYmoiLCJzeW1WYWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3ltcyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZGVzY3JpcHRvciIsIiRoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImdldE5hdGl2ZSIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwic2V0IiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSIsIl9fZGF0YV9fIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2siLCJkYXRhIiwidGhpc0FyZyIsImFycmF5RWFjaCIsImFycmF5IiwiaXRlcmF0ZWUiLCJhcnJheUZpbHRlciIsInByZWRpY2F0ZSIsInJlc0luZGV4IiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzSW5kZXgiLCJpc1R5cGVkQXJyYXkiLCJvYmplY3RQcm90byIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJhcnJheU1hcCIsImFycmF5UHVzaCIsImFycmF5UmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpbml0QWNjdW0iLCJhcnJheVNvbWUiLCJiYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsImFzc2lnblZhbHVlIiwib2JqZWN0Iiwib2JqVmFsdWUiLCJhc3NvY0luZGV4T2YiLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbiIsImtleXNJbiIsImJhc2VBc3NpZ25JbiIsImNsb25lQnVmZmVyIiwiY29weUFycmF5IiwiY29weVN5bWJvbHMiLCJjb3B5U3ltYm9sc0luIiwiZ2V0QWxsS2V5cyIsImdldEFsbEtleXNJbiIsImdldFRhZyIsImluaXRDbG9uZUFycmF5IiwiaW5pdENsb25lQnlUYWciLCJpbml0Q2xvbmVPYmplY3QiLCJpc01hcCIsImlzU2V0IiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsImNsb25lYWJsZVRhZ3MiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImlzRGVlcCIsImlzRmxhdCIsImlzRnVsbCIsInRhZyIsImlzRnVuYyIsInN0YWNrZWQiLCJzdWJWYWx1ZSIsImtleXNGdW5jIiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiYmFzZUNyZWF0ZSIsInByb3RvIiwiYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUVhY2giLCJiYXNlRmlsdGVyIiwiY29sbGVjdGlvbiIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZsYXR0ZW4iLCJpc1N0cmljdCIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yIiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXQiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUlzTmFOIiwic3RyaWN0SW5kZXhPZiIsImlzT2JqZWN0TGlrZSIsImJhc2VJc0FyZ3VtZW50cyIsImJhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwib3RoZXIiLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiYmFzZUlzTWFwIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJiYXNlSXNTZXQiLCJpc0xlbmd0aCIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VNYXRjaGVzIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImlkZW50aXR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImlzQXJyYXlMaWtlIiwiYmFzZU1hcCIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUmVkdWNlIiwiZWFjaEZ1bmMiLCJvdmVyUmVzdCIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJzdGFydCIsImJhc2VTZXRUb1N0cmluZyIsIm4iLCJpc1N5bWJvbCIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsImJhc2VVbmFyeSIsImNhY2hlSGFzIiwiY3JlYXRlU2V0Iiwic2V0VG9BcnJheSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJiYXNlVW5pcSIsImluY2x1ZGVzIiwiaXNDb21tb24iLCJzZWVuIiwib3V0ZXIiLCJjb21wdXRlZCIsInNlZW5JbmRleCIsImJhc2VWYWx1ZXMiLCJjYWNoZSIsImNhc3RGdW5jdGlvbiIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImJ1ZmZlciIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJyZUZsYWdzIiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJsYXN0SW5kZXgiLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsImNsb25lU3ltYm9sIiwic3ltYm9sIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsImlzTmV3IiwibmV3VmFsdWUiLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY29yZUpzRGF0YSIsIml0ZXJhYmxlIiwibm9vcCIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwibWFwVG9BcnJheSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiZ2V0VmFsdWUiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiQ3RvciIsImN0b3JTdHJpbmciLCJoYXNQYXRoIiwiaGFzRnVuYyIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJyZUhhc1VuaWNvZGUiLCJoYXNVbmljb2RlIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJpbnB1dCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJyZUlzVWludCIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJtYXNrU3JjS2V5IiwidWlkIiwiSUVfUFJPVE8iLCJhcnJheVByb3RvIiwibWVtb2l6ZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwiZnJlZVByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwiYmluZGluZyIsImFyZyIsIm5hdGl2ZU1heCIsIm90aGVyQXJncyIsImZyZWVTZWxmIiwic2hvcnRPdXQiLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIm5vdyIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicGFpcnMiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1NpemUiLCJjaGFyQ29kZUF0IiwicnNBc3RyYWwiLCJyc0NvbWJvIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyZU9wdE1vZCIsInJzT3B0VmFyIiwicnNPcHRKb2luIiwicnNTZXEiLCJyc1N5bWJvbCIsInJlVW5pY29kZSIsImRlZmF1bHRWYWx1ZSIsImlzQXJyYXlMaWtlT2JqZWN0Iiwic3R1YkZhbHNlIiwibmF0aXZlSXNCdWZmZXIiLCJhc3luY1RhZyIsInByb3h5VGFnIiwibm9kZUlzTWFwIiwibm9kZUlzU2V0Iiwibm9kZUlzVHlwZWRBcnJheSIsIlZFUlNJT04iLCJDT1JFX0VSUk9SX1RFWFQiLCJGVU5DX0VSUk9SX1RFWFQiLCJQTEFDRUhPTERFUiIsIldSQVBfQklORF9GTEFHIiwiV1JBUF9CSU5EX0tFWV9GTEFHIiwiV1JBUF9DVVJSWV9CT1VORF9GTEFHIiwiV1JBUF9DVVJSWV9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9QQVJUSUFMX0ZMQUciLCJXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyIsIldSQVBfQVJZX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJXUkFQX0ZMSVBfRkxBRyIsIkRFRkFVTFRfVFJVTkNfTEVOR1RIIiwiREVGQVVMVF9UUlVOQ19PTUlTU0lPTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiZG9tRXhjVGFnIiwid2Vha1NldFRhZyIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNjYXBlZEh0bWwiLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc0VzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwicmVFc2NhcGUiLCJyZUV2YWx1YXRlIiwicmVJbnRlcnBvbGF0ZSIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc1RlbXBsYXRlIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0RpbmdiYXRSYW5nZSIsInJzTG93ZXJSYW5nZSIsInJzTWF0aE9wUmFuZ2UiLCJyc05vbkNoYXJSYW5nZSIsInJzUHVuY3R1YXRpb25SYW5nZSIsInJzU3BhY2VSYW5nZSIsInJzVXBwZXJSYW5nZSIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyIsInJzQnJlYWsiLCJyc0RpZ2l0cyIsInJzRGluZ2JhdCIsInJzTG93ZXIiLCJyc01pc2MiLCJyc1VwcGVyIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJzT3JkTG93ZXIiLCJyc09yZFVwcGVyIiwicnNFbW9qaSIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJmcmVlUGFyc2VJbnQiLCJub2RlSXNBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXIiLCJub2RlSXNEYXRlIiwiaXNEYXRlIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJhcnJheUFnZ3JlZ2F0b3IiLCJzZXR0ZXIiLCJhcnJheUVhY2hSaWdodCIsImFycmF5RXZlcnkiLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXNjaWlUb0FycmF5IiwiYXNjaWlXb3JkcyIsImJhc2VGaW5kS2V5IiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJjdXJyZW50IiwiYmFzZVRvUGFpcnMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwibmV4dCIsImRvbmUiLCJyZXBsYWNlSG9sZGVycyIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJjb250ZXh0IiwiZGVmYXVsdHMiLCJwaWNrIiwiaWRDb3VudGVyIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJzeW1JdGVyYXRvciIsImN0eENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImN0eE5vdyIsImN0eFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsImNlaWwiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlSXNGaW5pdGUiLCJuYXRpdmVKb2luIiwibmF0aXZlTWluIiwibmF0aXZlUGFyc2VJbnQiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJuYXRpdmVSZXZlcnNlIiwibWV0YU1hcCIsInJlYWxOYW1lcyIsIkxhenlXcmFwcGVyIiwiTG9kYXNoV3JhcHBlciIsIndyYXBwZXJDbG9uZSIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImxhenlSZXZlcnNlIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNSaWdodCIsInZpZXciLCJnZXRWaWV3IiwiZW5kIiwiaXRlcmF0ZWVzIiwiaXRlckxlbmd0aCIsInRha2VDb3VudCIsImJhc2VXcmFwcGVyVmFsdWUiLCJpdGVySW5kZXgiLCJhcnJheVNhbXBsZSIsImJhc2VSYW5kb20iLCJhcnJheVNhbXBsZVNpemUiLCJzaHVmZmxlU2VsZiIsImJhc2VDbGFtcCIsImFycmF5U2h1ZmZsZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJiYXNlQWdncmVnYXRvciIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ29uZm9ybXMiLCJiYXNlQ29uZm9ybXNUbyIsImJhc2VEZWxheSIsIndhaXQiLCJiYXNlRGlmZmVyZW5jZSIsInZhbHVlc0xlbmd0aCIsInZhbHVlc0luZGV4IiwiYmFzZUVhY2hSaWdodCIsImJhc2VGb3JPd25SaWdodCIsImJhc2VFdmVyeSIsImJhc2VFeHRyZW11bSIsImJhc2VGaWxsIiwidG9JbnRlZ2VyIiwidG9MZW5ndGgiLCJiYXNlRm9yUmlnaHQiLCJiYXNlRnVuY3Rpb25zIiwiYmFzZUd0IiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwiY2FjaGVzIiwibWF4TGVuZ3RoIiwiSW5maW5pdHkiLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwiYmFzZUlzQXJyYXlCdWZmZXIiLCJiYXNlSXNEYXRlIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUx0IiwiYmFzZU1lcmdlIiwic3JjSW5kZXgiLCJiYXNlTWVyZ2VEZWVwIiwic2FmZUdldCIsIm1lcmdlRnVuYyIsImlzVHlwZWQiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU50aCIsImJhc2VPcmRlckJ5Iiwib3JkZXJzIiwiZ2V0SXRlcmF0ZWUiLCJjcml0ZXJpYSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VQaWNrIiwiYmFzZVBpY2tCeSIsImJhc2VTZXQiLCJiYXNlUHVsbEFsbCIsImJhc2VQdWxsQXQiLCJpbmRleGVzIiwicHJldmlvdXMiLCJiYXNlVW5zZXQiLCJiYXNlUmFuZ2UiLCJzdGVwIiwiYmFzZVJlcGVhdCIsImJhc2VTYW1wbGUiLCJiYXNlU2FtcGxlU2l6ZSIsIm5lc3RlZCIsImJhc2VTZXREYXRhIiwiYmFzZVNodWZmbGUiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwibWlkIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJhY3Rpb24iLCJiYXNlWG9yIiwiYmFzZVppcE9iamVjdCIsImFzc2lnbkZ1bmMiLCJ2YWxzTGVuZ3RoIiwiY2FzdEFycmF5TGlrZU9iamVjdCIsImNhc3RSZXN0IiwiY2FzdFNsaWNlIiwiaWQiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwiY29tcG9zZUFyZ3MiLCJwYXJ0aWFscyIsImhvbGRlcnMiLCJpc0N1cnJpZWQiLCJhcmdzSW5kZXgiLCJhcmdzTGVuZ3RoIiwiaG9sZGVyc0xlbmd0aCIsImxlZnRJbmRleCIsImxlZnRMZW5ndGgiLCJyYW5nZUxlbmd0aCIsImlzVW5jdXJyaWVkIiwiY29tcG9zZUFyZ3NSaWdodCIsImhvbGRlcnNJbmRleCIsInJpZ2h0SW5kZXgiLCJyaWdodExlbmd0aCIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJndWFyZCIsImlzSXRlcmF0ZWVDYWxsIiwiY3JlYXRlQmluZCIsImlzQmluZCIsImNyZWF0ZUN0b3IiLCJ3cmFwcGVyIiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsInRyYWlsaW5nIiwiY3JlYXRlQ29tcG91bmRlciIsIndvcmRzIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiZmxhdHRlbiIsIm90aGVyRnVuYyIsInRyYW5zZm9ybXMiLCJnZXRXcmFwRGV0YWlscyIsImluc2VydFdyYXBEZXRhaWxzIiwiaXNNYXNrYWJsZSIsInNyY0JpdG1hc2siLCJuZXdCaXRtYXNrIiwiaXNDb21ibyIsIm9sZEFycmF5IiwidXBkYXRlV3JhcERldGFpbHMiLCJyYW5kIiwiY2h1bmsiLCJjb21wYWN0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VCeSIsImRpZmZlcmVuY2VXaXRoIiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZyb21QYWlycyIsImhlYWQiLCJpbml0aWFsIiwiaW50ZXJzZWN0aW9uIiwibWFwcGVkIiwiaW50ZXJzZWN0aW9uQnkiLCJpbnRlcnNlY3Rpb25XaXRoIiwic2VwYXJhdG9yIiwibGFzdEluZGV4T2YiLCJudGgiLCJwdWxsIiwicHVsbEFsbCIsInB1bGxBbGxCeSIsInB1bGxBbGxXaXRoIiwicHVsbEF0IiwicmVtb3ZlIiwic29ydGVkSW5kZXgiLCJzb3J0ZWRJbmRleEJ5Iiwic29ydGVkSW5kZXhPZiIsInNvcnRlZExhc3RJbmRleCIsInNvcnRlZExhc3RJbmRleEJ5Iiwic29ydGVkTGFzdEluZGV4T2YiLCJzb3J0ZWRVbmlxIiwic29ydGVkVW5pcUJ5IiwidGFpbCIsInRha2UiLCJ0YWtlUmlnaHQiLCJ0YWtlUmlnaHRXaGlsZSIsInRha2VXaGlsZSIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlZCIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpbnZva2VNYXAiLCJrZXlCeSIsIm9yZGVyQnkiLCJwYXJ0aXRpb24iLCJyZWR1Y2VSaWdodCIsInJlamVjdCIsIm5lZ2F0ZSIsInNhbXBsZSIsInNhbXBsZVNpemUiLCJzaHVmZmxlIiwic29tZSIsInNvcnRCeSIsImFmdGVyIiwiYmVmb3JlIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsImxlYWRpbmdFZGdlIiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInRpbWVXYWl0aW5nIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiY2FuY2VsIiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiZGVmZXIiLCJkZWxheSIsImZsaXAiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJvbmNlIiwib3ZlckFyZ3MiLCJmdW5jc0xlbmd0aCIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJyZWFyZyIsInJlc3QiLCJzcHJlYWQiLCJ0aHJvdHRsZSIsInVuYXJ5Iiwid3JhcCIsImNhc3RBcnJheSIsImNsb25lV2l0aCIsImNsb25lRGVlcFdpdGgiLCJjb25mb3Jtc1RvIiwiZ3QiLCJndGUiLCJpc0VsZW1lbnQiLCJpc0VxdWFsIiwiaXNFcXVhbFdpdGgiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGUiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImluUmFuZ2UiLCJmbG9hdGluZyIsInRlbXAiLCJjYW1lbENhc2UiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwicG9zaXRpb24iLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsImxpbWl0Iiwic3RhcnRDYXNlIiwic3RhcnRzV2l0aCIsInRlbXBsYXRlIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwidmFyaWFibGUiLCJhdHRlbXB0IiwidG9Mb3dlciIsInRvVXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInNlYXJjaCIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZSIsInJhbmdlUmlnaHQiLCJzdHViT2JqZWN0Iiwic3R1YlN0cmluZyIsInN0dWJUcnVlIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGUiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInJvdW5kIiwic3VidHJhY3QiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bSIsInN1bUJ5IiwiZW50cmllc0luIiwiZXh0ZW5kIiwiZXh0ZW5kV2l0aCIsImVhY2hSaWdodCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJkZWZpbmUiLCJhbWQiLCJzdXBwb3J0ZWRMb2FkZXJzIiwiZmlsZSIsImh0dHAiLCJodHRwcyIsImRlZmF1bHRMb2FkZXIiLCJpbXBvcnRTY3JpcHRzIiwiZ2V0U2NoZW1lIiwiZ2V0TG9hZGVyIiwic2NoZW1lIiwibG9hZGVyIiwicHJvY2Vzc2VkIiwidW5zdXBwb3J0ZWRFcnJvciIsImdldEJhc2UiLCJyZXF1ZXN0Iiwic3VwcG9ydGVkSHR0cE1ldGhvZHMiLCJyZWFsTWV0aG9kIiwicmVhbFJlcXVlc3QiLCJtYWtlUmVxdWVzdCIsInJlcSIsImVycjIiLCJwcmVwYXJlUmVxdWVzdCIsIkVtaXR0ZXIiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9jYWxsYmFja3MiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYWxsYmFja3MiLCJjYiIsImVtaXQiLCJsZW4iLCJsaXN0ZW5lcnMiLCJoYXNMaXN0ZW5lcnMiLCJBZ2VudCIsIl9kZWZhdWx0cyIsImNvbnNvbGUiLCJ3YXJuIiwic2FmZVN0cmluZ2lmeSIsIlJlcXVlc3RCYXNlIiwiUmVzcG9uc2VCYXNlIiwiUmVxdWVzdCIsImdldFhIUiIsIlhNTEh0dHBSZXF1ZXN0IiwicyIsInB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyIiwic3Via2V5Iiwic2VyaWFsaXplT2JqZWN0IiwicGFyc2VTdHJpbmciLCJzdHJpbmdfIiwicG9zIiwibGVuZ3RoXyIsImh0bWwiLCJ4bWwiLCJ1cmxlbmNvZGVkIiwiZm9ybSIsImluZGljZXMiLCJzdHJpY3ROdWxsSGFuZGxpbmciLCJwYXJzZUhlYWRlciIsImxpbmVzIiwiZmllbGRzIiwibGluZSIsImZpZWxkIiwiaXNKU09OIiwibWltZSIsIlJlc3BvbnNlIiwicmVxdWVzdF8iLCJ4aHIiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwic3RhdHVzIiwiX3NldFN0YXR1c1Byb3BlcnRpZXMiLCJoZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiaGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJfc2V0SGVhZGVyUHJvcGVydGllcyIsIl9yZXNwb25zZVR5cGUiLCJib2R5IiwicmVzcG9uc2UiLCJfcGFyc2VCb2R5IiwiX3BhcnNlciIsInRvRXJyb3IiLCJfcXVlcnkiLCJfaGVhZGVyIiwib3JpZ2luYWwiLCJyYXdSZXNwb25zZSIsInN0YXR1c0NvZGUiLCJuZXdfZXJyb3IiLCJfaXNSZXNwb25zZU9LIiwiYWNjZXB0IiwiYXV0aCIsInVzZXIiLCJwYXNzIiwiYnRvYSIsImVuY29kZXIiLCJfYXV0aCIsImF0dGFjaCIsIl9kYXRhIiwiX2dldEZvcm1EYXRhIiwiYXBwZW5kIiwiX2Zvcm1EYXRhIiwiRm9ybURhdGEiLCJfc2hvdWxkUmV0cnkiLCJfcmV0cnkiLCJfY2FsbGJhY2siLCJfbWF4UmV0cmllcyIsInJldHJpZXMiLCJfcmV0cmllcyIsImNyb3NzRG9tYWluRXJyb3IiLCJjcm9zc0RvbWFpbiIsImFnZW50IiwiY2EiLCJwaXBlIiwiX2lzSG9zdCIsIl9lbmRDYWxsZWQiLCJfZmluYWxpemVRdWVyeVN0cmluZyIsIl9lbmQiLCJfc2V0VXBsb2FkVGltZW91dCIsIl91cGxvYWRUaW1lb3V0IiwiX3VwbG9hZFRpbWVvdXRUaW1lciIsIl90aW1lb3V0RXJyb3IiLCJfYWJvcnRlZCIsIl9zZXRUaW1lb3V0cyIsInJlYWR5U3RhdGUiLCJfcmVzcG9uc2VUaW1lb3V0VGltZXIiLCJ0aW1lZG91dCIsImhhbmRsZVByb2dyZXNzIiwiZGlyZWN0aW9uIiwidG90YWwiLCJwZXJjZW50IiwibG9hZGVkIiwidXBsb2FkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm9wZW4iLCJfd2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiY29udGVudFR5cGUiLCJfc2VyaWFsaXplciIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwiX3NldERlZmF1bHRzIiwiZGVsIiwicGF0Y2giLCJwb3N0IiwicHV0IiwiX3RpbWVyIiwidGltZW91dCIsIl90aW1lb3V0IiwiX3Jlc3BvbnNlVGltZW91dCIsIm9wdGlvbiIsImRlYWRsaW5lIiwicmV0cnkiLCJfcmV0cnlDYWxsYmFjayIsIkVSUk9SX0NPREVTIiwiU1RBVFVTX0NPREVTIiwib3ZlcnJpZGUiLCJjb2RlIiwidGltZWRvdXRFcnJvciIsIl9mdWxsZmlsbGVkUHJvbWlzZSIsInVzZSIsIm9rIiwiX29rQ2FsbGJhY2siLCJnZXRIZWFkZXIiLCJhYm9ydCIsImJhc2U2NEVuY29kZXIiLCJyZWRpcmVjdHMiLCJfbWF4UmVkaXJlY3RzIiwibWF4UmVzcG9uc2VTaXplIiwiX21heFJlc3BvbnNlU2l6ZSIsImlzT2JqZWN0XyIsInNvcnRRdWVyeSIsIl9zb3J0IiwicXVlcnlBcnJheSIsIl9hcHBlbmRRdWVyeVN0cmluZyIsInJlYXNvbiIsImVycm5vIiwidXRpbHMiLCJjdCIsInBhcmFtZXRlcnMiLCJwYXJhbXMiLCJsaW5rcyIsImxpbmsiLCJwYXJzZUxpbmtzIiwidHJ1bmMiLCJzdGF0dXNUeXBlIiwiaW5mbyIsInJlZGlyZWN0IiwiY2xpZW50RXJyb3IiLCJzZXJ2ZXJFcnJvciIsImNyZWF0ZWQiLCJhY2NlcHRlZCIsIm5vQ29udGVudCIsImJhZFJlcXVlc3QiLCJ1bmF1dGhvcml6ZWQiLCJub3RBY2NlcHRhYmxlIiwiZm9yYmlkZGVuIiwibm90Rm91bmQiLCJ1bnByb2Nlc3NhYmxlRW50aXR5IiwicmVsIiwiY2xlYW5IZWFkZXIiLCJjaGFuZ2VzT3JpZ2luIiwiaG9zdCIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJpc0d6aXBPckRlZmxhdGVFbmNvZGluZyIsImlzQnJvdGxpRW5jb2RpbmciLCJVTUQiLCJkZWZpbml0aW9uIiwiJEFNRCQiLCJERUYiLCJidWlsdEluUHJvcCIsImN5Y2xlIiwic2NoZWR1bGluZ19xdWV1ZSIsIlRvU3RyaW5nIiwidGltZXIiLCJzZXRJbW1lZGlhdGUiLCJjb25maWciLCJRdWV1ZSIsIkl0ZW0iLCJkcmFpbiIsImYiLCJzY2hlZHVsZSIsImlzVGhlbmFibGUiLCJvIiwiX3RoZW4iLCJvX3R5cGUiLCJub3RpZnkiLCJub3RpZnlJc29sYXRlZCIsInN0YXRlIiwic3VjY2VzcyIsImZhaWx1cmUiLCJyZXQiLCJtc2ciLCJwcm9taXNlIiwidHJpZ2dlcmVkIiwiZGVmX3dyYXBwZXIiLCJNYWtlRGVmV3JhcHBlciIsIiRyZXNvbHZlJCIsIiRyZWplY3QkIiwiaXRlcmF0ZVByb21pc2VzIiwiQ29uc3RydWN0b3IiLCJyZWplY3RlciIsImlkeCIsIklJRkUiLCIkcmVzb2x2ZXIkIiwiTWFrZURlZiIsImV4ZWN1dG9yIiwiX19OUE9fXyIsImV4dHJhY3RDaGFpbiIsIiRjYXRjaCQiLCJwdWJsaWNSZXNvbHZlIiwicHVibGljUmVqZWN0IiwiUHJvbWlzZVByb3RvdHlwZSIsIlByb21pc2UkcmVzb2x2ZSIsIlByb21pc2UkcmVqZWN0IiwiUHJvbWlzZSRhbGwiLCJtc2dzIiwiUHJvbWlzZSRyYWNlIiwiYXNzZXJ0UGF0aCIsIm5vcm1hbGl6ZVN0cmluZ1Bvc2l4IiwiYWxsb3dBYm92ZVJvb3QiLCJsYXN0U2VnbWVudExlbmd0aCIsImxhc3RTbGFzaCIsImRvdHMiLCJsYXN0U2xhc2hJbmRleCIsIl9mb3JtYXQiLCJzZXAiLCJwYXRoT2JqZWN0IiwiYmFzZSIsImV4dCIsInBvc2l4IiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsIm5vcm1hbGl6ZSIsInRyYWlsaW5nU2VwYXJhdG9yIiwiam9pbmVkIiwicmVsYXRpdmUiLCJmcm9tIiwidG8iLCJmcm9tU3RhcnQiLCJmcm9tRW5kIiwiZnJvbUxlbiIsInRvU3RhcnQiLCJ0b0VuZCIsInRvTGVuIiwibGFzdENvbW1vblNlcCIsImZyb21Db2RlIiwidG9Db2RlIiwib3V0IiwiX21ha2VMb25nIiwiaGFzUm9vdCIsIm1hdGNoZWRTbGFzaCIsImJhc2VuYW1lIiwiZXh0SWR4IiwiZmlyc3ROb25TbGFzaEVuZCIsImV4dG5hbWUiLCJzdGFydERvdCIsInN0YXJ0UGFydCIsInByZURvdFN0YXRlIiwiZm9ybWF0IiwiZGVsaW1pdGVyIiwid2luMzIiLCJwZXJjZW50VHdlbnRpZXMiLCJGb3JtYXQiLCJSRkMxNzM4IiwiUkZDMzk4NiIsImZvcm1hdHRlcnMiLCJmb3JtYXRzIiwiYWxsb3dEb3RzIiwiYWxsb3dFbXB0eUFycmF5cyIsImFsbG93UHJvdG90eXBlcyIsImFsbG93U3BhcnNlIiwiYXJyYXlMaW1pdCIsImNoYXJzZXQiLCJjaGFyc2V0U2VudGluZWwiLCJjb21tYSIsImRlY29kZURvdEluS2V5cyIsImRlY29kZXIiLCJkZWNvZGUiLCJkdXBsaWNhdGVzIiwiaWdub3JlUXVlcnlQcmVmaXgiLCJpbnRlcnByZXROdW1lcmljRW50aXRpZXMiLCJwYXJhbWV0ZXJMaW1pdCIsInBhcnNlQXJyYXlzIiwicGxhaW5PYmplY3RzIiwic3RyaWN0RGVwdGgiLCIkMCIsIm51bWJlclN0ciIsImZyb21DaGFyQ29kZSIsInBhcnNlQXJyYXlWYWx1ZSIsImlzb1NlbnRpbmVsIiwicGFyc2VWYWx1ZXMiLCJwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzIiwiY2xlYW5TdHIiLCJza2lwSW5kZXgiLCJicmFja2V0RXF1YWxzUG9zIiwibWF5YmVNYXAiLCJlbmNvZGVkVmFsIiwiZXhpc3RpbmciLCJjb21iaW5lIiwicGFyc2VPYmplY3QiLCJ2YWx1ZXNQYXJzZWQiLCJsZWFmIiwiY2xlYW5Sb290IiwiZGVjb2RlZFJvb3QiLCJwYXJzZUtleXMiLCJwYXJzZVF1ZXJ5U3RyaW5nS2V5cyIsImdpdmVuS2V5IiwiYnJhY2tldHMiLCJub3JtYWxpemVQYXJzZU9wdGlvbnMiLCJ0ZW1wT2JqIiwibmV3T2JqIiwiZ2V0U2lkZUNoYW5uZWwiLCJhcnJheVByZWZpeEdlbmVyYXRvcnMiLCJwdXNoVG9BcnJheSIsInZhbHVlT3JBcnJheSIsInRvSVNPIiwidG9JU09TdHJpbmciLCJkZWZhdWx0Rm9ybWF0IiwiYWRkUXVlcnlQcmVmaXgiLCJhcnJheUZvcm1hdCIsImVuY29kZSIsImVuY29kZURvdEluS2V5cyIsImVuY29kZVZhbHVlc09ubHkiLCJmb3JtYXR0ZXIiLCJzZXJpYWxpemVEYXRlIiwiZGF0ZSIsInNraXBOdWxscyIsImlzTm9uTnVsbGlzaFByaW1pdGl2ZSIsInNlbnRpbmVsIiwiZ2VuZXJhdGVBcnJheVByZWZpeCIsImNvbW1hUm91bmRUcmlwIiwic2lkZUNoYW5uZWwiLCJ0bXBTYyIsImZpbmRGbGFnIiwia2V5VmFsdWUiLCJvYmpLZXlzIiwiZW5jb2RlZFByZWZpeCIsImFkanVzdGVkUHJlZml4IiwiZW5jb2RlZEtleSIsImtleVByZWZpeCIsInZhbHVlU2lkZUNoYW5uZWwiLCJub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zIiwiaGV4VGFibGUiLCJjb21wYWN0UXVldWUiLCJxdWV1ZSIsImNvbXBhY3RlZCIsImFycmF5VG9PYmplY3QiLCJtZXJnZVRhcmdldCIsInRhcmdldEl0ZW0iLCJhc3NpZ25TaW5nbGVTb3VyY2UiLCJzdHJXaXRob3V0UGx1cyIsImRlZmF1bHRFbmNvZGVyIiwia2luZCIsImMiLCJtYXhLZXlzIiwia3N0ciIsInZzdHIiLCJ4cyIsInN0cmluZ2lmeVByaW1pdGl2ZSIsIm9iamVjdEtleXMiLCJrcyIsImhhc0Rlc2NyaXB0b3JzIiwiZ09QRCIsIiRmbG9vciIsImZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUiLCJmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUiLCJjYWxsQm91bmQiLCJpbnNwZWN0IiwiJFdlYWtNYXAiLCIkTWFwIiwiJHdlYWtNYXBHZXQiLCIkd2Vha01hcFNldCIsIiR3ZWFrTWFwSGFzIiwiJG1hcEdldCIsIiRtYXBTZXQiLCIkbWFwSGFzIiwibGlzdEdldE5vZGUiLCJsaXN0IiwicHJldiIsImN1cnIiLCJsaXN0R2V0Iiwib2JqZWN0cyIsImxpc3RTZXQiLCJsaXN0SGFzIiwiJHdtIiwiJG0iLCIkbyIsImNoYW5uZWwiLCJhc3NlcnQiLCJoYXNNYXAiLCJtYXBTaXplRGVzY3JpcHRvciIsIm1hcFNpemUiLCJtYXBGb3JFYWNoIiwiaGFzU2V0Iiwic2V0U2l6ZURlc2NyaXB0b3IiLCJzZXRTaXplIiwic2V0Rm9yRWFjaCIsImhhc1dlYWtNYXAiLCJ3ZWFrTWFwSGFzIiwiaGFzV2Vha1NldCIsIndlYWtTZXRIYXMiLCJoYXNXZWFrUmVmIiwid2Vha1JlZkRlcmVmIiwiZGVyZWYiLCJib29sZWFuVmFsdWVPZiIsImZ1bmN0aW9uVG9TdHJpbmciLCIkbWF0Y2giLCIkc2xpY2UiLCIkdG9VcHBlckNhc2UiLCIkdG9Mb3dlckNhc2UiLCIkdGVzdCIsIiRqb2luIiwiJGFyclNsaWNlIiwiYmlnSW50VmFsdWVPZiIsImdPUFMiLCJzeW1Ub1N0cmluZyIsImhhc1NoYW1tZWRTeW1ib2xzIiwiaXNFbnVtZXJhYmxlIiwiZ1BPIiwiTyIsImFkZE51bWVyaWNTZXBhcmF0b3IiLCJudW0iLCJzZXBSZWdleCIsImludCIsImludFN0ciIsImRlYyIsInV0aWxJbnNwZWN0IiwiaW5zcGVjdEN1c3RvbSIsImN1c3RvbSIsImluc3BlY3RTeW1ib2wiLCJpbnNwZWN0XyIsInF1b3RlU3R5bGUiLCJtYXhTdHJpbmdMZW5ndGgiLCJjdXN0b21JbnNwZWN0IiwiaW5kZW50IiwibnVtZXJpY1NlcGFyYXRvciIsImluc3BlY3RTdHJpbmciLCJiaWdJbnRTdHIiLCJtYXhEZXB0aCIsImdldEluZGVudCIsIm5vSW5kZW50IiwibmV3T3B0cyIsIm5hbWVPZiIsImFyck9iaktleXMiLCJzeW1TdHJpbmciLCJtYXJrQm94ZWQiLCJub2RlTmFtZSIsImF0dHJzIiwiYXR0cmlidXRlcyIsIndyYXBRdW90ZXMiLCJjaGlsZE5vZGVzIiwic2luZ2xlTGluZVZhbHVlcyIsImluZGVudGVkSm9pbiIsImNhdXNlIiwibWFwUGFydHMiLCJjb2xsZWN0aW9uT2YiLCJzZXRQYXJ0cyIsIndlYWtDb2xsZWN0aW9uT2YiLCJpc1dlYWtSZWYiLCJpc0JpZ0ludCIsImdsb2JhbFRoaXMiLCJ5cyIsInByb3RvVGFnIiwiY29uc3RydWN0b3JUYWciLCJkZWZhdWx0U3R5bGUiLCJxdW90ZUNoYXIiLCJtIiwiSFRNTEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0cmFpbGVyIiwibG93Ynl0ZSIsImpvaW5lZEVudHJpZXMiLCJiYXNlSW5kZW50IiwibGluZUpvaW5lciIsInN5bU1hcCIsImlzRXh0ZW5kZWRMZW5ndGhQYXRoIiwiaGFzTm9uQXNjaWkiLCJTQ0hFTUVTIiwibWFpbHRvIiwidXJuIiwidXVpZCIsIlVVSUQiLCJoYW5kbGVyIiwidXVpZENvbXBvbmVudHMiLCJ1cm5Db21wb25lbnRzIiwiVVJOX1BBUlNFIiwibmlkIiwibnNzIiwidXJuU2NoZW1lIiwic2NoZW1lSGFuZGxlciIsInVyaUNvbXBvbmVudHMiLCJpc0lSSSIsIlVOUkVTRVJWRUQkJCIsIkhFWERJRyQkIiwiUENUX0VOQ09ERUQkIiwic3ViZXhwIiwiQVRFWFQkJCIsIlFURVhUJCQiLCJWQ0hBUiQkIiwiU09NRV9ERUxJTVMkJCIsIlVOUkVTRVJWRUQiLCJQQ1RfRU5DT0RFRCIsIk5PVF9MT0NBTF9QQVJUIiwiTk9UX0hGTkFNRSIsIk5PVF9IRlZBTFVFIiwiZGVjU3RyIiwicGN0RGVjQ2hhcnMiLCJtYWlsdG9Db21wb25lbnRzIiwidW5rbm93bkhlYWRlcnMiLCJoZmllbGRzIiwieGwiLCJoZmllbGQiLCJ0b0FkZHJzIiwidW5lc2NhcGVDb21wb25lbnQiLCJhZGRyIiwicHVueWNvZGUiLCJ0b0FkZHIiLCJhdElkeCIsImxvY2FsUGFydCIsImRvbWFpbiIsIm5ld1N0ciIsImlsIiwiYzIiLCJjMyIsImRlY29kZVVucmVzZXJ2ZWQiLCJwcm90b2NvbCIsImFkZHJlc3MiLCJ6b25lIiwiZmlyc3RGaWVsZHMiLCJsYXN0RmllbGRzIiwiaXNMYXN0RmllbGRJUHY0QWRkcmVzcyIsImZpZWxkQ291bnQiLCJsYXN0RmllbGRzU3RhcnQiLCJfbm9ybWFsaXplSVB2NCIsImFsbFplcm9GaWVsZHMiLCJsYXN0TG9uZ2VzdCIsImxvbmdlc3RaZXJvRmllbGRzIiwibmV3SG9zdCIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsIlVSSV9QQVJTRSIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsInVyaVN0cmluZyIsIl9ub3JtYWxpemVJUHY2IiwidXJpVG9rZW5zIiwiJDIiLCJSRFMxIiwiUkRTMiIsIlJEUzMiLCJSRFM1Iiwib3V0cHV0IiwiaW0iLCJhdXRob3JpdHkiLCJfcmVjb21wb3NlQXV0aG9yaXR5IiwicmVtb3ZlRG90U2VnbWVudHMiLCJza2lwTm9ybWFsaXphdGlvbiIsInNjaGVtZWxlc3NPcHRpb25zIiwicmVzb2x2ZUNvbXBvbmVudHMiLCJ0eXBlT2YiLCJ1cmlBIiwiVVJJX1BST1RPQ09MIiwiSVJJX1BST1RPQ09MIiwibWF4SW50IiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJsYWJlbHMiLCJlbmNvZGVkIiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImNvZGVQb2ludCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiZmxhZyIsImFkYXB0IiwiZmlyc3RUaW1lIiwiZGVsdGEiLCJpbnB1dExlbmd0aCIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ0IiwiYmFzZU1pbnVzVCIsInVjczJkZWNvZGUiLCJjdXJyZW50VmFsdWUiLCJiYXNpY0xlbmd0aCIsImhhbmRsZWRDUENvdW50IiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwiYnVpbGRFeHBzIiwiQUxQSEEkJCIsIkNSJCIsIkRJR0lUJCQiLCJEUVVPVEUkJCIsIlNQJCQiLCJTVUJfREVMSU1TJCQiLCJSRVNFUlZFRCQkIiwiVUNTQ0hBUiQkIiwiU0NIRU1FJCIsIlVTRVJJTkZPJCIsIkRFQ19PQ1RFVCQiLCJERUNfT0NURVRfUkVMQVhFRCQiLCJIMTYkIiwiTFMzMiQiLCJJUFY2QUREUkVTUzEkIiwiWk9ORUlEJCIsIklQVjZBRERSRVNTJCIsIklQX0xJVEVSQUwkIiwiSVBWNkFERFJaX1JFTEFYRUQkIiwiSE9TVCQiLCJQT1JUJCIsIkFVVEhPUklUWSQiLCJQQ0hBUiQiLCJTRUdNRU5UJCIsIlNFR01FTlRfTlokIiwiU0VHTUVOVF9OWl9OQyQiLCJQQVRIX0FCRU1QVFkkIiwiUEFUSF9BQlNPTFVURSQiLCJQQVRIJCIsIlFVRVJZJCIsIkZSQUdNRU5UJCIsIkhJRVJfUEFSVCQiLCJVUkkkIiwiUkVMQVRJVkVfUEFSVCQiLCJSRUxBVElWRSQiLCJVUklfUkVGRVJFTkNFJCIsIkFCU09MVVRFX1VSSSQiLCJHRU5FUklDX1JFRiQiLCJSRUxBVElWRV9SRUYkIiwiQUJTT0xVVEVfUkVGJCIsIlNBTUVET0NfUkVGJCIsIkFVVEhPUklUWV9SRUYkIiwic2V0cyJdLCJzb3VyY2VSb290IjoiIn0=